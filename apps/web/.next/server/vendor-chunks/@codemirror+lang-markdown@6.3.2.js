"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+lang-markdown@6.3.2";
exports.ids = ["vendor-chunks/@codemirror+lang-markdown@6.3.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@codemirror+lang-markdown@6.3.2/node_modules/@codemirror/lang-markdown/dist/index.js":
/*!*********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@codemirror+lang-markdown@6.3.2/node_modules/@codemirror/lang-markdown/dist/index.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   commonmarkLanguage: () => (/* binding */ commonmarkLanguage),\n/* harmony export */   deleteMarkupBackward: () => (/* binding */ deleteMarkupBackward),\n/* harmony export */   insertNewlineContinueMarkup: () => (/* binding */ insertNewlineContinueMarkup),\n/* harmony export */   markdown: () => (/* binding */ markdown),\n/* harmony export */   markdownKeymap: () => (/* binding */ markdownKeymap),\n/* harmony export */   markdownLanguage: () => (/* binding */ markdownLanguage)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/../../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/../../node_modules/.pnpm/@codemirror+view@6.36.7/node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/../../node_modules/.pnpm/@codemirror+language@6.11.0/node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @codemirror/autocomplete */ \"(ssr)/../../node_modules/.pnpm/@codemirror+autocomplete@6.18.6/node_modules/@codemirror/autocomplete/dist/index.js\");\n/* harmony import */ var _lezer_markdown__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/markdown */ \"(ssr)/../../node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js\");\n/* harmony import */ var _codemirror_lang_html__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/lang-html */ \"(ssr)/../../node_modules/.pnpm/@codemirror+lang-html@6.4.9/node_modules/@codemirror/lang-html/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/../../node_modules/.pnpm/@lezer+common@1.2.3/node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n\n\n\n\nconst data = /*@__PURE__*/(0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.defineLanguageFacet)({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_1__.NodeProp();\nconst commonmark = /*@__PURE__*/_lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.parser.configure({\n    props: [\n        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldService.of((state, start, end) => {\n    for (let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([_lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.GFM, _lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.Subscript, _lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.Superscript, _lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.Emoji, {\n        props: [\n            /*@__PURE__*/_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageDescription)\n                return found.support ? found.support.language.parser : _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [], context = [];\n    for (let cur = node; cur; cur = cur.parent) {\n        if (cur.name == \"FencedCode\")\n            return context;\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.indentUnit) != \"\\t\")\n        return content;\n    let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, 0))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e\n            ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, 4, Math.min(line.text.length, context[i + 1].from)) - insert.length\n            : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, 4, inner.to) - (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/(0,_codemirror_lang_html__WEBPACK_IMPORTED_MODULE_4__.html)({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;\n    if (!(parser instanceof _lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlTagLanguage.support], defaultCode;\n    if (defaultCodeLanguage instanceof _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push((0,_lezer_markdown__WEBPACK_IMPORTED_MODULE_0__.parseCode)({ codeParser, htmlParser: htmlTagLanguage.language.parser }));\n    if (addKeymap)\n        support.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(_codemirror_view__WEBPACK_IMPORTED_MODULE_5__.keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxTree)(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = (0,_codemirror_lang_html__WEBPACK_IMPORTED_MODULE_4__.htmlCompletionSource)(new _codemirror_autocomplete__WEBPACK_IMPORTED_MODULE_6__.CompletionContext(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK2xhbmctbWFya2Rvd25ANi4zLjIvbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmctbWFya2Rvd24vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9GO0FBQzFDO0FBQ29LO0FBQ2pKO0FBQzJDO0FBQ3JDO0FBQzFCOztBQUV6QywwQkFBMEIseUVBQW1CLEdBQUcsaUJBQWlCLFNBQVMsZ0NBQWdDO0FBQzFHLHFDQUFxQyxtREFBUTtBQUM3QyxnQ0FBZ0MsbURBQU07QUFDdEM7QUFDQSxxQkFBcUIsOERBQVk7QUFDakM7QUFDQSxzQ0FBc0MsbURBQW1EO0FBQ3pGLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixnRUFBYztBQUNuQztBQUNBLFNBQVM7QUFDVCxxQkFBcUIsa0VBQWdCO0FBQ3JDO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBVztBQUM3QyxvQkFBb0IsZ0VBQVUsK0JBQStCLE1BQU07QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGVBQWUsMERBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnREFBRyxFQUFFLHNEQUFTLEVBQUUsd0RBQVcsRUFBRSxrREFBSztBQUN0RjtBQUNBLHlCQUF5Qiw4REFBWTtBQUNyQywyQ0FBMkMsbURBQW1EO0FBQzlGLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFF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bnNpZ2h0bG9vcFxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGNvZGVtaXJyb3IrbGFuZy1tYXJrZG93bkA2LjMuMlxcbm9kZV9tb2R1bGVzXFxAY29kZW1pcnJvclxcbGFuZy1tYXJrZG93blxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWRpdG9yU2VsZWN0aW9uLCBjb3VudENvbHVtbiwgUHJlYywgRWRpdG9yU3RhdGUgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgeyBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGRlZmluZUxhbmd1YWdlRmFjZXQsIGZvbGROb2RlUHJvcCwgaW5kZW50Tm9kZVByb3AsIGxhbmd1YWdlRGF0YVByb3AsIGZvbGRTZXJ2aWNlLCBzeW50YXhUcmVlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgUGFyc2VDb250ZXh0LCBpbmRlbnRVbml0LCBMYW5ndWFnZVN1cHBvcnQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5pbXBvcnQgeyBDb21wbGV0aW9uQ29udGV4dCB9IGZyb20gJ0Bjb2RlbWlycm9yL2F1dG9jb21wbGV0ZSc7XG5pbXBvcnQgeyBwYXJzZXIsIEdGTSwgU3Vic2NyaXB0LCBTdXBlcnNjcmlwdCwgRW1vamksIE1hcmtkb3duUGFyc2VyLCBwYXJzZUNvZGUgfSBmcm9tICdAbGV6ZXIvbWFya2Rvd24nO1xuaW1wb3J0IHsgaHRtbCwgaHRtbENvbXBsZXRpb25Tb3VyY2UgfSBmcm9tICdAY29kZW1pcnJvci9sYW5nLWh0bWwnO1xuaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxuY29uc3QgZGF0YSA9IC8qQF9fUFVSRV9fKi9kZWZpbmVMYW5ndWFnZUZhY2V0KHsgY29tbWVudFRva2VuczogeyBibG9jazogeyBvcGVuOiBcIjwhLS1cIiwgY2xvc2U6IFwiLS0+XCIgfSB9IH0pO1xuY29uc3QgaGVhZGluZ1Byb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5jb25zdCBjb21tb25tYXJrID0gLypAX19QVVJFX18qL3BhcnNlci5jb25maWd1cmUoe1xuICAgIHByb3BzOiBbXG4gICAgICAgIC8qQF9fUFVSRV9fKi9mb2xkTm9kZVByb3AuYWRkKHR5cGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICF0eXBlLmlzKFwiQmxvY2tcIikgfHwgdHlwZS5pcyhcIkRvY3VtZW50XCIpIHx8IGlzSGVhZGluZyh0eXBlKSAhPSBudWxsIHx8IGlzTGlzdCh0eXBlKSA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogKHRyZWUsIHN0YXRlKSA9PiAoeyBmcm9tOiBzdGF0ZS5kb2MubGluZUF0KHRyZWUuZnJvbSkudG8sIHRvOiB0cmVlLnRvIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgLypAX19QVVJFX18qL2hlYWRpbmdQcm9wLmFkZChpc0hlYWRpbmcpLFxuICAgICAgICAvKkBfX1BVUkVfXyovaW5kZW50Tm9kZVByb3AuYWRkKHtcbiAgICAgICAgICAgIERvY3VtZW50OiAoKSA9PiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAvKkBfX1BVUkVfXyovbGFuZ3VhZ2VEYXRhUHJvcC5hZGQoe1xuICAgICAgICAgICAgRG9jdW1lbnQ6IGRhdGFcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbmZ1bmN0aW9uIGlzSGVhZGluZyh0eXBlKSB7XG4gICAgbGV0IG1hdGNoID0gL14oPzpBVFh8U2V0ZXh0KUhlYWRpbmcoXFxkKSQvLmV4ZWModHlwZS5uYW1lKTtcbiAgICByZXR1cm4gbWF0Y2ggPyArbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0xpc3QodHlwZSkge1xuICAgIHJldHVybiB0eXBlLm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiIHx8IHR5cGUubmFtZSA9PSBcIkJ1bGxldExpc3RcIjtcbn1cbmZ1bmN0aW9uIGZpbmRTZWN0aW9uRW5kKGhlYWRlck5vZGUsIGxldmVsKSB7XG4gICAgbGV0IGxhc3QgPSBoZWFkZXJOb2RlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBsYXN0Lm5leHRTaWJsaW5nLCBoZWFkaW5nO1xuICAgICAgICBpZiAoIW5leHQgfHwgKGhlYWRpbmcgPSBpc0hlYWRpbmcobmV4dC50eXBlKSkgIT0gbnVsbCAmJiBoZWFkaW5nIDw9IGxldmVsKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxhc3QgPSBuZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbGFzdC50bztcbn1cbmNvbnN0IGhlYWRlckluZGVudCA9IC8qQF9fUFVSRV9fKi9mb2xkU2VydmljZS5vZigoc3RhdGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgICBmb3IgKGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKGVuZCwgLTEpOyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA8IHN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBoZWFkaW5nID0gbm9kZS50eXBlLnByb3AoaGVhZGluZ1Byb3ApO1xuICAgICAgICBpZiAoaGVhZGluZyA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCB1cHRvID0gZmluZFNlY3Rpb25FbmQobm9kZSwgaGVhZGluZyk7XG4gICAgICAgIGlmICh1cHRvID4gZW5kKVxuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZW5kLCB0bzogdXB0byB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuZnVuY3Rpb24gbWtMYW5nKHBhcnNlcikge1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2UoZGF0YSwgcGFyc2VyLCBbaGVhZGVySW5kZW50XSwgXCJtYXJrZG93blwiKTtcbn1cbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3Igc3RyaWN0IENvbW1vbk1hcmsuXG4qL1xuY29uc3QgY29tbW9ubWFya0xhbmd1YWdlID0gLypAX19QVVJFX18qL21rTGFuZyhjb21tb25tYXJrKTtcbmNvbnN0IGV4dGVuZGVkID0gLypAX19QVVJFX18qL2NvbW1vbm1hcmsuY29uZmlndXJlKFtHRk0sIFN1YnNjcmlwdCwgU3VwZXJzY3JpcHQsIEVtb2ppLCB7XG4gICAgICAgIHByb3BzOiBbXG4gICAgICAgICAgICAvKkBfX1BVUkVfXyovZm9sZE5vZGVQcm9wLmFkZCh7XG4gICAgICAgICAgICAgICAgVGFibGU6ICh0cmVlLCBzdGF0ZSkgPT4gKHsgZnJvbTogc3RhdGUuZG9jLmxpbmVBdCh0cmVlLmZyb20pLnRvLCB0bzogdHJlZS50byB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgIH1dKTtcbi8qKlxuTGFuZ3VhZ2Ugc3VwcG9ydCBmb3IgW0dGTV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vKSBwbHVzXG5zdWJzY3JpcHQsIHN1cGVyc2NyaXB0LCBhbmQgZW1vamkgc3ludGF4LlxuKi9cbmNvbnN0IG1hcmtkb3duTGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovbWtMYW5nKGV4dGVuZGVkKTtcbmZ1bmN0aW9uIGdldENvZGVQYXJzZXIobGFuZ3VhZ2VzLCBkZWZhdWx0TGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gKGluZm8pID0+IHtcbiAgICAgICAgaWYgKGluZm8gJiYgbGFuZ3VhZ2VzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU3RyaXAgYW55dGhpbmcgYWZ0ZXIgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaW5mbyA9IC9cXFMqLy5leGVjKGluZm8pWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gbGFuZ3VhZ2VzKGluZm8pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGZvdW5kID0gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5tYXRjaExhbmd1YWdlTmFtZShsYW5ndWFnZXMsIGluZm8sIHRydWUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kIGluc3RhbmNlb2YgTGFuZ3VhZ2VEZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQuc3VwcG9ydCA/IGZvdW5kLnN1cHBvcnQubGFuZ3VhZ2UucGFyc2VyIDogUGFyc2VDb250ZXh0LmdldFNraXBwaW5nUGFyc2VyKGZvdW5kLmxvYWQoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQucGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGFuZ3VhZ2UgPyBkZWZhdWx0TGFuZ3VhZ2UucGFyc2VyIDogbnVsbDtcbiAgICB9O1xufVxuXG5jbGFzcyBDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBmcm9tLCB0bywgc3BhY2VCZWZvcmUsIHNwYWNlQWZ0ZXIsIHR5cGUsIGl0ZW0pIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNwYWNlQmVmb3JlID0gc3BhY2VCZWZvcmU7XG4gICAgICAgIHRoaXMuc3BhY2VBZnRlciA9IHNwYWNlQWZ0ZXI7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgfVxuICAgIGJsYW5rKG1heFdpZHRoLCB0cmFpbGluZyA9IHRydWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BhY2VCZWZvcmUgKyAodGhpcy5ub2RlLm5hbWUgPT0gXCJCbG9ja3F1b3RlXCIgPyBcIj5cIiA6IFwiXCIpO1xuICAgICAgICBpZiAobWF4V2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBtYXhXaWR0aClcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudG8gLSB0aGlzLmZyb20gLSByZXN1bHQubGVuZ3RoIC0gdGhpcy5zcGFjZUFmdGVyLmxlbmd0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKHRyYWlsaW5nID8gdGhpcy5zcGFjZUFmdGVyIDogXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFya2VyKGRvYywgYWRkKSB7XG4gICAgICAgIGxldCBudW1iZXIgPSB0aGlzLm5vZGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIgPyBTdHJpbmcoKCtpdGVtTnVtYmVyKHRoaXMuaXRlbSwgZG9jKVsyXSArIGFkZCkpIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhY2VCZWZvcmUgKyBudW1iZXIgKyB0aGlzLnR5cGUgKyB0aGlzLnNwYWNlQWZ0ZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChub2RlLCBkb2MpIHtcbiAgICBsZXQgbm9kZXMgPSBbXSwgY29udGV4dCA9IFtdO1xuICAgIGZvciAobGV0IGN1ciA9IG5vZGU7IGN1cjsgY3VyID0gY3VyLnBhcmVudCkge1xuICAgICAgICBpZiAoY3VyLm5hbWUgPT0gXCJGZW5jZWRDb2RlXCIpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgaWYgKGN1ci5uYW1lID09IFwiTGlzdEl0ZW1cIiB8fCBjdXIubmFtZSA9PSBcIkJsb2NrcXVvdGVcIilcbiAgICAgICAgICAgIG5vZGVzLnB1c2goY3VyKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0sIG1hdGNoO1xuICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQobm9kZS5mcm9tKSwgc3RhcnRQb3MgPSBub2RlLmZyb20gLSBsaW5lLmZyb207XG4gICAgICAgIGlmIChub2RlLm5hbWUgPT0gXCJCbG9ja3F1b3RlXCIgJiYgKG1hdGNoID0gL14gKj4oID8pLy5leGVjKGxpbmUudGV4dC5zbGljZShzdGFydFBvcykpKSkge1xuICAgICAgICAgICAgY29udGV4dC5wdXNoKG5ldyBDb250ZXh0KG5vZGUsIHN0YXJ0UG9zLCBzdGFydFBvcyArIG1hdGNoWzBdLmxlbmd0aCwgXCJcIiwgbWF0Y2hbMV0sIFwiPlwiLCBudWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09IFwiTGlzdEl0ZW1cIiAmJiBub2RlLnBhcmVudC5uYW1lID09IFwiT3JkZXJlZExpc3RcIiAmJlxuICAgICAgICAgICAgKG1hdGNoID0gL14oICopXFxkKyhbLildKSggKikvLmV4ZWMobGluZS50ZXh0LnNsaWNlKHN0YXJ0UG9zKSkpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaFszXSwgbGVuID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFmdGVyLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zbGljZSgwLCBhZnRlci5sZW5ndGggLSA0KTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQucHVzaChuZXcgQ29udGV4dChub2RlLnBhcmVudCwgc3RhcnRQb3MsIHN0YXJ0UG9zICsgbGVuLCBtYXRjaFsxXSwgYWZ0ZXIsIG1hdGNoWzJdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09IFwiTGlzdEl0ZW1cIiAmJiBub2RlLnBhcmVudC5uYW1lID09IFwiQnVsbGV0TGlzdFwiICYmXG4gICAgICAgICAgICAobWF0Y2ggPSAvXiggKikoWy0rKl0pKCB7MSw0fVxcW1sgeFhdXFxdKT8oICspLy5leGVjKGxpbmUudGV4dC5zbGljZShzdGFydFBvcykpKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbWF0Y2hbNF0sIGxlbiA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhZnRlci5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zbGljZSgwLCBhZnRlci5sZW5ndGggLSA0KTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0eXBlID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pXG4gICAgICAgICAgICAgICAgdHlwZSArPSBtYXRjaFszXS5yZXBsYWNlKC9beFhdLywgJyAnKTtcbiAgICAgICAgICAgIGNvbnRleHQucHVzaChuZXcgQ29udGV4dChub2RlLnBhcmVudCwgc3RhcnRQb3MsIHN0YXJ0UG9zICsgbGVuLCBtYXRjaFsxXSwgYWZ0ZXIsIHR5cGUsIG5vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGl0ZW1OdW1iZXIoaXRlbSwgZG9jKSB7XG4gICAgcmV0dXJuIC9eKFxccyopKFxcZCspKD89Wy4pXSkvLmV4ZWMoZG9jLnNsaWNlU3RyaW5nKGl0ZW0uZnJvbSwgaXRlbS5mcm9tICsgMTApKTtcbn1cbmZ1bmN0aW9uIHJlbnVtYmVyTGlzdChhZnRlciwgZG9jLCBjaGFuZ2VzLCBvZmZzZXQgPSAwKSB7XG4gICAgZm9yIChsZXQgcHJldiA9IC0xLCBub2RlID0gYWZ0ZXI7Oykge1xuICAgICAgICBpZiAobm9kZS5uYW1lID09IFwiTGlzdEl0ZW1cIikge1xuICAgICAgICAgICAgbGV0IG0gPSBpdGVtTnVtYmVyKG5vZGUsIGRvYyk7XG4gICAgICAgICAgICBsZXQgbnVtYmVyID0gK21bMl07XG4gICAgICAgICAgICBpZiAocHJldiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKG51bWJlciAhPSBwcmV2ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG5vZGUuZnJvbSArIG1bMV0ubGVuZ3RoLCB0bzogbm9kZS5mcm9tICsgbVswXS5sZW5ndGgsIGluc2VydDogU3RyaW5nKHByZXYgKyAyICsgb2Zmc2V0KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5kZW50KGNvbnRlbnQsIHN0YXRlKSB7XG4gICAgbGV0IGJsYW5rID0gL15bIFxcdF0qLy5leGVjKGNvbnRlbnQpWzBdLmxlbmd0aDtcbiAgICBpZiAoIWJsYW5rIHx8IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpICE9IFwiXFx0XCIpXG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihjb250ZW50LCA0LCBibGFuayk7XG4gICAgbGV0IHNwYWNlID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gY29sOyBpID4gMDspIHtcbiAgICAgICAgaWYgKGkgPj0gNCkge1xuICAgICAgICAgICAgc3BhY2UgKz0gXCJcXHRcIjtcbiAgICAgICAgICAgIGkgLT0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwYWNlICs9IFwiIFwiO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGFjZSArIGNvbnRlbnQuc2xpY2UoYmxhbmspO1xufVxuLyoqXG5UaGlzIGNvbW1hbmQsIHdoZW4gaW52b2tlZCBpbiBNYXJrZG93biBjb250ZXh0IHdpdGggY3Vyc29yXG5zZWxlY3Rpb24ocyksIHdpbGwgY3JlYXRlIGEgbmV3IGxpbmUgd2l0aCB0aGUgbWFya3VwIGZvclxuYmxvY2txdW90ZXMgYW5kIGxpc3RzIHRoYXQgd2VyZSBhY3RpdmUgb24gdGhlIG9sZCBsaW5lLiBJZiB0aGVcbmN1cnNvciB3YXMgZGlyZWN0bHkgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgbWFya3VwIGZvciB0aGUgb2xkIGxpbmUsXG50cmFpbGluZyB3aGl0ZXNwYWNlIGFuZCBsaXN0IG1hcmtlcnMgYXJlIHJlbW92ZWQgZnJvbSB0aGF0IGxpbmUuXG5cblRoZSBjb21tYW5kIGRvZXMgbm90aGluZyBpbiBub24tTWFya2Rvd24gY29udGV4dCwgc28gaXQgc2hvdWxkXG5ub3QgYmUgdXNlZCBhcyB0aGUgb25seSBiaW5kaW5nIGZvciBFbnRlciAoZXZlbiBpbiBhIE1hcmtkb3duXG5kb2N1bWVudCwgSFRNTCBhbmQgY29kZSByZWdpb25zIG1pZ2h0IHVzZSBhIGRpZmZlcmVudCBsYW5ndWFnZSkuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCB7IGRvYyB9ID0gc3RhdGU7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgfHwgIW1hcmtkb3duTGFuZ3VhZ2UuaXNBY3RpdmVBdChzdGF0ZSwgcmFuZ2UuZnJvbSwgMCkpXG4gICAgICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gZ2V0Q29udGV4dCh0cmVlLnJlc29sdmVJbm5lcihwb3MsIC0xKSwgZG9jKTtcbiAgICAgICAgd2hpbGUgKGNvbnRleHQubGVuZ3RoICYmIGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXS5mcm9tID4gcG9zIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgICAgaWYgKCFjb250ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBkb250ID0geyByYW5nZSB9O1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpbm5lci50byAtIGlubmVyLnNwYWNlQWZ0ZXIubGVuZ3RoID4gcG9zIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIGRvbnQgPSB7IHJhbmdlIH07XG4gICAgICAgIGxldCBlbXB0eUxpbmUgPSBwb3MgPj0gKGlubmVyLnRvIC0gaW5uZXIuc3BhY2VBZnRlci5sZW5ndGgpICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZShpbm5lci50bykpO1xuICAgICAgICAvLyBFbXB0eSBsaW5lIGluIGxpc3RcbiAgICAgICAgaWYgKGlubmVyLml0ZW0gJiYgZW1wdHlMaW5lKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBpbm5lci5ub2RlLmZpcnN0Q2hpbGQsIHNlY29uZCA9IGlubmVyLm5vZGUuZ2V0Q2hpbGQoXCJMaXN0SXRlbVwiLCBcIkxpc3RJdGVtXCIpO1xuICAgICAgICAgICAgLy8gTm90IHNlY29uZCBpdGVtIG9yIGJsYW5rIGxpbmUgYmVmb3JlOiBkZWxldGUgYSBsZXZlbCBvZiBtYXJrdXBcbiAgICAgICAgICAgIGlmIChmaXJzdC50byA+PSBwb3MgfHwgc2Vjb25kICYmIHNlY29uZC50byA8IHBvcyB8fFxuICAgICAgICAgICAgICAgIGxpbmUuZnJvbSA+IDAgJiYgIS9bXlxccz5dLy50ZXN0KGRvYy5saW5lQXQobGluZS5mcm9tIC0gMSkudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvbnRleHQubGVuZ3RoID4gMSA/IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAyXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGRlbFRvLCBpbnNlcnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQuaXRlbSkgeyAvLyBSZS1hZGQgbWFya2VyIGZvciB0aGUgbGlzdCBhdCB0aGUgbmV4dCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBkZWxUbyA9IGxpbmUuZnJvbSArIG5leHQuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gbmV4dC5tYXJrZXIoZG9jLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbFRvID0gbGluZS5mcm9tICsgKG5leHQgPyBuZXh0LnRvIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gW3sgZnJvbTogZGVsVG8sIHRvOiBwb3MsIGluc2VydCB9XTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIubm9kZS5uYW1lID09IFwiT3JkZXJlZExpc3RcIilcbiAgICAgICAgICAgICAgICAgICAgcmVudW1iZXJMaXN0KGlubmVyLml0ZW0sIGRvYywgY2hhbmdlcywgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubm9kZS5uYW1lID09IFwiT3JkZXJlZExpc3RcIilcbiAgICAgICAgICAgICAgICAgICAgcmVudW1iZXJMaXN0KG5leHQuaXRlbSwgZG9jLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkZWxUbyArIGluc2VydC5sZW5ndGgpLCBjaGFuZ2VzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gTW92ZSBzZWNvbmQgaXRlbSBkb3duLCBtYWtpbmcgdGlnaHQgdHdvLWl0ZW0gbGlzdCBub24tdGlnaHRcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0ID0gYmxhbmtMaW5lKGNvbnRleHQsIHN0YXRlLCBsaW5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyBpbnNlcnQubGVuZ3RoICsgMSksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogbGluZS5mcm9tLCBpbnNlcnQ6IGluc2VydCArIHN0YXRlLmxpbmVCcmVhayB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlubmVyLm5vZGUubmFtZSA9PSBcIkJsb2NrcXVvdGVcIiAmJiBlbXB0eUxpbmUgJiYgbGluZS5mcm9tKSB7XG4gICAgICAgICAgICBsZXQgcHJldkxpbmUgPSBkb2MubGluZUF0KGxpbmUuZnJvbSAtIDEpLCBxdW90ZWQgPSAvPlxccyokLy5leGVjKHByZXZMaW5lLnRleHQpO1xuICAgICAgICAgICAgLy8gVHdvIGFsaWduZWQgZW1wdHkgcXVvdGVkIGxpbmVzIGluIGEgcm93XG4gICAgICAgICAgICBpZiAocXVvdGVkICYmIHF1b3RlZC5pbmRleCA9PSBpbm5lci5mcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VzKFt7IGZyb206IHByZXZMaW5lLmZyb20gKyBxdW90ZWQuaW5kZXgsIHRvOiBwcmV2TGluZS50byB9LFxuICAgICAgICAgICAgICAgICAgICB7IGZyb206IGxpbmUuZnJvbSArIGlubmVyLmZyb20sIHRvOiBsaW5lLnRvIH1dKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UubWFwKGNoYW5nZXMpLCBjaGFuZ2VzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgaWYgKGlubmVyLm5vZGUubmFtZSA9PSBcIk9yZGVyZWRMaXN0XCIpXG4gICAgICAgICAgICByZW51bWJlckxpc3QoaW5uZXIuaXRlbSwgZG9jLCBjaGFuZ2VzKTtcbiAgICAgICAgbGV0IGNvbnRpbnVlZCA9IGlubmVyLml0ZW0gJiYgaW5uZXIuaXRlbS5mcm9tIDwgbGluZS5mcm9tO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgLy8gSWYgbm90IGRlZGVudGVkXG4gICAgICAgIGlmICghY29udGludWVkIHx8IC9eW1xcc1xcZC4pXFwtKyo+XSovLmV4ZWMobGluZS50ZXh0KVswXS5sZW5ndGggPj0gaW5uZXIudG8pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gY29udGV4dC5sZW5ndGggLSAxOyBpIDw9IGU7IGkrKykge1xuICAgICAgICAgICAgICAgIGluc2VydCArPSBpID09IGUgJiYgIWNvbnRpbnVlZCA/IGNvbnRleHRbaV0ubWFya2VyKGRvYywgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBjb250ZXh0W2ldLmJsYW5rKGkgPCBlID8gY291bnRDb2x1bW4obGluZS50ZXh0LCA0LCBjb250ZXh0W2kgKyAxXS5mcm9tKSAtIGluc2VydC5sZW5ndGggOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbSA9IHBvcztcbiAgICAgICAgd2hpbGUgKGZyb20gPiBsaW5lLmZyb20gJiYgL1xccy8udGVzdChsaW5lLnRleHQuY2hhckF0KGZyb20gLSBsaW5lLmZyb20gLSAxKSkpXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGluc2VydCA9IG5vcm1hbGl6ZUluZGVudChpbnNlcnQsIHN0YXRlKTtcbiAgICAgICAgaWYgKG5vblRpZ2h0TGlzdChpbm5lci5ub2RlLCBzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgaW5zZXJ0ID0gYmxhbmtMaW5lKGNvbnRleHQsIHN0YXRlLCBsaW5lKSArIHN0YXRlLmxpbmVCcmVhayArIGluc2VydDtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbSwgdG86IHBvcywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBpbnNlcnQgfSk7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20gKyBpbnNlcnQubGVuZ3RoICsgMSksIGNoYW5nZXMgfTtcbiAgICB9KTtcbiAgICBpZiAoZG9udClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNNYXJrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lID09IFwiUXVvdGVNYXJrXCIgfHwgbm9kZS5uYW1lID09IFwiTGlzdE1hcmtcIjtcbn1cbmZ1bmN0aW9uIG5vblRpZ2h0TGlzdChub2RlLCBkb2MpIHtcbiAgICBpZiAobm9kZS5uYW1lICE9IFwiT3JkZXJlZExpc3RcIiAmJiBub2RlLm5hbWUgIT0gXCJCdWxsZXRMaXN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZmlyc3QgPSBub2RlLmZpcnN0Q2hpbGQsIHNlY29uZCA9IG5vZGUuZ2V0Q2hpbGQoXCJMaXN0SXRlbVwiLCBcIkxpc3RJdGVtXCIpO1xuICAgIGlmICghc2Vjb25kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGxpbmUxID0gZG9jLmxpbmVBdChmaXJzdC50byksIGxpbmUyID0gZG9jLmxpbmVBdChzZWNvbmQuZnJvbSk7XG4gICAgbGV0IGVtcHR5ID0gL15bXFxzPl0qJC8udGVzdChsaW5lMS50ZXh0KTtcbiAgICByZXR1cm4gbGluZTEubnVtYmVyICsgKGVtcHR5ID8gMCA6IDEpIDwgbGluZTIubnVtYmVyO1xufVxuZnVuY3Rpb24gYmxhbmtMaW5lKGNvbnRleHQsIHN0YXRlLCBsaW5lKSB7XG4gICAgbGV0IGluc2VydCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGUgPSBjb250ZXh0Lmxlbmd0aCAtIDI7IGkgPD0gZTsgaSsrKSB7XG4gICAgICAgIGluc2VydCArPSBjb250ZXh0W2ldLmJsYW5rKGkgPCBlXG4gICAgICAgICAgICA/IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgNCwgTWF0aC5taW4obGluZS50ZXh0Lmxlbmd0aCwgY29udGV4dFtpICsgMV0uZnJvbSkpIC0gaW5zZXJ0Lmxlbmd0aFxuICAgICAgICAgICAgOiBudWxsLCBpIDwgZSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVJbmRlbnQoaW5zZXJ0LCBzdGF0ZSk7XG59XG5mdW5jdGlvbiBjb250ZXh0Tm9kZUZvckRlbGV0ZSh0cmVlLCBwb3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgLTEpLCBzY2FuID0gcG9zO1xuICAgIGlmIChpc01hcmsobm9kZSkpIHtcbiAgICAgICAgc2NhbiA9IG5vZGUuZnJvbTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cbiAgICBmb3IgKGxldCBwcmV2OyBwcmV2ID0gbm9kZS5jaGlsZEJlZm9yZShzY2FuKTspIHtcbiAgICAgICAgaWYgKGlzTWFyayhwcmV2KSkge1xuICAgICAgICAgICAgc2NhbiA9IHByZXYuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2Lm5hbWUgPT0gXCJPcmRlcmVkTGlzdFwiIHx8IHByZXYubmFtZSA9PSBcIkJ1bGxldExpc3RcIikge1xuICAgICAgICAgICAgbm9kZSA9IHByZXYubGFzdENoaWxkO1xuICAgICAgICAgICAgc2NhbiA9IG5vZGUudG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuVGhpcyBjb21tYW5kIHdpbGwsIHdoZW4gaW52b2tlZCBpbiBhIE1hcmtkb3duIGNvbnRleHQgd2l0aCB0aGVcbmN1cnNvciBkaXJlY3RseSBhZnRlciBsaXN0IG9yIGJsb2NrcXVvdGUgbWFya3VwLCBkZWxldGUgb25lIGxldmVsXG5vZiBtYXJrdXAuIFdoZW4gdGhlIG1hcmt1cCBpcyBmb3IgYSBsaXN0LCBpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5XG5zcGFjZXMgb24gdGhlIGZpcnN0IGludm9jYXRpb24gKGEgZnVydGhlciBpbnZvY2F0aW9uIHdpbGwgZGVsZXRlXG50aGUgc3BhY2VzKSwgdG8gbWFrZSBpdCBlYXN5IHRvIGNvbnRpbnVlIGEgbGlzdC5cblxuV2hlbiBub3QgYWZ0ZXIgTWFya2Rvd24gYmxvY2sgbWFya3VwLCB0aGlzIGNvbW1hbmQgd2lsbCByZXR1cm5cbmZhbHNlLCBzbyBpdCBpcyBpbnRlbmRlZCB0byBiZSBib3VuZCBhbG9uZ3NpZGUgb3RoZXIgZGVsZXRpb25cbmNvbW1hbmRzLCB3aXRoIGEgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiB0aGUgbW9yZSBnZW5lcmljIGNvbW1hbmRzLlxuKi9cbmNvbnN0IGRlbGV0ZU1hcmt1cEJhY2t3YXJkID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgeyBkb2MgfSA9IHN0YXRlO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbWFya2Rvd25MYW5ndWFnZS5pc0FjdGl2ZUF0KHN0YXRlLCByYW5nZS5mcm9tKSkge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBkb2MubGluZUF0KHBvcyk7XG4gICAgICAgICAgICBsZXQgY29udGV4dCA9IGdldENvbnRleHQoY29udGV4dE5vZGVGb3JEZWxldGUodHJlZSwgcG9zKSwgZG9jKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBpbm5lci50byAtIGlubmVyLnNwYWNlQWZ0ZXIubGVuZ3RoICsgKGlubmVyLnNwYWNlQWZ0ZXIgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIGV4dHJhIHRyYWlsaW5nIHNwYWNlIGFmdGVyIG1hcmt1cFxuICAgICAgICAgICAgICAgIGlmIChwb3MgLSBsaW5lLmZyb20gPiBzcGFjZUVuZCAmJiAhL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2Uoc3BhY2VFbmQsIHBvcyAtIGxpbmUuZnJvbSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZUVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSArIHNwYWNlRW5kLCB0bzogcG9zIH0gfTtcbiAgICAgICAgICAgICAgICBpZiAocG9zIC0gbGluZS5mcm9tID09IHNwYWNlRW5kICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhpcyBpZiB3ZSdyZSBvbiB0aGUgbGluZSB0aGF0IGhhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3RydWN0J3Mgc3ludGF4LCBvciB0aGVyZSdzIG9ubHkgaW5kZW50YXRpb24gaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhcmdldCByYW5nZVxuICAgICAgICAgICAgICAgICAgICAoIWlubmVyLml0ZW0gfHwgbGluZS5mcm9tIDw9IGlubmVyLml0ZW0uZnJvbSB8fCAhL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2UoMCwgaW5uZXIudG8pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbGluZS5mcm9tICsgaW5uZXIuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhIGxpc3QgaXRlbSBtYXJrZXIgd2l0aCBibGFuayBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuaXRlbSAmJiBpbm5lci5ub2RlLmZyb20gPCBpbm5lci5pdGVtLmZyb20gJiYgL1xcUy8udGVzdChsaW5lLnRleHQuc2xpY2UoaW5uZXIuZnJvbSwgaW5uZXIudG8pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluc2VydCA9IGlubmVyLmJsYW5rKGNvdW50Q29sdW1uKGxpbmUudGV4dCwgNCwgaW5uZXIudG8pIC0gY291bnRDb2x1bW4obGluZS50ZXh0LCA0LCBpbm5lci5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG5vcm1hbGl6ZUluZGVudChpbnNlcnQsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXJ0ICsgaW5zZXJ0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBzdGFydCwgdG86IGxpbmUuZnJvbSArIGlubmVyLnRvLCBpbnNlcnQgfSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBvbmUgbGV2ZWwgb2YgaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnQpLCBjaGFuZ2VzOiB7IGZyb206IHN0YXJ0LCB0bzogcG9zIH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbnQgPSB7IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKGRvbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuQSBzbWFsbCBrZXltYXAgd2l0aCBNYXJrZG93bi1zcGVjaWZpYyBiaW5kaW5ncy4gQmluZHMgRW50ZXIgdG9cbltgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5nLW1hcmtkb3duLmluc2VydE5ld2xpbmVDb250aW51ZU1hcmt1cClcbmFuZCBCYWNrc3BhY2UgdG9cbltgZGVsZXRlTWFya3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmctbWFya2Rvd24uZGVsZXRlTWFya3VwQmFja3dhcmQpLlxuKi9cbmNvbnN0IG1hcmtkb3duS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkVudGVyXCIsIHJ1bjogaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwIH0sXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlTWFya3VwQmFja3dhcmQgfVxuXTtcbmNvbnN0IGh0bWxOb01hdGNoID0gLypAX19QVVJFX18qL2h0bWwoeyBtYXRjaENsb3NpbmdUYWdzOiBmYWxzZSB9KTtcbi8qKlxuTWFya2Rvd24gbGFuZ3VhZ2Ugc3VwcG9ydC5cbiovXG5mdW5jdGlvbiBtYXJrZG93bihjb25maWcgPSB7fSkge1xuICAgIGxldCB7IGNvZGVMYW5ndWFnZXMsIGRlZmF1bHRDb2RlTGFuZ3VhZ2UsIGFkZEtleW1hcCA9IHRydWUsIGJhc2U6IHsgcGFyc2VyIH0gPSBjb21tb25tYXJrTGFuZ3VhZ2UsIGNvbXBsZXRlSFRNTFRhZ3MgPSB0cnVlLCBodG1sVGFnTGFuZ3VhZ2UgPSBodG1sTm9NYXRjaCB9ID0gY29uZmlnO1xuICAgIGlmICghKHBhcnNlciBpbnN0YW5jZW9mIE1hcmtkb3duUGFyc2VyKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCYXNlIHBhcnNlciBwcm92aWRlZCB0byBgbWFya2Rvd25gIHNob3VsZCBiZSBhIE1hcmtkb3duIHBhcnNlclwiKTtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IGNvbmZpZy5leHRlbnNpb25zID8gW2NvbmZpZy5leHRlbnNpb25zXSA6IFtdO1xuICAgIGxldCBzdXBwb3J0ID0gW2h0bWxUYWdMYW5ndWFnZS5zdXBwb3J0XSwgZGVmYXVsdENvZGU7XG4gICAgaWYgKGRlZmF1bHRDb2RlTGFuZ3VhZ2UgaW5zdGFuY2VvZiBMYW5ndWFnZVN1cHBvcnQpIHtcbiAgICAgICAgc3VwcG9ydC5wdXNoKGRlZmF1bHRDb2RlTGFuZ3VhZ2Uuc3VwcG9ydCk7XG4gICAgICAgIGRlZmF1bHRDb2RlID0gZGVmYXVsdENvZGVMYW5ndWFnZS5sYW5ndWFnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmYXVsdENvZGVMYW5ndWFnZSkge1xuICAgICAgICBkZWZhdWx0Q29kZSA9IGRlZmF1bHRDb2RlTGFuZ3VhZ2U7XG4gICAgfVxuICAgIGxldCBjb2RlUGFyc2VyID0gY29kZUxhbmd1YWdlcyB8fCBkZWZhdWx0Q29kZSA/IGdldENvZGVQYXJzZXIoY29kZUxhbmd1YWdlcywgZGVmYXVsdENvZGUpIDogdW5kZWZpbmVkO1xuICAgIGV4dGVuc2lvbnMucHVzaChwYXJzZUNvZGUoeyBjb2RlUGFyc2VyLCBodG1sUGFyc2VyOiBodG1sVGFnTGFuZ3VhZ2UubGFuZ3VhZ2UucGFyc2VyIH0pKTtcbiAgICBpZiAoYWRkS2V5bWFwKVxuICAgICAgICBzdXBwb3J0LnB1c2goUHJlYy5oaWdoKGtleW1hcC5vZihtYXJrZG93bktleW1hcCkpKTtcbiAgICBsZXQgbGFuZyA9IG1rTGFuZyhwYXJzZXIuY29uZmlndXJlKGV4dGVuc2lvbnMpKTtcbiAgICBpZiAoY29tcGxldGVIVE1MVGFncylcbiAgICAgICAgc3VwcG9ydC5wdXNoKGxhbmcuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogaHRtbFRhZ0NvbXBsZXRpb24gfSkpO1xuICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdXBwb3J0KGxhbmcsIHN1cHBvcnQpO1xufVxuZnVuY3Rpb24gaHRtbFRhZ0NvbXBsZXRpb24oY29udGV4dCkge1xuICAgIGxldCB7IHN0YXRlLCBwb3MgfSA9IGNvbnRleHQsIG0gPSAvPFs6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokLy5leGVjKHN0YXRlLnNsaWNlRG9jKHBvcyAtIDI1LCBwb3MpKTtcbiAgICBpZiAoIW0pXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIHdoaWxlICh0cmVlICYmICF0cmVlLnR5cGUuaXNUb3ApIHtcbiAgICAgICAgaWYgKHRyZWUubmFtZSA9PSBcIkNvZGVCbG9ja1wiIHx8IHRyZWUubmFtZSA9PSBcIkZlbmNlZENvZGVcIiB8fCB0cmVlLm5hbWUgPT0gXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25CbG9ja1wiIHx8XG4gICAgICAgICAgICB0cmVlLm5hbWUgPT0gXCJDb21tZW50QmxvY2tcIiB8fCB0cmVlLm5hbWUgPT0gXCJMaW5rXCIgfHwgdHJlZS5uYW1lID09IFwiSW1hZ2VcIilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0cmVlID0gdHJlZS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IHBvcyAtIG1bMF0ubGVuZ3RoLCB0bzogcG9zLFxuICAgICAgICBvcHRpb25zOiBodG1sVGFnQ29tcGxldGlvbnMoKSxcbiAgICAgICAgdmFsaWRGb3I6IC9ePFs6XFwtXFwuXFx3XFx1MDBiNy1cXHVmZmZmXSokL1xuICAgIH07XG59XG5sZXQgX3RhZ0NvbXBsZXRpb25zID0gbnVsbDtcbmZ1bmN0aW9uIGh0bWxUYWdDb21wbGV0aW9ucygpIHtcbiAgICBpZiAoX3RhZ0NvbXBsZXRpb25zKVxuICAgICAgICByZXR1cm4gX3RhZ0NvbXBsZXRpb25zO1xuICAgIGxldCByZXN1bHQgPSBodG1sQ29tcGxldGlvblNvdXJjZShuZXcgQ29tcGxldGlvbkNvbnRleHQoRWRpdG9yU3RhdGUuY3JlYXRlKHsgZXh0ZW5zaW9uczogaHRtbE5vTWF0Y2ggfSksIDAsIHRydWUpKTtcbiAgICByZXR1cm4gX3RhZ0NvbXBsZXRpb25zID0gcmVzdWx0ID8gcmVzdWx0Lm9wdGlvbnMgOiBbXTtcbn1cblxuZXhwb3J0IHsgY29tbW9ubWFya0xhbmd1YWdlLCBkZWxldGVNYXJrdXBCYWNrd2FyZCwgaW5zZXJ0TmV3bGluZUNvbnRpbnVlTWFya3VwLCBtYXJrZG93biwgbWFya2Rvd25LZXltYXAsIG1hcmtkb3duTGFuZ3VhZ2UgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@codemirror+lang-markdown@6.3.2/node_modules/@codemirror/lang-markdown/dist/index.js\n");

/***/ })

};
;