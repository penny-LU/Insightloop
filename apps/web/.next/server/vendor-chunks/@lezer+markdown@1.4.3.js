"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer+markdown@1.4.3";
exports.ids = ["vendor-chunks/@lezer+markdown@1.4.3"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js":
/*!*************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Autolink: () => (/* binding */ Autolink),\n/* harmony export */   BlockContext: () => (/* binding */ BlockContext),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Emoji: () => (/* binding */ Emoji),\n/* harmony export */   GFM: () => (/* binding */ GFM),\n/* harmony export */   InlineContext: () => (/* binding */ InlineContext),\n/* harmony export */   LeafBlock: () => (/* binding */ LeafBlock),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MarkdownParser: () => (/* binding */ MarkdownParser),\n/* harmony export */   Strikethrough: () => (/* binding */ Strikethrough),\n/* harmony export */   Subscript: () => (/* binding */ Subscript),\n/* harmony export */   Superscript: () => (/* binding */ Superscript),\n/* harmony export */   Table: () => (/* binding */ Table),\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   parseCode: () => (/* binding */ parseCode),\n/* harmony export */   parser: () => (/* binding */ parser)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/../../node_modules/.pnpm/@lezer+common@1.2.3/node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/../../node_modules/.pnpm/@lezer+highlight@1.2.1/node_modules/@lezer/highlight/dist/index.js\");\n\n\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) != this.hash)\n            child = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n    Type[Type[\"URL\"] = 44] = \"URL\";\n})(Type || (Type = {}));\n/**\nData structure used to accumulate a block's content during [leaf\nblock parsing](#BlockParser.leaf).\n*/\nclass LeafBlock {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the block.\n    */\n    start, \n    /**\n    The block's text content.\n    */\n    content) {\n        this.start = start;\n        this.content = content;\n        /**\n        @internal\n        */\n        this.marks = [];\n        /**\n        The block parsers active for this block.\n        */\n        this.parsers = [];\n    }\n}\n/**\nData structure used during block-level per-line parsing.\n*/\nclass Line {\n    constructor() {\n        /**\n        The line's full text.\n        */\n        this.text = \"\";\n        /**\n        The base indent provided by the composite contexts (that have\n        been handled so far).\n        */\n        this.baseIndent = 0;\n        /**\n        The string position corresponding to the base indent.\n        */\n        this.basePos = 0;\n        /**\n        The number of contexts handled @internal\n        */\n        this.depth = 0;\n        /**\n        Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        */\n        this.markers = [];\n        /**\n        The position of the next non-whitespace character beyond any\n        list, blockquote, or other composite block markers.\n        */\n        this.pos = 0;\n        /**\n        The column of the next non-whitespace character.\n        */\n        this.indent = 0;\n        /**\n        The character code of the character after `pos`.\n        */\n        this.next = -1;\n    }\n    /**\n    @internal\n    */\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /**\n    @internal\n    */\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /**\n    Skip whitespace after the given position, return the position of\n    the next non-space character or the end of the line if there's\n    only space after `from`.\n    */\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /**\n    @internal\n    */\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /**\n    Move the line's base position forward to the given position.\n    This should only be called by composite [block\n    parsers](#BlockParser.parse) or [markup skipping\n    functions](#NodeSpec.composite).\n    */\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /**\n    Move the line's base position forward to the given _column_.\n    */\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /**\n    Store a composite-block-level marker. Should be called from\n    [markup skipping functions](#NodeSpec.composite) when they\n    consume any non-whitespace characters.\n    */\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /**\n    Find the column position at `to`, optionally starting at a given\n    position and column.\n    */\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /**\n    Find the position corresponding to the given column.\n    */\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /**\n    @internal\n    */\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length &&\n        cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/**\nBlock-level parsing functions get access to this context object.\n*/\nclass BlockContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser configuration used.\n    */\n    parser, \n    /**\n    @internal\n    */\n    input, fragments, \n    /**\n    @internal\n    */\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /**\n        For reused nodes on gaps, we can't directly put the original\n        node into the tree, since that may be bigger than its parent.\n        When this happens, we create a dummy tree that is replaced by\n        the proper node in `injectGaps` @internal\n        */\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /**\n        The range index that absoluteLineStart points into @internal\n        */\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            for (let markI = 0;;) {\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\n                    let mark = line.markers[markI++];\n                    this.addNode(mark.type, mark.from, mark.to);\n                }\n                if (!next)\n                    break;\n                this.finishContext();\n            }\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /**\n    The number of parent blocks surrounding the current block.\n    */\n    get depth() {\n        return this.stack.length;\n    }\n    /**\n    Get the type of the parent block at the given depth. When no\n    depth is passed, return the type of the innermost parent.\n    */\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /**\n    Move to the next input line. This should only be called by\n    (non-composite) [block parsers](#BlockParser.parse) that consume\n    the line directly, or leaf block parser\n    [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    consume the current line (and return true).\n    */\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    /**\n    Retrieve the text of the line after the current one, without\n    actually moving the context's current line forward.\n    */\n    peekLine() {\n        return this.scanLine(this.absoluteLineEnd + 1).text;\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /**\n    @internal\n    Collect the text for the next line.\n    */\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /**\n    @internal\n    Populate this.line with the content of the next line. Skip\n    leading characters covered by composite blocks.\n    */\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /**\n    The end position of the previous line.\n    */\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /**\n    @internal\n    */\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /**\n    Start a composite block. Should only be called from [block\n    parser functions](#BlockParser.parse) that return null.\n    */\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /**\n    @internal\n    */\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /**\n    Add a block element. Can be called by [block\n    parsers](#BlockParser.parse).\n    */\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /**\n    Add a block element from a [leaf parser](#LeafBlockParser). This\n    makes sure any extra composite block markup (such as blockquote\n    markers) inside the block are also added to the syntax tree.\n    */\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /**\n    @internal\n    */\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /**\n    @internal\n    */\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /**\n    @internal\n    */\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/**\nA Markdown parser configuration.\n*/\nclass MarkdownParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser's syntax [node\n    types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    */\n    nodeSet, \n    /**\n    @internal\n    */\n    blockParsers, \n    /**\n    @internal\n    */\n    leafBlockParsers, \n    /**\n    @internal\n    */\n    blockNames, \n    /**\n    @internal\n    */\n    endLeafBlock, \n    /**\n    @internal\n    */\n    skipContextMarkup, \n    /**\n    @internal\n    */\n    inlineParsers, \n    /**\n    @internal\n    */\n    inlineNames, \n    /**\n    @internal\n    */\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /**\n        @internal\n        */\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Reconfigure the parser.\n    */\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n                    id,\n                    name,\n                    props: group && [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend((0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /**\n    @internal\n    */\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /**\n    Parse the given piece of inline text at the given offset,\n    returning an array of [`Element`](#Element) objects representing\n    the inline content.\n    */\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/**\nElements are used to compose syntax nodes during parsing.\n*/\nclass Element {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The node's\n    [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    */\n    type, \n    /**\n    The start of the node, as an offset from the start of the document.\n    */\n    from, \n    /**\n    The end of the node.\n    */\n    to, \n    /**\n    The node's child nodes @internal\n    */\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /**\n    @internal\n    */\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /**\n    @internal\n    */\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{S}|\\\\p{P}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url) {\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\n                elt(Type.LinkMark, start, start + 1),\n                // url[0] includes the closing bracket, so exclude it from this slice\n                elt(Type.URL, start + 1, start + url[0].length),\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\n            ]));\n        }\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0 /* Mark.None */;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            // The destination and title must be separated by whitespace\n            if (pos != dest.to) {\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n                if (title)\n                    pos = cx.skipSpace(title.to);\n            }\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/**\nInline parsing functions get access to this context, and use it to\nread the content and emit syntax nodes.\n*/\nclass InlineContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser that is being used.\n    */\n    parser, \n    /**\n    The text of this inline section.\n    */\n    text, \n    /**\n    The starting offset of the section in the document.\n    */\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /**\n        @internal\n        */\n        this.parts = [];\n    }\n    /**\n    Get the character code at the given (document-relative)\n    position.\n    */\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /**\n    The position of the end of this inline section.\n    */\n    get end() { return this.offset + this.text.length; }\n    /**\n    Get a substring of this inline section. Again uses\n    document-relative positions.\n    */\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /**\n    @internal\n    */\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /**\n    Add a [delimiter](#DelimiterType) at this given position. `open`\n    and `close` indicate whether this delimiter is opening, closing,\n    or both. Returns the end of the delimiter, for convenient\n    returning from [parse functions](#InlineParser.parse).\n    */\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    }\n    /**\n    Returns true when there is an unmatched link or image opening\n    token before the current position.\n    */\n    get hasOpenLink() {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\n                return true;\n        }\n        return false;\n    }\n    /**\n    Add an inline element. Returns the end of the element.\n    */\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /**\n    Resolve markers between this.parts.length and from, wrapping matched markers in the\n    appropriate node and updating the content of this.parts. @internal\n    */\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /**\n    Find an opening delimiter of the given type. Returns `null` if\n    no delimiter is found, or an index that can be passed to\n    [`takeContent`](#InlineContext.takeContent) otherwise.\n    */\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /**\n    Remove all inline elements and delimiters starting from the\n    given index (which you should get from\n    [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    resolve delimiters inside of them, and return them as an array\n    of elements.\n    */\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /**\n    Skip space after the given (document) position, returning either\n    the position of the next non-space character or the end of the\n    section.\n    */\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n    \"Blockquote/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.quote,\n    HorizontalRule: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading2,\n    \"ATXHeading3/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading3,\n    \"ATXHeading4/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading4,\n    \"ATXHeading5/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading5,\n    \"ATXHeading6/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading6,\n    \"Comment CommentBlock\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n    Escape: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n    Entity: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character,\n    \"Emphasis/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n    \"StrongEmphasis/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n    \"Link/... Image/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n    \"OrderedList/... BulletList/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.list,\n    \"BlockQuote/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.quote,\n    \"InlineCode CodeText\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.monospace,\n    \"URL Autolink\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction,\n    \"CodeInfo LinkLabel\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName,\n    LinkTitle: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n    Paragraph: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content\n});\n/**\nThe default CommonMark parser.\n*/\nconst parser = new MarkdownParser(new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/**\nCreate a Markdown extension to enable nested parsing on code\nblocks and/or embedded HTML.\n*/\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = (0,_lezer_common__WEBPACK_IMPORTED_MODULE_0__.parseMixed)((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag || id == Type.CommentBlock)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/**\nAn extension that implements\n[GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\nStrikethrough syntax using `~~` delimiters.\n*/\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\n// Parse a line as a table row and return the row count. When `elts`\n// is given, push syntax elements for the content onto it.\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/**\nThis extension provides\n[GFM-style](https://github.github.com/gfm/#tables-extension-)\ntables, using syntax like this:\n\n```\n| head 1 | head 2 |\n| ---    | ---    |\n| cell 1 | cell 2 |\n```\n*/\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content },\n        { name: \"TableDelimiter\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.peekLine();\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/**\nExtension providing\n[GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\ntask list items, where list items can be prefixed with `[ ]` or\n`[x]` to add a checkbox.\n*/\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.list },\n        { name: \"TaskMarker\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/**\nExtension that implements autolinking for\n`www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\naddresses.\n*/\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                if (pos && /\\w/.test(cx.text[pos - 1]))\n                    return -1;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && cx.hasOpenLink) {\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\n                        end = pos + noBracket[0].length;\n                    }\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/**\nExtension bundle containing [`Table`](#Table),\n[`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n[`Autolink`](#Autolink).\n*/\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsuperscript using `^` markers.\n*/\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content) },\n        { name: \"SuperscriptMark\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsubscript using `~` markers.\n*/\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.content) },\n        { name: \"SubscriptMark\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/**\nExtension that parses two colons with only letters, underscores,\nand numbers between them as `Emoji` nodes.\n*/\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXplcittYXJrZG93bkAxLjQuMy9ub2RlX21vZHVsZXMvQGxlemVyL21hcmtkb3duL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNGO0FBQzlCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQVE7QUFDbEM7QUFDQTtBQUNBLHVCQUF1QixtREFBUTtBQUMvQix3QkFBd0IsK0NBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0NBQUk7QUFDdkIsMkRBQTJELCtDQUFJLENBQUMsbURBQVE7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnREFBZ0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRkFBMkY7QUFDeEgsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPLFVBQVUsWUFBWTtBQUMzQztBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlEQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxzQkFBc0Is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SSxXQUFXO0FBQ2xFLFVBQVUsZ0NBQWdDLGtEQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQixrREFBSSxTQUFTLGtEQUFJLFdBQVc7QUFDaEUsVUFBVSw4QkFBOEIsa0RBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQixrREFBSSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRWtMIiwic291cmNlcyI6WyJEOlxc5a245qChXFxwcm9qZWN0XFxzdGFja1xcaW5zaWdodGxvb3BcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBsZXplcittYXJrZG93bkAxLjQuM1xcbm9kZV9tb2R1bGVzXFxAbGV6ZXJcXG1hcmtkb3duXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlVHlwZSwgTm9kZVByb3AsIE5vZGVTZXQsIFRyZWUsIFBhcnNlciwgcGFyc2VNaXhlZCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuaW1wb3J0IHsgc3R5bGVUYWdzLCB0YWdzLCBUYWcgfSBmcm9tICdAbGV6ZXIvaGlnaGxpZ2h0JztcblxuY2xhc3MgQ29tcG9zaXRlQmxvY2sge1xuICAgIHN0YXRpYyBjcmVhdGUodHlwZSwgdmFsdWUsIGZyb20sIHBhcmVudEhhc2gsIGVuZCkge1xuICAgICAgICBsZXQgaGFzaCA9IChwYXJlbnRIYXNoICsgKHBhcmVudEhhc2ggPDwgOCkgKyB0eXBlICsgKHZhbHVlIDw8IDQpKSB8IDA7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlQmxvY2sodHlwZSwgdmFsdWUsIGZyb20sIGhhc2gsIGVuZCwgW10sIFtdKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSwgXG4gICAgLy8gVXNlZCBmb3IgaW5kZW50YXRpb24gaW4gbGlzdCBpdGVtcywgbWFya3VwIGNoYXJhY3RlciBpbiBsaXN0c1xuICAgIHZhbHVlLCBmcm9tLCBoYXNoLCBlbmQsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5oYXNoUHJvcCA9IFtbTm9kZVByb3AuY29udGV4dEhhc2gsIGhhc2hdXTtcbiAgICB9XG4gICAgYWRkQ2hpbGQoY2hpbGQsIHBvcykge1xuICAgICAgICBpZiAoY2hpbGQucHJvcChOb2RlUHJvcC5jb250ZXh0SGFzaCkgIT0gdGhpcy5oYXNoKVxuICAgICAgICAgICAgY2hpbGQgPSBuZXcgVHJlZShjaGlsZC50eXBlLCBjaGlsZC5jaGlsZHJlbiwgY2hpbGQucG9zaXRpb25zLCBjaGlsZC5sZW5ndGgsIHRoaXMuaGFzaFByb3ApO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKHBvcyk7XG4gICAgfVxuICAgIHRvVHJlZShub2RlU2V0LCBlbmQgPSB0aGlzLmVuZCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPj0gMClcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWF4KGVuZCwgdGhpcy5wb3NpdGlvbnNbbGFzdF0gKyB0aGlzLmNoaWxkcmVuW2xhc3RdLmxlbmd0aCArIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZShub2RlU2V0LnR5cGVzW3RoaXMudHlwZV0sIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCBlbmQgLSB0aGlzLmZyb20pLmJhbGFuY2Uoe1xuICAgICAgICAgICAgbWFrZVRyZWU6IChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgdGhpcy5oYXNoUHJvcClcbiAgICAgICAgfSk7XG4gICAgfVxufVxudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJEb2N1bWVudFwiXSA9IDFdID0gXCJEb2N1bWVudFwiO1xuICAgIFR5cGVbVHlwZVtcIkNvZGVCbG9ja1wiXSA9IDJdID0gXCJDb2RlQmxvY2tcIjtcbiAgICBUeXBlW1R5cGVbXCJGZW5jZWRDb2RlXCJdID0gM10gPSBcIkZlbmNlZENvZGVcIjtcbiAgICBUeXBlW1R5cGVbXCJCbG9ja3F1b3RlXCJdID0gNF0gPSBcIkJsb2NrcXVvdGVcIjtcbiAgICBUeXBlW1R5cGVbXCJIb3Jpem9udGFsUnVsZVwiXSA9IDVdID0gXCJIb3Jpem9udGFsUnVsZVwiO1xuICAgIFR5cGVbVHlwZVtcIkJ1bGxldExpc3RcIl0gPSA2XSA9IFwiQnVsbGV0TGlzdFwiO1xuICAgIFR5cGVbVHlwZVtcIk9yZGVyZWRMaXN0XCJdID0gN10gPSBcIk9yZGVyZWRMaXN0XCI7XG4gICAgVHlwZVtUeXBlW1wiTGlzdEl0ZW1cIl0gPSA4XSA9IFwiTGlzdEl0ZW1cIjtcbiAgICBUeXBlW1R5cGVbXCJBVFhIZWFkaW5nMVwiXSA9IDldID0gXCJBVFhIZWFkaW5nMVwiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmcyXCJdID0gMTBdID0gXCJBVFhIZWFkaW5nMlwiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmczXCJdID0gMTFdID0gXCJBVFhIZWFkaW5nM1wiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmc0XCJdID0gMTJdID0gXCJBVFhIZWFkaW5nNFwiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmc1XCJdID0gMTNdID0gXCJBVFhIZWFkaW5nNVwiO1xuICAgIFR5cGVbVHlwZVtcIkFUWEhlYWRpbmc2XCJdID0gMTRdID0gXCJBVFhIZWFkaW5nNlwiO1xuICAgIFR5cGVbVHlwZVtcIlNldGV4dEhlYWRpbmcxXCJdID0gMTVdID0gXCJTZXRleHRIZWFkaW5nMVwiO1xuICAgIFR5cGVbVHlwZVtcIlNldGV4dEhlYWRpbmcyXCJdID0gMTZdID0gXCJTZXRleHRIZWFkaW5nMlwiO1xuICAgIFR5cGVbVHlwZVtcIkhUTUxCbG9ja1wiXSA9IDE3XSA9IFwiSFRNTEJsb2NrXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlua1JlZmVyZW5jZVwiXSA9IDE4XSA9IFwiTGlua1JlZmVyZW5jZVwiO1xuICAgIFR5cGVbVHlwZVtcIlBhcmFncmFwaFwiXSA9IDE5XSA9IFwiUGFyYWdyYXBoXCI7XG4gICAgVHlwZVtUeXBlW1wiQ29tbWVudEJsb2NrXCJdID0gMjBdID0gXCJDb21tZW50QmxvY2tcIjtcbiAgICBUeXBlW1R5cGVbXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25CbG9ja1wiXSA9IDIxXSA9IFwiUHJvY2Vzc2luZ0luc3RydWN0aW9uQmxvY2tcIjtcbiAgICAvLyBJbmxpbmVcbiAgICBUeXBlW1R5cGVbXCJFc2NhcGVcIl0gPSAyMl0gPSBcIkVzY2FwZVwiO1xuICAgIFR5cGVbVHlwZVtcIkVudGl0eVwiXSA9IDIzXSA9IFwiRW50aXR5XCI7XG4gICAgVHlwZVtUeXBlW1wiSGFyZEJyZWFrXCJdID0gMjRdID0gXCJIYXJkQnJlYWtcIjtcbiAgICBUeXBlW1R5cGVbXCJFbXBoYXNpc1wiXSA9IDI1XSA9IFwiRW1waGFzaXNcIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJvbmdFbXBoYXNpc1wiXSA9IDI2XSA9IFwiU3Ryb25nRW1waGFzaXNcIjtcbiAgICBUeXBlW1R5cGVbXCJMaW5rXCJdID0gMjddID0gXCJMaW5rXCI7XG4gICAgVHlwZVtUeXBlW1wiSW1hZ2VcIl0gPSAyOF0gPSBcIkltYWdlXCI7XG4gICAgVHlwZVtUeXBlW1wiSW5saW5lQ29kZVwiXSA9IDI5XSA9IFwiSW5saW5lQ29kZVwiO1xuICAgIFR5cGVbVHlwZVtcIkhUTUxUYWdcIl0gPSAzMF0gPSBcIkhUTUxUYWdcIjtcbiAgICBUeXBlW1R5cGVbXCJDb21tZW50XCJdID0gMzFdID0gXCJDb21tZW50XCI7XG4gICAgVHlwZVtUeXBlW1wiUHJvY2Vzc2luZ0luc3RydWN0aW9uXCJdID0gMzJdID0gXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjtcbiAgICBUeXBlW1R5cGVbXCJBdXRvbGlua1wiXSA9IDMzXSA9IFwiQXV0b2xpbmtcIjtcbiAgICAvLyBTbWFsbGVyIHRva2Vuc1xuICAgIFR5cGVbVHlwZVtcIkhlYWRlck1hcmtcIl0gPSAzNF0gPSBcIkhlYWRlck1hcmtcIjtcbiAgICBUeXBlW1R5cGVbXCJRdW90ZU1hcmtcIl0gPSAzNV0gPSBcIlF1b3RlTWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIkxpc3RNYXJrXCJdID0gMzZdID0gXCJMaXN0TWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIkxpbmtNYXJrXCJdID0gMzddID0gXCJMaW5rTWFya1wiO1xuICAgIFR5cGVbVHlwZVtcIkVtcGhhc2lzTWFya1wiXSA9IDM4XSA9IFwiRW1waGFzaXNNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiQ29kZU1hcmtcIl0gPSAzOV0gPSBcIkNvZGVNYXJrXCI7XG4gICAgVHlwZVtUeXBlW1wiQ29kZVRleHRcIl0gPSA0MF0gPSBcIkNvZGVUZXh0XCI7XG4gICAgVHlwZVtUeXBlW1wiQ29kZUluZm9cIl0gPSA0MV0gPSBcIkNvZGVJbmZvXCI7XG4gICAgVHlwZVtUeXBlW1wiTGlua1RpdGxlXCJdID0gNDJdID0gXCJMaW5rVGl0bGVcIjtcbiAgICBUeXBlW1R5cGVbXCJMaW5rTGFiZWxcIl0gPSA0M10gPSBcIkxpbmtMYWJlbFwiO1xuICAgIFR5cGVbVHlwZVtcIlVSTFwiXSA9IDQ0XSA9IFwiVVJMXCI7XG59KShUeXBlIHx8IChUeXBlID0ge30pKTtcbi8qKlxuRGF0YSBzdHJ1Y3R1cmUgdXNlZCB0byBhY2N1bXVsYXRlIGEgYmxvY2sncyBjb250ZW50IGR1cmluZyBbbGVhZlxuYmxvY2sgcGFyc2luZ10oI0Jsb2NrUGFyc2VyLmxlYWYpLlxuKi9cbmNsYXNzIExlYWZCbG9jayB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGJsb2NrLlxuICAgICovXG4gICAgc3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBibG9jaydzIHRleHQgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBibG9jayBwYXJzZXJzIGFjdGl2ZSBmb3IgdGhpcyBibG9jay5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJzZXJzID0gW107XG4gICAgfVxufVxuLyoqXG5EYXRhIHN0cnVjdHVyZSB1c2VkIGR1cmluZyBibG9jay1sZXZlbCBwZXItbGluZSBwYXJzaW5nLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGxpbmUncyBmdWxsIHRleHQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgYmFzZSBpbmRlbnQgcHJvdmlkZWQgYnkgdGhlIGNvbXBvc2l0ZSBjb250ZXh0cyAodGhhdCBoYXZlXG4gICAgICAgIGJlZW4gaGFuZGxlZCBzbyBmYXIpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VJbmRlbnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0cmluZyBwb3NpdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBiYXNlIGluZGVudC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlUG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBudW1iZXIgb2YgY29udGV4dHMgaGFuZGxlZCBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBBbnkgbWFya2VycyAoaS5lLiBibG9jayBxdW90ZSBtYXJrZXJzKSBwYXJzZWQgZm9yIHRoZSBjb250ZXh0cy4gQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBiZXlvbmQgYW55XG4gICAgICAgIGxpc3QsIGJsb2NrcXVvdGUsIG9yIG90aGVyIGNvbXBvc2l0ZSBibG9jayBtYXJrZXJzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY29sdW1uIG9mIHRoZSBuZXh0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIgYHBvc2AuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcndhcmQoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQb3MgPiB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZElubmVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZm9yd2FyZElubmVyKCkge1xuICAgICAgICBsZXQgbmV3UG9zID0gdGhpcy5za2lwU3BhY2UodGhpcy5iYXNlUG9zKTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLmNvdW50SW5kZW50KG5ld1BvcywgdGhpcy5wb3MsIHRoaXMuaW5kZW50KTtcbiAgICAgICAgdGhpcy5wb3MgPSBuZXdQb3M7XG4gICAgICAgIHRoaXMubmV4dCA9IG5ld1BvcyA9PSB0aGlzLnRleHQubGVuZ3RoID8gLTEgOiB0aGlzLnRleHQuY2hhckNvZGVBdChuZXdQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLCByZXR1cm4gdGhlIHBvc2l0aW9uIG9mXG4gICAgdGhlIG5leHQgbm9uLXNwYWNlIGNoYXJhY3RlciBvciB0aGUgZW5kIG9mIHRoZSBsaW5lIGlmIHRoZXJlJ3NcbiAgICBvbmx5IHNwYWNlIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIHNraXBTcGFjZShmcm9tKSB7IHJldHVybiBza2lwU3BhY2UodGhpcy50ZXh0LCBmcm9tKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmJhc2VJbmRlbnQgPSB0aGlzLmJhc2VQb3MgPSB0aGlzLnBvcyA9IHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgdGhpcy5mb3J3YXJkSW5uZXIoKTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IDE7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hcmtlcnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXJrZXJzLnBvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBsaW5lJ3MgYmFzZSBwb3NpdGlvbiBmb3J3YXJkIHRvIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBieSBjb21wb3NpdGUgW2Jsb2NrXG4gICAgcGFyc2Vyc10oI0Jsb2NrUGFyc2VyLnBhcnNlKSBvciBbbWFya3VwIHNraXBwaW5nXG4gICAgZnVuY3Rpb25zXSgjTm9kZVNwZWMuY29tcG9zaXRlKS5cbiAgICAqL1xuICAgIG1vdmVCYXNlKHRvKSB7XG4gICAgICAgIHRoaXMuYmFzZVBvcyA9IHRvO1xuICAgICAgICB0aGlzLmJhc2VJbmRlbnQgPSB0aGlzLmNvdW50SW5kZW50KHRvLCB0aGlzLnBvcywgdGhpcy5pbmRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBsaW5lJ3MgYmFzZSBwb3NpdGlvbiBmb3J3YXJkIHRvIHRoZSBnaXZlbiBfY29sdW1uXy5cbiAgICAqL1xuICAgIG1vdmVCYXNlQ29sdW1uKGluZGVudCkge1xuICAgICAgICB0aGlzLmJhc2VJbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMuYmFzZVBvcyA9IHRoaXMuZmluZENvbHVtbihpbmRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBTdG9yZSBhIGNvbXBvc2l0ZS1ibG9jay1sZXZlbCBtYXJrZXIuIFNob3VsZCBiZSBjYWxsZWQgZnJvbVxuICAgIFttYXJrdXAgc2tpcHBpbmcgZnVuY3Rpb25zXSgjTm9kZVNwZWMuY29tcG9zaXRlKSB3aGVuIHRoZXlcbiAgICBjb25zdW1lIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgYWRkTWFya2VyKGVsdCkge1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChlbHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgYHRvYCwgb3B0aW9uYWxseSBzdGFydGluZyBhdCBhIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIGNvbHVtbi5cbiAgICAqL1xuICAgIGNvdW50SW5kZW50KHRvLCBmcm9tID0gMCwgaW5kZW50ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgICAgICBpbmRlbnQgKz0gdGhpcy50ZXh0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IDQgLSBpbmRlbnQgJSA0IDogMTtcbiAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgcG9zaXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICovXG4gICAgZmluZENvbHVtbihnb2FsKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgaW5kZW50ID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGggJiYgaW5kZW50IDwgZ29hbDsgaSsrKVxuICAgICAgICAgICAgaW5kZW50ICs9IHRoaXMudGV4dC5jaGFyQ29kZUF0KGkpID09IDkgPyA0IC0gaW5kZW50ICUgNCA6IDE7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjcnViKCkge1xuICAgICAgICBpZiAoIXRoaXMuYmFzZUluZGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmFzZVBvczsgaSsrKVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIFwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgdGhpcy50ZXh0LnNsaWNlKHRoaXMuYmFzZVBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEZvckxpc3QoYmwsIGN4LCBsaW5lKSB7XG4gICAgaWYgKGxpbmUucG9zID09IGxpbmUudGV4dC5sZW5ndGggfHxcbiAgICAgICAgKGJsICE9IGN4LmJsb2NrICYmIGxpbmUuaW5kZW50ID49IGN4LnN0YWNrW2xpbmUuZGVwdGggKyAxXS52YWx1ZSArIGxpbmUuYmFzZUluZGVudCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChsaW5lLmluZGVudCA+PSBsaW5lLmJhc2VJbmRlbnQgKyA0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpemUgPSAoYmwudHlwZSA9PSBUeXBlLk9yZGVyZWRMaXN0ID8gaXNPcmRlcmVkTGlzdCA6IGlzQnVsbGV0TGlzdCkobGluZSwgY3gsIGZhbHNlKTtcbiAgICByZXR1cm4gc2l6ZSA+IDAgJiZcbiAgICAgICAgKGJsLnR5cGUgIT0gVHlwZS5CdWxsZXRMaXN0IHx8IGlzSG9yaXpvbnRhbFJ1bGUobGluZSwgY3gsIGZhbHNlKSA8IDApICYmXG4gICAgICAgIGxpbmUudGV4dC5jaGFyQ29kZUF0KGxpbmUucG9zICsgc2l6ZSAtIDEpID09IGJsLnZhbHVlO1xufVxuY29uc3QgRGVmYXVsdFNraXBNYXJrdXAgPSB7XG4gICAgW1R5cGUuQmxvY2txdW90ZV0oYmwsIGN4LCBsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLm5leHQgIT0gNjIgLyogJz4nICovKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsaW5lLm1hcmtlcnMucHVzaChlbHQoVHlwZS5RdW90ZU1hcmssIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcyArIDEpKTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZShsaW5lLnBvcyArIChzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChsaW5lLnBvcyArIDEpKSA/IDIgOiAxKSk7XG4gICAgICAgIGJsLmVuZCA9IGN4LmxpbmVTdGFydCArIGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgW1R5cGUuTGlzdEl0ZW1dKGJsLCBfY3gsIGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuaW5kZW50IDwgbGluZS5iYXNlSW5kZW50ICsgYmwudmFsdWUgJiYgbGluZS5uZXh0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxpbmUubW92ZUJhc2VDb2x1bW4obGluZS5iYXNlSW5kZW50ICsgYmwudmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFtUeXBlLk9yZGVyZWRMaXN0XTogc2tpcEZvckxpc3QsXG4gICAgW1R5cGUuQnVsbGV0TGlzdF06IHNraXBGb3JMaXN0LFxuICAgIFtUeXBlLkRvY3VtZW50XSgpIHsgcmV0dXJuIHRydWU7IH1cbn07XG5mdW5jdGlvbiBzcGFjZShjaCkgeyByZXR1cm4gY2ggPT0gMzIgfHwgY2ggPT0gOSB8fCBjaCA9PSAxMCB8fCBjaCA9PSAxMzsgfVxuZnVuY3Rpb24gc2tpcFNwYWNlKGxpbmUsIGkgPSAwKSB7XG4gICAgd2hpbGUgKGkgPCBsaW5lLmxlbmd0aCAmJiBzcGFjZShsaW5lLmNoYXJDb2RlQXQoaSkpKVxuICAgICAgICBpKys7XG4gICAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBza2lwU3BhY2VCYWNrKGxpbmUsIGksIHRvKSB7XG4gICAgd2hpbGUgKGkgPiB0byAmJiBzcGFjZShsaW5lLmNoYXJDb2RlQXQoaSAtIDEpKSlcbiAgICAgICAgaS0tO1xuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gaXNGZW5jZWRDb2RlKGxpbmUpIHtcbiAgICBpZiAobGluZS5uZXh0ICE9IDk2ICYmIGxpbmUubmV4dCAhPSAxMjYgLyogJ2B+JyAqLylcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBwb3MgPSBsaW5lLnBvcyArIDE7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudGV4dC5sZW5ndGggJiYgbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKSA9PSBsaW5lLm5leHQpXG4gICAgICAgIHBvcysrO1xuICAgIGlmIChwb3MgPCBsaW5lLnBvcyArIDMpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAobGluZS5uZXh0ID09IDk2KVxuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgbGluZS50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGxpbmUudGV4dC5jaGFyQ29kZUF0KGkpID09IDk2KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gcG9zO1xufVxuZnVuY3Rpb24gaXNCbG9ja3F1b3RlKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5uZXh0ICE9IDYyIC8qICc+JyAqLyA/IC0xIDogbGluZS50ZXh0LmNoYXJDb2RlQXQobGluZS5wb3MgKyAxKSA9PSAzMiA/IDIgOiAxO1xufVxuZnVuY3Rpb24gaXNIb3Jpem9udGFsUnVsZShsaW5lLCBjeCwgYnJlYWtpbmcpIHtcbiAgICBpZiAobGluZS5uZXh0ICE9IDQyICYmIGxpbmUubmV4dCAhPSA0NSAmJiBsaW5lLm5leHQgIT0gOTUgLyogJ18tKicgKi8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgY291bnQgPSAxO1xuICAgIGZvciAobGV0IHBvcyA9IGxpbmUucG9zICsgMTsgcG9zIDwgbGluZS50ZXh0Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgbGV0IGNoID0gbGluZS50ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGNoID09IGxpbmUubmV4dClcbiAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIGVsc2UgaWYgKCFzcGFjZShjaCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIFNldGV4dCBoZWFkZXJzIHRha2UgcHJlY2VkZW5jZVxuICAgIGlmIChicmVha2luZyAmJiBsaW5lLm5leHQgPT0gNDUgJiYgaXNTZXRleHRVbmRlcmxpbmUobGluZSkgPiAtMSAmJiBsaW5lLmRlcHRoID09IGN4LnN0YWNrLmxlbmd0aCAmJlxuICAgICAgICBjeC5wYXJzZXIubGVhZkJsb2NrUGFyc2Vycy5pbmRleE9mKERlZmF1bHRMZWFmQmxvY2tzLlNldGV4dEhlYWRpbmcpID4gLTEpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gY291bnQgPCAzID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gaW5MaXN0KGN4LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IGN4LnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBpZiAoY3guc3RhY2tbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNCdWxsZXRMaXN0KGxpbmUsIGN4LCBicmVha2luZykge1xuICAgIHJldHVybiAobGluZS5uZXh0ID09IDQ1IHx8IGxpbmUubmV4dCA9PSA0MyB8fCBsaW5lLm5leHQgPT0gNDIgLyogJy0rKicgKi8pICYmXG4gICAgICAgIChsaW5lLnBvcyA9PSBsaW5lLnRleHQubGVuZ3RoIC0gMSB8fCBzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChsaW5lLnBvcyArIDEpKSkgJiZcbiAgICAgICAgKCFicmVha2luZyB8fCBpbkxpc3QoY3gsIFR5cGUuQnVsbGV0TGlzdCkgfHwgbGluZS5za2lwU3BhY2UobGluZS5wb3MgKyAyKSA8IGxpbmUudGV4dC5sZW5ndGgpID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gaXNPcmRlcmVkTGlzdChsaW5lLCBjeCwgYnJlYWtpbmcpIHtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MsIG5leHQgPSBsaW5lLm5leHQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3IC8qICcwLTknICovKVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAocG9zID09IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICBpZiAocG9zID09IGxpbmUucG9zIHx8IHBvcyA+IGxpbmUucG9zICsgOSB8fFxuICAgICAgICAobmV4dCAhPSA0NiAmJiBuZXh0ICE9IDQxIC8qICcuKScgKi8pIHx8XG4gICAgICAgIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoIC0gMSAmJiAhc3BhY2UobGluZS50ZXh0LmNoYXJDb2RlQXQocG9zICsgMSkpKSB8fFxuICAgICAgICBicmVha2luZyAmJiAhaW5MaXN0KGN4LCBUeXBlLk9yZGVyZWRMaXN0KSAmJlxuICAgICAgICAgICAgKGxpbmUuc2tpcFNwYWNlKHBvcyArIDEpID09IGxpbmUudGV4dC5sZW5ndGggfHwgcG9zID4gbGluZS5wb3MgKyAxIHx8IGxpbmUubmV4dCAhPSA0OSAvKiAnMScgKi8pKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIHBvcyArIDEgLSBsaW5lLnBvcztcbn1cbmZ1bmN0aW9uIGlzQXR4SGVhZGluZyhsaW5lKSB7XG4gICAgaWYgKGxpbmUubmV4dCAhPSAzNSAvKiAnIycgKi8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MgKyAxO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgPT0gMzUpXG4gICAgICAgIHBvcysrO1xuICAgIGlmIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgIT0gMzIpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgc2l6ZSA9IHBvcyAtIGxpbmUucG9zO1xuICAgIHJldHVybiBzaXplID4gNiA/IC0xIDogc2l6ZTtcbn1cbmZ1bmN0aW9uIGlzU2V0ZXh0VW5kZXJsaW5lKGxpbmUpIHtcbiAgICBpZiAobGluZS5uZXh0ICE9IDQ1ICYmIGxpbmUubmV4dCAhPSA2MSAvKiAnLT0nICovIHx8IGxpbmUuaW5kZW50ID49IGxpbmUuYmFzZUluZGVudCArIDQpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgcG9zID0gbGluZS5wb3MgKyAxO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykgPT0gbGluZS5uZXh0KVxuICAgICAgICBwb3MrKztcbiAgICBsZXQgZW5kID0gcG9zO1xuICAgIHdoaWxlIChwb3MgPCBsaW5lLnRleHQubGVuZ3RoICYmIHNwYWNlKGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcykpKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zID09IGxpbmUudGV4dC5sZW5ndGggPyBlbmQgOiAtMTtcbn1cbmNvbnN0IEVtcHR5TGluZSA9IC9eWyBcXHRdKiQvLCBDb21tZW50RW5kID0gLy0tPi8sIFByb2Nlc3NpbmdFbmQgPSAvXFw/Pi87XG5jb25zdCBIVE1MQmxvY2tTdHlsZSA9IFtcbiAgICBbL148KD86c2NyaXB0fHByZXxzdHlsZSkoPzpcXHN8PnwkKS9pLCAvPFxcLyg/OnNjcmlwdHxwcmV8c3R5bGUpPi9pXSxcbiAgICBbL15cXHMqPCEtLS8sIENvbW1lbnRFbmRdLFxuICAgIFsvXlxccyo8XFw/LywgUHJvY2Vzc2luZ0VuZF0sXG4gICAgWy9eXFxzKjwhW0EtWl0vLCAvPi9dLFxuICAgIFsvXlxccyo8IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vXSxcbiAgICBbL15cXHMqPFxcLz8oPzphZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbnxjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18ZnJhbWV8ZnJhbWVzZXR8aDF8aDJ8aDN8aDR8aDV8aDZ8aGVhZHxoZWFkZXJ8aHJ8aHRtbHxpZnJhbWV8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb258cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyfHRyYWNrfHVsKSg/Olxcc3xcXC8/PnwkKS9pLCBFbXB0eUxpbmVdLFxuICAgIFsvXlxccyooPzo8XFwvW2Etel1bXFx3LV0qXFxzKj58PFthLXpdW1xcdy1dKihcXHMrW2EtejpfXVtcXHctLl0qKD86XFxzKj1cXHMqKD86W15cXHNcIic9PD5gXSt8J1teJ10qJ3xcIlteXCJdKlwiKSk/KSpcXHMqPilcXHMqJC9pLCBFbXB0eUxpbmVdXG5dO1xuZnVuY3Rpb24gaXNIVE1MQmxvY2sobGluZSwgX2N4LCBicmVha2luZykge1xuICAgIGlmIChsaW5lLm5leHQgIT0gNjAgLyogJzwnICovKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IHJlc3QgPSBsaW5lLnRleHQuc2xpY2UobGluZS5wb3MpO1xuICAgIGZvciAobGV0IGkgPSAwLCBlID0gSFRNTEJsb2NrU3R5bGUubGVuZ3RoIC0gKGJyZWFraW5nID8gMSA6IDApOyBpIDwgZTsgaSsrKVxuICAgICAgICBpZiAoSFRNTEJsb2NrU3R5bGVbaV1bMF0udGVzdChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJbmRlbnQobGluZSwgcG9zKSB7XG4gICAgbGV0IGluZGVudEFmdGVyID0gbGluZS5jb3VudEluZGVudChwb3MsIGxpbmUucG9zLCBsaW5lLmluZGVudCk7XG4gICAgbGV0IGluZGVudGVkID0gbGluZS5jb3VudEluZGVudChsaW5lLnNraXBTcGFjZShwb3MpLCBwb3MsIGluZGVudEFmdGVyKTtcbiAgICByZXR1cm4gaW5kZW50ZWQgPj0gaW5kZW50QWZ0ZXIgKyA1ID8gaW5kZW50QWZ0ZXIgKyAxIDogaW5kZW50ZWQ7XG59XG5mdW5jdGlvbiBhZGRDb2RlVGV4dChtYXJrcywgZnJvbSwgdG8pIHtcbiAgICBsZXQgbGFzdCA9IG1hcmtzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBtYXJrc1tsYXN0XS50byA9PSBmcm9tICYmIG1hcmtzW2xhc3RdLnR5cGUgPT0gVHlwZS5Db2RlVGV4dClcbiAgICAgICAgbWFya3NbbGFzdF0udG8gPSB0bztcbiAgICBlbHNlXG4gICAgICAgIG1hcmtzLnB1c2goZWx0KFR5cGUuQ29kZVRleHQsIGZyb20sIHRvKSk7XG59XG4vLyBSdWxlcyBmb3IgcGFyc2luZyBibG9ja3MuIEEgcmV0dXJuIHZhbHVlIG9mIGZhbHNlIG1lYW5zIHRoZSBydWxlXG4vLyBkb2Vzbid0IGFwcGx5IGhlcmUsIHRydWUgbWVhbnMgaXQgZG9lcy4gV2hlbiB0cnVlIGlzIHJldHVybmVkIGFuZFxuLy8gYHAubGluZWAgaGFzIGJlZW4gdXBkYXRlZCwgdGhlIHJ1bGUgaXMgYXNzdW1lZCB0byBoYXZlIGNvbnN1bWVkIGFcbi8vIGxlYWYgYmxvY2suIE90aGVyd2lzZSwgaXQgaXMgYXNzdW1lZCB0byBoYXZlIG9wZW5lZCBhIGNvbnRleHQuXG5jb25zdCBEZWZhdWx0QmxvY2tQYXJzZXJzID0ge1xuICAgIExpbmtSZWZlcmVuY2U6IHVuZGVmaW5lZCxcbiAgICBJbmRlbnRlZENvZGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBsaW5lLmJhc2VJbmRlbnQgKyA0O1xuICAgICAgICBpZiAobGluZS5pbmRlbnQgPCBiYXNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSBsaW5lLmZpbmRDb2x1bW4oYmFzZSk7XG4gICAgICAgIGxldCBmcm9tID0gY3gubGluZVN0YXJ0ICsgc3RhcnQsIHRvID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG1hcmtzID0gW10sIHBlbmRpbmdNYXJrcyA9IFtdO1xuICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgZnJvbSwgdG8pO1xuICAgICAgICB3aGlsZSAoY3gubmV4dExpbmUoKSAmJiBsaW5lLmRlcHRoID49IGN4LnN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxpbmUucG9zID09IGxpbmUudGV4dC5sZW5ndGgpIHsgLy8gRW1wdHlcbiAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChwZW5kaW5nTWFya3MsIGN4LmxpbmVTdGFydCAtIDEsIGN4LmxpbmVTdGFydCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBsaW5lLm1hcmtlcnMpXG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdNYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGluZS5pbmRlbnQgPCBiYXNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ01hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtIG9mIHBlbmRpbmdNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0udHlwZSA9PSBUeXBlLkNvZGVUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBtLmZyb20sIG0udG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzLnB1c2gobSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ01hcmtzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBjeC5saW5lU3RhcnQgLSAxLCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIHRvID0gY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZVN0YXJ0ID0gY3gubGluZVN0YXJ0ICsgbGluZS5maW5kQ29sdW1uKGxpbmUuYmFzZUluZGVudCArIDQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlU3RhcnQgPCB0bylcbiAgICAgICAgICAgICAgICAgICAgYWRkQ29kZVRleHQobWFya3MsIGNvZGVTdGFydCwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwZW5kaW5nTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBwZW5kaW5nTWFya3MgPSBwZW5kaW5nTWFya3MuZmlsdGVyKG0gPT4gbS50eXBlICE9IFR5cGUuQ29kZVRleHQpO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdNYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGluZS5tYXJrZXJzID0gcGVuZGluZ01hcmtzLmNvbmNhdChsaW5lLm1hcmtlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGN4LmFkZE5vZGUoY3guYnVmZmVyLndyaXRlRWxlbWVudHMobWFya3MsIC1mcm9tKS5maW5pc2goVHlwZS5Db2RlQmxvY2ssIHRvIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEZlbmNlZENvZGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IGZlbmNlRW5kID0gaXNGZW5jZWRDb2RlKGxpbmUpO1xuICAgICAgICBpZiAoZmVuY2VFbmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZnJvbSA9IGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjaCA9IGxpbmUubmV4dCwgbGVuID0gZmVuY2VFbmQgLSBsaW5lLnBvcztcbiAgICAgICAgbGV0IGluZm9Gcm9tID0gbGluZS5za2lwU3BhY2UoZmVuY2VFbmQpLCBpbmZvVG8gPSBza2lwU3BhY2VCYWNrKGxpbmUudGV4dCwgbGluZS50ZXh0Lmxlbmd0aCwgaW5mb0Zyb20pO1xuICAgICAgICBsZXQgbWFya3MgPSBbZWx0KFR5cGUuQ29kZU1hcmssIGZyb20sIGZyb20gKyBsZW4pXTtcbiAgICAgICAgaWYgKGluZm9Gcm9tIDwgaW5mb1RvKVxuICAgICAgICAgICAgbWFya3MucHVzaChlbHQoVHlwZS5Db2RlSW5mbywgY3gubGluZVN0YXJ0ICsgaW5mb0Zyb20sIGN4LmxpbmVTdGFydCArIGluZm9UbykpO1xuICAgICAgICBmb3IgKGxldCBmaXJzdCA9IHRydWU7IGN4Lm5leHRMaW5lKCkgJiYgbGluZS5kZXB0aCA+PSBjeC5zdGFjay5sZW5ndGg7IGZpcnN0ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGxldCBpID0gbGluZS5wb3M7XG4gICAgICAgICAgICBpZiAobGluZS5pbmRlbnQgLSBsaW5lLmJhc2VJbmRlbnQgPCA0KVxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgbGluZS50ZXh0Lmxlbmd0aCAmJiBsaW5lLnRleHQuY2hhckNvZGVBdChpKSA9PSBjaClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgLSBsaW5lLnBvcyA+PSBsZW4gJiYgbGluZS5za2lwU3BhY2UoaSkgPT0gbGluZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goZWx0KFR5cGUuQ29kZU1hcmssIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBpKSk7XG4gICAgICAgICAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGFkZENvZGVUZXh0KG1hcmtzLCBjeC5saW5lU3RhcnQgLSAxLCBjeC5saW5lU3RhcnQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0U3RhcnQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLmJhc2VQb3MsIHRleHRFbmQgPSBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPCB0ZXh0RW5kKVxuICAgICAgICAgICAgICAgICAgICBhZGRDb2RlVGV4dChtYXJrcywgdGV4dFN0YXJ0LCB0ZXh0RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjeC5hZGROb2RlKGN4LmJ1ZmZlci53cml0ZUVsZW1lbnRzKG1hcmtzLCAtZnJvbSlcbiAgICAgICAgICAgIC5maW5pc2goVHlwZS5GZW5jZWRDb2RlLCBjeC5wcmV2TGluZUVuZCgpIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEJsb2NrcXVvdGUoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc0Jsb2NrcXVvdGUobGluZSk7XG4gICAgICAgIGlmIChzaXplIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuQmxvY2txdW90ZSwgbGluZS5wb3MpO1xuICAgICAgICBjeC5hZGROb2RlKFR5cGUuUXVvdGVNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MgKyAxKTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZShsaW5lLnBvcyArIHNpemUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIEhvcml6b250YWxSdWxlKGN4LCBsaW5lKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWxSdWxlKGxpbmUsIGN4LCBmYWxzZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZnJvbSA9IGN4LmxpbmVTdGFydCArIGxpbmUucG9zO1xuICAgICAgICBjeC5uZXh0TGluZSgpO1xuICAgICAgICBjeC5hZGROb2RlKFR5cGUuSG9yaXpvbnRhbFJ1bGUsIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIEJ1bGxldExpc3QoY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHNpemUgPSBpc0J1bGxldExpc3QobGluZSwgY3gsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3guYmxvY2sudHlwZSAhPSBUeXBlLkJ1bGxldExpc3QpXG4gICAgICAgICAgICBjeC5zdGFydENvbnRleHQoVHlwZS5CdWxsZXRMaXN0LCBsaW5lLmJhc2VQb3MsIGxpbmUubmV4dCk7XG4gICAgICAgIGxldCBuZXdCYXNlID0gZ2V0TGlzdEluZGVudChsaW5lLCBsaW5lLnBvcyArIDEpO1xuICAgICAgICBjeC5zdGFydENvbnRleHQoVHlwZS5MaXN0SXRlbSwgbGluZS5iYXNlUG9zLCBuZXdCYXNlIC0gbGluZS5iYXNlSW5kZW50KTtcbiAgICAgICAgY3guYWRkTm9kZShUeXBlLkxpc3RNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MgKyBzaXplKTtcbiAgICAgICAgbGluZS5tb3ZlQmFzZUNvbHVtbihuZXdCYXNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBPcmRlcmVkTGlzdChjeCwgbGluZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IGlzT3JkZXJlZExpc3QobGluZSwgY3gsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3guYmxvY2sudHlwZSAhPSBUeXBlLk9yZGVyZWRMaXN0KVxuICAgICAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuT3JkZXJlZExpc3QsIGxpbmUuYmFzZVBvcywgbGluZS50ZXh0LmNoYXJDb2RlQXQobGluZS5wb3MgKyBzaXplIC0gMSkpO1xuICAgICAgICBsZXQgbmV3QmFzZSA9IGdldExpc3RJbmRlbnQobGluZSwgbGluZS5wb3MgKyBzaXplKTtcbiAgICAgICAgY3guc3RhcnRDb250ZXh0KFR5cGUuTGlzdEl0ZW0sIGxpbmUuYmFzZVBvcywgbmV3QmFzZSAtIGxpbmUuYmFzZUluZGVudCk7XG4gICAgICAgIGN4LmFkZE5vZGUoVHlwZS5MaXN0TWFyaywgY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zICsgc2l6ZSk7XG4gICAgICAgIGxpbmUubW92ZUJhc2VDb2x1bW4obmV3QmFzZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgQVRYSGVhZGluZyhjeCwgbGluZSkge1xuICAgICAgICBsZXQgc2l6ZSA9IGlzQXR4SGVhZGluZyhsaW5lKTtcbiAgICAgICAgaWYgKHNpemUgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb2ZmID0gbGluZS5wb3MsIGZyb20gPSBjeC5saW5lU3RhcnQgKyBvZmY7XG4gICAgICAgIGxldCBlbmRPZlNwYWNlID0gc2tpcFNwYWNlQmFjayhsaW5lLnRleHQsIGxpbmUudGV4dC5sZW5ndGgsIG9mZiksIGFmdGVyID0gZW5kT2ZTcGFjZTtcbiAgICAgICAgd2hpbGUgKGFmdGVyID4gb2ZmICYmIGxpbmUudGV4dC5jaGFyQ29kZUF0KGFmdGVyIC0gMSkgPT0gbGluZS5uZXh0KVxuICAgICAgICAgICAgYWZ0ZXItLTtcbiAgICAgICAgaWYgKGFmdGVyID09IGVuZE9mU3BhY2UgfHwgYWZ0ZXIgPT0gb2ZmIHx8ICFzcGFjZShsaW5lLnRleHQuY2hhckNvZGVBdChhZnRlciAtIDEpKSlcbiAgICAgICAgICAgIGFmdGVyID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1ZiA9IGN4LmJ1ZmZlclxuICAgICAgICAgICAgLndyaXRlKFR5cGUuSGVhZGVyTWFyaywgMCwgc2l6ZSlcbiAgICAgICAgICAgIC53cml0ZUVsZW1lbnRzKGN4LnBhcnNlci5wYXJzZUlubGluZShsaW5lLnRleHQuc2xpY2Uob2ZmICsgc2l6ZSArIDEsIGFmdGVyKSwgZnJvbSArIHNpemUgKyAxKSwgLWZyb20pO1xuICAgICAgICBpZiAoYWZ0ZXIgPCBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgYnVmLndyaXRlKFR5cGUuSGVhZGVyTWFyaywgYWZ0ZXIgLSBvZmYsIGVuZE9mU3BhY2UgLSBvZmYpO1xuICAgICAgICBsZXQgbm9kZSA9IGJ1Zi5maW5pc2goVHlwZS5BVFhIZWFkaW5nMSAtIDEgKyBzaXplLCBsaW5lLnRleHQubGVuZ3RoIC0gb2ZmKTtcbiAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgY3guYWRkTm9kZShub2RlLCBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBIVE1MQmxvY2soY3gsIGxpbmUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBpc0hUTUxCbG9jayhsaW5lLCBjeCwgZmFsc2UpO1xuICAgICAgICBpZiAodHlwZSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBmcm9tID0gY3gubGluZVN0YXJ0ICsgbGluZS5wb3MsIGVuZCA9IEhUTUxCbG9ja1N0eWxlW3R5cGVdWzFdO1xuICAgICAgICBsZXQgbWFya3MgPSBbXSwgdHJhaWxpbmcgPSBlbmQgIT0gRW1wdHlMaW5lO1xuICAgICAgICB3aGlsZSAoIWVuZC50ZXN0KGxpbmUudGV4dCkgJiYgY3gubmV4dExpbmUoKSkge1xuICAgICAgICAgICAgaWYgKGxpbmUuZGVwdGggPCBjeC5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBsaW5lLm1hcmtlcnMpXG4gICAgICAgICAgICAgICAgbWFya3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaWxpbmcpXG4gICAgICAgICAgICBjeC5uZXh0TGluZSgpO1xuICAgICAgICBsZXQgbm9kZVR5cGUgPSBlbmQgPT0gQ29tbWVudEVuZCA/IFR5cGUuQ29tbWVudEJsb2NrIDogZW5kID09IFByb2Nlc3NpbmdFbmQgPyBUeXBlLlByb2Nlc3NpbmdJbnN0cnVjdGlvbkJsb2NrIDogVHlwZS5IVE1MQmxvY2s7XG4gICAgICAgIGxldCB0byA9IGN4LnByZXZMaW5lRW5kKCk7XG4gICAgICAgIGN4LmFkZE5vZGUoY3guYnVmZmVyLndyaXRlRWxlbWVudHMobWFya3MsIC1mcm9tKS5maW5pc2gobm9kZVR5cGUsIHRvIC0gZnJvbSksIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFNldGV4dEhlYWRpbmc6IHVuZGVmaW5lZCAvLyBTcGVjaWZpZXMgcmVsYXRpdmUgcHJlY2VkZW5jZSBmb3IgYmxvY2stY29udGludWUgZnVuY3Rpb25cbn07XG4vLyBUaGlzIGltcGxlbWVudHMgYSBzdGF0ZSBtYWNoaW5lIHRoYXQgaW5jcmVtZW50YWxseSBwYXJzZXMgbGluayByZWZlcmVuY2VzLiBBdCBlYWNoXG4vLyBuZXh0IGxpbmUsIGl0IGxvb2tzIGFoZWFkIHRvIHNlZSBpZiB0aGUgbGluZSBjb250aW51ZXMgdGhlIHJlZmVyZW5jZSBvciBub3QuIElmIGl0XG4vLyBkb2Vzbid0IGFuZCBhIHZhbGlkIGxpbmsgaXMgYXZhaWxhYmxlIGVuZGluZyBiZWZvcmUgdGhhdCBsaW5lLCBpdCBmaW5pc2hlcyB0aGF0LlxuLy8gU2ltaWxhcmx5LCBvbiBgZmluaXNoYCAod2hlbiB0aGUgbGVhZiBpcyB0ZXJtaW5hdGVkIGJ5IGV4dGVybmFsIGNpcmN1bXN0YW5jZXMpLCBpdFxuLy8gY3JlYXRlcyBhIGxpbmsgcmVmZXJlbmNlIGlmIHRoZXJlJ3MgYSB2YWxpZCByZWZlcmVuY2UgdXAgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG5jbGFzcyBMaW5rUmVmZXJlbmNlUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihsZWFmKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSAwIC8qIFJlZlN0YWdlLlN0YXJ0ICovO1xuICAgICAgICB0aGlzLmVsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbGVhZi5zdGFydDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKGxlYWYuY29udGVudCk7XG4gICAgfVxuICAgIG5leHRMaW5lKGN4LCBsaW5lLCBsZWFmKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlID09IC0xIC8qIFJlZlN0YWdlLkZhaWxlZCAqLylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBsZWFmLmNvbnRlbnQgKyBcIlxcblwiICsgbGluZS5zY3J1YigpO1xuICAgICAgICBsZXQgZmluaXNoID0gdGhpcy5hZHZhbmNlKGNvbnRlbnQpO1xuICAgICAgICBpZiAoZmluaXNoID4gLTEgJiYgZmluaXNoIDwgY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShjeCwgbGVhZiwgZmluaXNoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5pc2goY3gsIGxlYWYpIHtcbiAgICAgICAgaWYgKCh0aGlzLnN0YWdlID09IDIgLyogUmVmU3RhZ2UuTGluayAqLyB8fCB0aGlzLnN0YWdlID09IDMgLyogUmVmU3RhZ2UuVGl0bGUgKi8pICYmIHNraXBTcGFjZShsZWFmLmNvbnRlbnQsIHRoaXMucG9zKSA9PSBsZWFmLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUoY3gsIGxlYWYsIGxlYWYuY29udGVudC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbXBsZXRlKGN4LCBsZWFmLCBsZW4pIHtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KFR5cGUuTGlua1JlZmVyZW5jZSwgdGhpcy5zdGFydCwgdGhpcy5zdGFydCArIGxlbiwgdGhpcy5lbHRzKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBuZXh0U3RhZ2UoZWx0KSB7XG4gICAgICAgIGlmIChlbHQpIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gZWx0LnRvIC0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuZWx0cy5wdXNoKGVsdCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlKys7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UgPSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi87XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWR2YW5jZShjb250ZW50KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YWdlID09IC0xIC8qIFJlZlN0YWdlLkZhaWxlZCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhZ2UgPT0gMCAvKiBSZWZTdGFnZS5TdGFydCAqLykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXh0U3RhZ2UocGFyc2VMaW5rTGFiZWwoY29udGVudCwgdGhpcy5wb3MsIHRoaXMuc3RhcnQsIHRydWUpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmNoYXJDb2RlQXQodGhpcy5wb3MpICE9IDU4IC8qICc6JyAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UgPSAtMSAvKiBSZWZTdGFnZS5GYWlsZWQgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5lbHRzLnB1c2goZWx0KFR5cGUuTGlua01hcmssIHRoaXMucG9zICsgdGhpcy5zdGFydCwgdGhpcy5wb3MgKyB0aGlzLnN0YXJ0ICsgMSkpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YWdlID09IDEgLyogUmVmU3RhZ2UuTGFiZWwgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmV4dFN0YWdlKHBhcnNlVVJMKGNvbnRlbnQsIHNraXBTcGFjZShjb250ZW50LCB0aGlzLnBvcyksIHRoaXMuc3RhcnQpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFnZSA9PSAyIC8qIFJlZlN0YWdlLkxpbmsgKi8pIHtcbiAgICAgICAgICAgICAgICBsZXQgc2tpcCA9IHNraXBTcGFjZShjb250ZW50LCB0aGlzLnBvcyksIGVuZCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiB0aGlzLnBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGUgPSBwYXJzZUxpbmtUaXRsZShjb250ZW50LCBza2lwLCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGl0bGVFbmQgPSBsaW5lRW5kKGNvbnRlbnQsIHRpdGxlLnRvIC0gdGhpcy5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGl0bGVFbmQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0U3RhZ2UodGl0bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHRpdGxlRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW5kKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBsaW5lRW5kKGNvbnRlbnQsIHRoaXMucG9zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kID4gMCAmJiBlbmQgPCBjb250ZW50Lmxlbmd0aCA/IGVuZCA6IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIFJlZlN0YWdlLlRpdGxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVFbmQoY29udGVudCwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbGluZUVuZCh0ZXh0LCBwb3MpIHtcbiAgICBmb3IgKDsgcG9zIDwgdGV4dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChuZXh0ID09IDEwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICghc3BhY2UobmV4dCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5jbGFzcyBTZXRleHRIZWFkaW5nUGFyc2VyIHtcbiAgICBuZXh0TGluZShjeCwgbGluZSwgbGVhZikge1xuICAgICAgICBsZXQgdW5kZXJsaW5lID0gbGluZS5kZXB0aCA8IGN4LnN0YWNrLmxlbmd0aCA/IC0xIDogaXNTZXRleHRVbmRlcmxpbmUobGluZSk7XG4gICAgICAgIGxldCBuZXh0ID0gbGluZS5uZXh0O1xuICAgICAgICBpZiAodW5kZXJsaW5lIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHVuZGVybGluZU1hcmsgPSBlbHQoVHlwZS5IZWFkZXJNYXJrLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgdW5kZXJsaW5lKTtcbiAgICAgICAgY3gubmV4dExpbmUoKTtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KG5leHQgPT0gNjEgPyBUeXBlLlNldGV4dEhlYWRpbmcxIDogVHlwZS5TZXRleHRIZWFkaW5nMiwgbGVhZi5zdGFydCwgY3gucHJldkxpbmVFbmQoKSwgW1xuICAgICAgICAgICAgLi4uY3gucGFyc2VyLnBhcnNlSW5saW5lKGxlYWYuY29udGVudCwgbGVhZi5zdGFydCksXG4gICAgICAgICAgICB1bmRlcmxpbmVNYXJrXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IERlZmF1bHRMZWFmQmxvY2tzID0ge1xuICAgIExpbmtSZWZlcmVuY2UoXywgbGVhZikgeyByZXR1cm4gbGVhZi5jb250ZW50LmNoYXJDb2RlQXQoMCkgPT0gOTEgLyogJ1snICovID8gbmV3IExpbmtSZWZlcmVuY2VQYXJzZXIobGVhZikgOiBudWxsOyB9LFxuICAgIFNldGV4dEhlYWRpbmcoKSB7IHJldHVybiBuZXcgU2V0ZXh0SGVhZGluZ1BhcnNlcjsgfVxufTtcbmNvbnN0IERlZmF1bHRFbmRMZWFmID0gW1xuICAgIChfLCBsaW5lKSA9PiBpc0F0eEhlYWRpbmcobGluZSkgPj0gMCxcbiAgICAoXywgbGluZSkgPT4gaXNGZW5jZWRDb2RlKGxpbmUpID49IDAsXG4gICAgKF8sIGxpbmUpID0+IGlzQmxvY2txdW90ZShsaW5lKSA+PSAwLFxuICAgIChwLCBsaW5lKSA9PiBpc0J1bGxldExpc3QobGluZSwgcCwgdHJ1ZSkgPj0gMCxcbiAgICAocCwgbGluZSkgPT4gaXNPcmRlcmVkTGlzdChsaW5lLCBwLCB0cnVlKSA+PSAwLFxuICAgIChwLCBsaW5lKSA9PiBpc0hvcml6b250YWxSdWxlKGxpbmUsIHAsIHRydWUpID49IDAsXG4gICAgKHAsIGxpbmUpID0+IGlzSFRNTEJsb2NrKGxpbmUsIHAsIHRydWUpID49IDBcbl07XG5jb25zdCBzY2FuTGluZVJlc3VsdCA9IHsgdGV4dDogXCJcIiwgZW5kOiAwIH07XG4vKipcbkJsb2NrLWxldmVsIHBhcnNpbmcgZnVuY3Rpb25zIGdldCBhY2Nlc3MgdG8gdGhpcyBjb250ZXh0IG9iamVjdC5cbiovXG5jbGFzcyBCbG9ja0NvbnRleHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlciBjb25maWd1cmF0aW9uIHVzZWQuXG4gICAgKi9cbiAgICBwYXJzZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5wdXQsIGZyYWdtZW50cywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubGluZSA9IG5ldyBMaW5lKCk7XG4gICAgICAgIHRoaXMuYXRFbmQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEZvciByZXVzZWQgbm9kZXMgb24gZ2Fwcywgd2UgY2FuJ3QgZGlyZWN0bHkgcHV0IHRoZSBvcmlnaW5hbFxuICAgICAgICBub2RlIGludG8gdGhlIHRyZWUsIHNpbmNlIHRoYXQgbWF5IGJlIGJpZ2dlciB0aGFuIGl0cyBwYXJlbnQuXG4gICAgICAgIFdoZW4gdGhpcyBoYXBwZW5zLCB3ZSBjcmVhdGUgYSBkdW1teSB0cmVlIHRoYXQgaXMgcmVwbGFjZWQgYnlcbiAgICAgICAgdGhlIHByb3BlciBub2RlIGluIGBpbmplY3RHYXBzYCBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXVzZVBsYWNlaG9sZGVycyA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSByYW5nZSBpbmRleCB0aGF0IGFic29sdXRlTGluZVN0YXJ0IHBvaW50cyBpbnRvIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhbmdlSSA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgPSB0aGlzLmFic29sdXRlTGluZUVuZCA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICB0aGlzLmJsb2NrID0gQ29tcG9zaXRlQmxvY2suY3JlYXRlKFR5cGUuRG9jdW1lbnQsIDAsIHRoaXMubGluZVN0YXJ0LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFt0aGlzLmJsb2NrXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoID8gbmV3IEZyYWdtZW50Q3Vyc29yKGZyYWdtZW50cywgaW5wdXQpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkTGluZSgpO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZUxpbmVTdGFydDtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA+IHRoaXMuc3RvcHBlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGxldCB7IGxpbmUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IG1hcmtJID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBsaW5lLmRlcHRoIDwgdGhpcy5zdGFjay5sZW5ndGggPyB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtYXJrSSA8IGxpbmUubWFya2Vycy5sZW5ndGggJiYgKCFuZXh0IHx8IGxpbmUubWFya2Vyc1ttYXJrSV0uZnJvbSA8IG5leHQuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGxpbmUubWFya2Vyc1ttYXJrSSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGROb2RlKG1hcmsudHlwZSwgbWFyay5mcm9tLCBtYXJrLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaENvbnRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lLnBvcyA8IGxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBFbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoIXRoaXMubmV4dExpbmUoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMgJiYgdGhpcy5yZXVzZUZyYWdtZW50KGxpbmUuYmFzZVBvcykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3RhcnQ6IGZvciAoOzspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy5wYXJzZXIuYmxvY2tQYXJzZXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0eXBlKHRoaXMsIGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLmZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlYWYgPSBuZXcgTGVhZkJsb2NrKHRoaXMubGluZVN0YXJ0ICsgbGluZS5wb3MsIGxpbmUudGV4dC5zbGljZShsaW5lLnBvcykpO1xuICAgICAgICBmb3IgKGxldCBwYXJzZSBvZiB0aGlzLnBhcnNlci5sZWFmQmxvY2tQYXJzZXJzKVxuICAgICAgICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlciA9IHBhcnNlKHRoaXMsIGxlYWYpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZXIpXG4gICAgICAgICAgICAgICAgICAgIGxlYWYucGFyc2Vycy5wdXNoKHBhcnNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxpbmVzOiB3aGlsZSAodGhpcy5uZXh0TGluZSgpKSB7XG4gICAgICAgICAgICBpZiAobGluZS5wb3MgPT0gbGluZS50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChsaW5lLmluZGVudCA8IGxpbmUuYmFzZUluZGVudCArIDQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdG9wIG9mIHRoaXMucGFyc2VyLmVuZExlYWZCbG9jaylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AodGhpcywgbGluZSwgbGVhZikpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsaW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnNlciBvZiBsZWFmLnBhcnNlcnMpXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5uZXh0TGluZSh0aGlzLCBsaW5lLCBsZWFmKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZWFmLmNvbnRlbnQgKz0gXCJcXG5cIiArIGxpbmUuc2NydWIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IG0gb2YgbGluZS5tYXJrZXJzKVxuICAgICAgICAgICAgICAgIGxlYWYubWFya3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaExlYWYobGVhZik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgcmV1c2VGcmFnbWVudChzdGFydCkge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ21lbnRzLm1vdmVUbyh0aGlzLmFic29sdXRlTGluZVN0YXJ0ICsgc3RhcnQsIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQpIHx8XG4gICAgICAgICAgICAhdGhpcy5mcmFnbWVudHMubWF0Y2hlcyh0aGlzLmJsb2NrLmhhc2gpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdGFrZW4gPSB0aGlzLmZyYWdtZW50cy50YWtlTm9kZXModGhpcyk7XG4gICAgICAgIGlmICghdGFrZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVMaW5lU3RhcnQgKz0gdGFrZW47XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gdG9SZWxhdGl2ZSh0aGlzLmFic29sdXRlTGluZVN0YXJ0LCB0aGlzLnJhbmdlcyk7XG4gICAgICAgIHRoaXMubW92ZVJhbmdlSSgpO1xuICAgICAgICBpZiAodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBwYXJlbnQgYmxvY2tzIHN1cnJvdW5kaW5nIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICovXG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdHlwZSBvZiB0aGUgcGFyZW50IGJsb2NrIGF0IHRoZSBnaXZlbiBkZXB0aC4gV2hlbiBub1xuICAgIGRlcHRoIGlzIHBhc3NlZCwgcmV0dXJuIHRoZSB0eXBlIG9mIHRoZSBpbm5lcm1vc3QgcGFyZW50LlxuICAgICovXG4gICAgcGFyZW50VHlwZShkZXB0aCA9IHRoaXMuZGVwdGggLSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW3RoaXMuc3RhY2tbZGVwdGhdLnR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IGlucHV0IGxpbmUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5XG4gICAgKG5vbi1jb21wb3NpdGUpIFtibG9jayBwYXJzZXJzXSgjQmxvY2tQYXJzZXIucGFyc2UpIHRoYXQgY29uc3VtZVxuICAgIHRoZSBsaW5lIGRpcmVjdGx5LCBvciBsZWFmIGJsb2NrIHBhcnNlclxuICAgIFtgbmV4dExpbmVgXSgjTGVhZkJsb2NrUGFyc2VyLm5leHRMaW5lKSBtZXRob2RzIHdoZW4gdGhleVxuICAgIGNvbnN1bWUgdGhlIGN1cnJlbnQgbGluZSAoYW5kIHJldHVybiB0cnVlKS5cbiAgICAqL1xuICAgIG5leHRMaW5lKCkge1xuICAgICAgICB0aGlzLmxpbmVTdGFydCArPSB0aGlzLmxpbmUudGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLmFic29sdXRlTGluZUVuZCA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0ID0gdGhpcy5hYnNvbHV0ZUxpbmVFbmQ7XG4gICAgICAgICAgICB0aGlzLmF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVhZExpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0Kys7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0ID0gdGhpcy5hYnNvbHV0ZUxpbmVFbmQgKyAxO1xuICAgICAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRMaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBvZiB0aGUgbGluZSBhZnRlciB0aGUgY3VycmVudCBvbmUsIHdpdGhvdXRcbiAgICBhY3R1YWxseSBtb3ZpbmcgdGhlIGNvbnRleHQncyBjdXJyZW50IGxpbmUgZm9yd2FyZC5cbiAgICAqL1xuICAgIHBlZWtMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FuTGluZSh0aGlzLmFic29sdXRlTGluZUVuZCArIDEpLnRleHQ7XG4gICAgfVxuICAgIG1vdmVSYW5nZUkoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlSSA8IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEgJiYgdGhpcy5hYnNvbHV0ZUxpbmVTdGFydCA+PSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSV0udG8pIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2VJKys7XG4gICAgICAgICAgICB0aGlzLmFic29sdXRlTGluZVN0YXJ0ID0gTWF0aC5tYXgodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCwgdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUldLmZyb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgIENvbGxlY3QgdGhlIHRleHQgZm9yIHRoZSBuZXh0IGxpbmUuXG4gICAgKi9cbiAgICBzY2FuTGluZShzdGFydCkge1xuICAgICAgICBsZXQgciA9IHNjYW5MaW5lUmVzdWx0O1xuICAgICAgICByLmVuZCA9IHN0YXJ0O1xuICAgICAgICBpZiAoc3RhcnQgPj0gdGhpcy50bykge1xuICAgICAgICAgICAgci50ZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIudGV4dCA9IHRoaXMubGluZUNodW5rQXQoc3RhcnQpO1xuICAgICAgICAgICAgci5lbmQgKz0gci50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRPZmZzZXQgPSB0aGlzLmFic29sdXRlTGluZVN0YXJ0LCByYW5nZUkgPSB0aGlzLnJhbmdlSTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5yYW5nZXNbcmFuZ2VJXS50byA8IHIuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlSSsrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dEZyb20gPSB0aGlzLnJhbmdlc1tyYW5nZUldLmZyb207XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHRoaXMubGluZUNodW5rQXQobmV4dEZyb20pO1xuICAgICAgICAgICAgICAgICAgICByLmVuZCA9IG5leHRGcm9tICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICByLnRleHQgPSByLnRleHQuc2xpY2UoMCwgdGhpcy5yYW5nZXNbcmFuZ2VJIC0gMV0udG8gLSB0ZXh0T2Zmc2V0KSArIGFmdGVyO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gci5lbmQgLSByLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgUG9wdWxhdGUgdGhpcy5saW5lIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlIG5leHQgbGluZS4gU2tpcFxuICAgIGxlYWRpbmcgY2hhcmFjdGVycyBjb3ZlcmVkIGJ5IGNvbXBvc2l0ZSBibG9ja3MuXG4gICAgKi9cbiAgICByZWFkTGluZSgpIHtcbiAgICAgICAgbGV0IHsgbGluZSB9ID0gdGhpcywgeyB0ZXh0LCBlbmQgfSA9IHRoaXMuc2NhbkxpbmUodGhpcy5hYnNvbHV0ZUxpbmVTdGFydCk7XG4gICAgICAgIHRoaXMuYWJzb2x1dGVMaW5lRW5kID0gZW5kO1xuICAgICAgICBsaW5lLnJlc2V0KHRleHQpO1xuICAgICAgICBmb3IgKDsgbGluZS5kZXB0aCA8IHRoaXMuc3RhY2subGVuZ3RoOyBsaW5lLmRlcHRoKyspIHtcbiAgICAgICAgICAgIGxldCBjeCA9IHRoaXMuc3RhY2tbbGluZS5kZXB0aF0sIGhhbmRsZXIgPSB0aGlzLnBhcnNlci5za2lwQ29udGV4dE1hcmt1cFtjeC50eXBlXTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmhhbmRsZWQgYmxvY2sgY29udGV4dCBcIiArIFR5cGVbY3gudHlwZV0pO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKGN4LCB0aGlzLCBsaW5lKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVDaHVua0F0KHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5wdXQuY2h1bmsocG9zKSwgdGV4dDtcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LmxpbmVDaHVua3MpIHtcbiAgICAgICAgICAgIGxldCBlb2wgPSBuZXh0LmluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICB0ZXh0ID0gZW9sIDwgMCA/IG5leHQgOiBuZXh0LnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gbmV4dCA9PSBcIlxcblwiID8gXCJcIiA6IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyArIHRleHQubGVuZ3RoID4gdGhpcy50byA/IHRleHQuc2xpY2UoMCwgdGhpcy50byAtIHBvcykgOiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSBwcmV2aW91cyBsaW5lLlxuICAgICovXG4gICAgcHJldkxpbmVFbmQoKSB7IHJldHVybiB0aGlzLmF0RW5kID8gdGhpcy5saW5lU3RhcnQgOiB0aGlzLmxpbmVTdGFydCAtIDE7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0Q29udGV4dCh0eXBlLCBzdGFydCwgdmFsdWUgPSAwKSB7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBDb21wb3NpdGVCbG9jay5jcmVhdGUodHlwZSwgdmFsdWUsIHRoaXMubGluZVN0YXJ0ICsgc3RhcnQsIHRoaXMuYmxvY2suaGFzaCwgdGhpcy5saW5lU3RhcnQgKyB0aGlzLmxpbmUudGV4dC5sZW5ndGgpO1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5ibG9jayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGEgY29tcG9zaXRlIGJsb2NrLiBTaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSBbYmxvY2tcbiAgICBwYXJzZXIgZnVuY3Rpb25zXSgjQmxvY2tQYXJzZXIucGFyc2UpIHRoYXQgcmV0dXJuIG51bGwuXG4gICAgKi9cbiAgICBzdGFydENvbXBvc2l0ZSh0eXBlLCBzdGFydCwgdmFsdWUgPSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDb250ZXh0KHRoaXMucGFyc2VyLmdldE5vZGVUeXBlKHR5cGUpLCBzdGFydCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZE5vZGUoYmxvY2ssIGZyb20sIHRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIGJsb2NrID0gbmV3IFRyZWUodGhpcy5wYXJzZXIubm9kZVNldC50eXBlc1tibG9ja10sIG5vbmUsIG5vbmUsICh0byAhPT0gbnVsbCAmJiB0byAhPT0gdm9pZCAwID8gdG8gOiB0aGlzLnByZXZMaW5lRW5kKCkpIC0gZnJvbSk7XG4gICAgICAgIHRoaXMuYmxvY2suYWRkQ2hpbGQoYmxvY2ssIGZyb20gLSB0aGlzLmJsb2NrLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBibG9jayBlbGVtZW50LiBDYW4gYmUgY2FsbGVkIGJ5IFtibG9ja1xuICAgIHBhcnNlcnNdKCNCbG9ja1BhcnNlci5wYXJzZSkuXG4gICAgKi9cbiAgICBhZGRFbGVtZW50KGVsdCkge1xuICAgICAgICB0aGlzLmJsb2NrLmFkZENoaWxkKGVsdC50b1RyZWUodGhpcy5wYXJzZXIubm9kZVNldCksIGVsdC5mcm9tIC0gdGhpcy5ibG9jay5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgYmxvY2sgZWxlbWVudCBmcm9tIGEgW2xlYWYgcGFyc2VyXSgjTGVhZkJsb2NrUGFyc2VyKS4gVGhpc1xuICAgIG1ha2VzIHN1cmUgYW55IGV4dHJhIGNvbXBvc2l0ZSBibG9jayBtYXJrdXAgKHN1Y2ggYXMgYmxvY2txdW90ZVxuICAgIG1hcmtlcnMpIGluc2lkZSB0aGUgYmxvY2sgYXJlIGFsc28gYWRkZWQgdG8gdGhlIHN5bnRheCB0cmVlLlxuICAgICovXG4gICAgYWRkTGVhZkVsZW1lbnQobGVhZiwgZWx0KSB7XG4gICAgICAgIHRoaXMuYWRkTm9kZSh0aGlzLmJ1ZmZlclxuICAgICAgICAgICAgLndyaXRlRWxlbWVudHMoaW5qZWN0TWFya3MoZWx0LmNoaWxkcmVuLCBsZWFmLm1hcmtzKSwgLWVsdC5mcm9tKVxuICAgICAgICAgICAgLmZpbmlzaChlbHQudHlwZSwgZWx0LnRvIC0gZWx0LmZyb20pLCBlbHQuZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoQ29udGV4dCgpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgdG9wLmFkZENoaWxkKGN4LnRvVHJlZSh0aGlzLnBhcnNlci5ub2RlU2V0KSwgY3guZnJvbSAtIHRvcC5mcm9tKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IHRvcDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDb250ZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEdhcHModGhpcy5ibG9jay50b1RyZWUodGhpcy5wYXJzZXIubm9kZVNldCwgdGhpcy5saW5lU3RhcnQpKTtcbiAgICB9XG4gICAgYWRkR2Fwcyh0cmVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlcy5sZW5ndGggPiAxID9cbiAgICAgICAgICAgIGluamVjdEdhcHModGhpcy5yYW5nZXMsIDAsIHRyZWUudG9wTm9kZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgdGhpcy5yZXVzZVBsYWNlaG9sZGVycykgOiB0cmVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaExlYWYobGVhZikge1xuICAgICAgICBmb3IgKGxldCBwYXJzZXIgb2YgbGVhZi5wYXJzZXJzKVxuICAgICAgICAgICAgaWYgKHBhcnNlci5maW5pc2godGhpcywgbGVhZikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgaW5saW5lID0gaW5qZWN0TWFya3ModGhpcy5wYXJzZXIucGFyc2VJbmxpbmUobGVhZi5jb250ZW50LCBsZWFmLnN0YXJ0KSwgbGVhZi5tYXJrcyk7XG4gICAgICAgIHRoaXMuYWRkTm9kZSh0aGlzLmJ1ZmZlclxuICAgICAgICAgICAgLndyaXRlRWxlbWVudHMoaW5saW5lLCAtbGVhZi5zdGFydClcbiAgICAgICAgICAgIC5maW5pc2goVHlwZS5QYXJhZ3JhcGgsIGxlYWYuY29udGVudC5sZW5ndGgpLCBsZWFmLnN0YXJ0KTtcbiAgICB9XG4gICAgZWx0KHR5cGUsIGZyb20sIHRvLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBlbHQodGhpcy5wYXJzZXIuZ2V0Tm9kZVR5cGUodHlwZSksIGZyb20sIHRvLCBjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUVsZW1lbnQodHlwZSwgZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGJ1ZmZlcigpIHsgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJzZXIubm9kZVNldCk7IH1cbn1cbmZ1bmN0aW9uIGluamVjdEdhcHMocmFuZ2VzLCByYW5nZUksIHRyZWUsIG9mZnNldCwgZHVtbWllcykge1xuICAgIGxldCByYW5nZUVuZCA9IHJhbmdlc1tyYW5nZUldLnRvO1xuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXSwgc3RhcnQgPSB0cmVlLmZyb20gKyBvZmZzZXQ7XG4gICAgZnVuY3Rpb24gbW92ZVBhc3ROZXh0KHVwdG8sIGluY2x1c2l2ZSkge1xuICAgICAgICB3aGlsZSAoaW5jbHVzaXZlID8gdXB0byA+PSByYW5nZUVuZCA6IHVwdG8gPiByYW5nZUVuZCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSByYW5nZXNbcmFuZ2VJICsgMV0uZnJvbSAtIHJhbmdlRW5kO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgICAgICAgICB1cHRvICs9IHNpemU7XG4gICAgICAgICAgICByYW5nZUkrKztcbiAgICAgICAgICAgIHJhbmdlRW5kID0gcmFuZ2VzW3JhbmdlSV0udG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgY2ggPSB0cmVlLmZpcnN0Q2hpbGQ7IGNoOyBjaCA9IGNoLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIG1vdmVQYXN0TmV4dChjaC5mcm9tICsgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgbGV0IGZyb20gPSBjaC5mcm9tICsgb2Zmc2V0LCBub2RlLCByZXVzZSA9IGR1bW1pZXMuZ2V0KGNoLnRyZWUpO1xuICAgICAgICBpZiAocmV1c2UpIHtcbiAgICAgICAgICAgIG5vZGUgPSByZXVzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaC50byArIG9mZnNldCA+IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBub2RlID0gaW5qZWN0R2FwcyhyYW5nZXMsIHJhbmdlSSwgY2gsIG9mZnNldCwgZHVtbWllcyk7XG4gICAgICAgICAgICBtb3ZlUGFzdE5leHQoY2gudG8gKyBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBjaC50b1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gc3RhcnQpO1xuICAgIH1cbiAgICBtb3ZlUGFzdE5leHQodHJlZS50byArIG9mZnNldCwgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgVHJlZSh0cmVlLnR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIHRyZWUudG8gKyBvZmZzZXQgLSBzdGFydCwgdHJlZS50cmVlID8gdHJlZS50cmVlLnByb3BWYWx1ZXMgOiB1bmRlZmluZWQpO1xufVxuLyoqXG5BIE1hcmtkb3duIHBhcnNlciBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hcmtkb3duUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZXIncyBzeW50YXggW25vZGVcbiAgICB0eXBlc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbW9uLk5vZGVTZXQpLlxuICAgICovXG4gICAgbm9kZVNldCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBibG9ja1BhcnNlcnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbGVhZkJsb2NrUGFyc2VycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBibG9ja05hbWVzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZExlYWZCbG9jaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBza2lwQ29udGV4dE1hcmt1cCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbmxpbmVQYXJzZXJzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlubGluZU5hbWVzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdyYXBwZXJzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZVNldCA9IG5vZGVTZXQ7XG4gICAgICAgIHRoaXMuYmxvY2tQYXJzZXJzID0gYmxvY2tQYXJzZXJzO1xuICAgICAgICB0aGlzLmxlYWZCbG9ja1BhcnNlcnMgPSBsZWFmQmxvY2tQYXJzZXJzO1xuICAgICAgICB0aGlzLmJsb2NrTmFtZXMgPSBibG9ja05hbWVzO1xuICAgICAgICB0aGlzLmVuZExlYWZCbG9jayA9IGVuZExlYWZCbG9jaztcbiAgICAgICAgdGhpcy5za2lwQ29udGV4dE1hcmt1cCA9IHNraXBDb250ZXh0TWFya3VwO1xuICAgICAgICB0aGlzLmlubGluZVBhcnNlcnMgPSBpbmxpbmVQYXJzZXJzO1xuICAgICAgICB0aGlzLmlubGluZU5hbWVzID0gaW5saW5lTmFtZXM7XG4gICAgICAgIHRoaXMud3JhcHBlcnMgPSB3cmFwcGVycztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHQgb2Ygbm9kZVNldC50eXBlcylcbiAgICAgICAgICAgIHRoaXMubm9kZVR5cGVzW3QubmFtZV0gPSB0LmlkO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gbmV3IEJsb2NrQ29udGV4dCh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVjb25maWd1cmUgdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShzcGVjKSB7XG4gICAgICAgIGxldCBjb25maWcgPSByZXNvbHZlQ29uZmlnKHNwZWMpO1xuICAgICAgICBpZiAoIWNvbmZpZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgeyBub2RlU2V0LCBza2lwQ29udGV4dE1hcmt1cCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJsb2NrUGFyc2VycyA9IHRoaXMuYmxvY2tQYXJzZXJzLnNsaWNlKCksIGxlYWZCbG9ja1BhcnNlcnMgPSB0aGlzLmxlYWZCbG9ja1BhcnNlcnMuc2xpY2UoKSwgYmxvY2tOYW1lcyA9IHRoaXMuYmxvY2tOYW1lcy5zbGljZSgpLCBpbmxpbmVQYXJzZXJzID0gdGhpcy5pbmxpbmVQYXJzZXJzLnNsaWNlKCksIGlubGluZU5hbWVzID0gdGhpcy5pbmxpbmVOYW1lcy5zbGljZSgpLCBlbmRMZWFmQmxvY2sgPSB0aGlzLmVuZExlYWZCbG9jay5zbGljZSgpLCB3cmFwcGVycyA9IHRoaXMud3JhcHBlcnM7XG4gICAgICAgIGlmIChub25FbXB0eShjb25maWcuZGVmaW5lTm9kZXMpKSB7XG4gICAgICAgICAgICBza2lwQ29udGV4dE1hcmt1cCA9IE9iamVjdC5hc3NpZ24oe30sIHNraXBDb250ZXh0TWFya3VwKTtcbiAgICAgICAgICAgIGxldCBub2RlVHlwZXMgPSBub2RlU2V0LnR5cGVzLnNsaWNlKCksIHN0eWxlcztcbiAgICAgICAgICAgIGZvciAobGV0IHMgb2YgY29uZmlnLmRlZmluZU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbmFtZSwgYmxvY2ssIGNvbXBvc2l0ZSwgc3R5bGUgfSA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyB7IG5hbWU6IHMgfSA6IHM7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlcy5zb21lKHQgPT4gdC5uYW1lID09IG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlKVxuICAgICAgICAgICAgICAgICAgICBza2lwQ29udGV4dE1hcmt1cFtub2RlVHlwZXMubGVuZ3RoXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAoYmwsIGN4LCBsaW5lKSA9PiBjb21wb3NpdGUoY3gsIGxpbmUsIGJsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBub2RlVHlwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBncm91cCA9IGNvbXBvc2l0ZSA/IFtcIkJsb2NrXCIsIFwiQmxvY2tDb250ZXh0XCJdIDogIWJsb2NrID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogaWQgPj0gVHlwZS5BVFhIZWFkaW5nMSAmJiBpZCA8PSBUeXBlLlNldGV4dEhlYWRpbmcyID8gW1wiQmxvY2tcIiwgXCJMZWFmQmxvY2tcIiwgXCJIZWFkaW5nXCJdIDogW1wiQmxvY2tcIiwgXCJMZWFmQmxvY2tcIl07XG4gICAgICAgICAgICAgICAgbm9kZVR5cGVzLnB1c2goTm9kZVR5cGUuZGVmaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBncm91cCAmJiBbW05vZGVQcm9wLmdyb3VwLCBncm91cF1dXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0eWxlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkgfHwgc3R5bGUgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbbmFtZV0gPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZXMsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlU2V0ID0gbmV3IE5vZGVTZXQobm9kZVR5cGVzKTtcbiAgICAgICAgICAgIGlmIChzdHlsZXMpXG4gICAgICAgICAgICAgICAgbm9kZVNldCA9IG5vZGVTZXQuZXh0ZW5kKHN0eWxlVGFncyhzdHlsZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnByb3BzKSlcbiAgICAgICAgICAgIG5vZGVTZXQgPSBub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnJlbW92ZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJtIG9mIGNvbmZpZy5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2sgPSB0aGlzLmJsb2NrTmFtZXMuaW5kZXhPZihybSksIGlubGluZSA9IHRoaXMuaW5saW5lTmFtZXMuaW5kZXhPZihybSk7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUGFyc2Vyc1tibG9ja10gPSBsZWFmQmxvY2tQYXJzZXJzW2Jsb2NrXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaW5saW5lID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVBhcnNlcnNbaW5saW5lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRW1wdHkoY29uZmlnLnBhcnNlQmxvY2spKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIGNvbmZpZy5wYXJzZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gYmxvY2tOYW1lcy5pbmRleE9mKHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tQYXJzZXJzW2ZvdW5kXSA9IHNwZWMucGFyc2U7XG4gICAgICAgICAgICAgICAgICAgIGxlYWZCbG9ja1BhcnNlcnNbZm91bmRdID0gc3BlYy5sZWFmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IHNwZWMuYmVmb3JlID8gZmluZE5hbWUoYmxvY2tOYW1lcywgc3BlYy5iZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNwZWMuYWZ0ZXIgPyBmaW5kTmFtZShibG9ja05hbWVzLCBzcGVjLmFmdGVyKSArIDEgOiBibG9ja05hbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrUGFyc2Vycy5zcGxpY2UocG9zLCAwLCBzcGVjLnBhcnNlKTtcbiAgICAgICAgICAgICAgICAgICAgbGVhZkJsb2NrUGFyc2Vycy5zcGxpY2UocG9zLCAwLCBzcGVjLmxlYWYpO1xuICAgICAgICAgICAgICAgICAgICBibG9ja05hbWVzLnNwbGljZShwb3MsIDAsIHNwZWMubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcGVjLmVuZExlYWYpXG4gICAgICAgICAgICAgICAgICAgIGVuZExlYWZCbG9jay5wdXNoKHNwZWMuZW5kTGVhZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vbkVtcHR5KGNvbmZpZy5wYXJzZUlubGluZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2YgY29uZmlnLnBhcnNlSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gaW5saW5lTmFtZXMuaW5kZXhPZihzcGVjLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZVBhcnNlcnNbZm91bmRdID0gc3BlYy5wYXJzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBzcGVjLmJlZm9yZSA/IGZpbmROYW1lKGlubGluZU5hbWVzLCBzcGVjLmJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3BlYy5hZnRlciA/IGZpbmROYW1lKGlubGluZU5hbWVzLCBzcGVjLmFmdGVyKSArIDEgOiBpbmxpbmVOYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpbmxpbmVQYXJzZXJzLnNwbGljZShwb3MsIDAsIHNwZWMucGFyc2UpO1xuICAgICAgICAgICAgICAgICAgICBpbmxpbmVOYW1lcy5zcGxpY2UocG9zLCAwLCBzcGVjLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICB3cmFwcGVycyA9IHdyYXBwZXJzLmNvbmNhdChjb25maWcud3JhcCk7XG4gICAgICAgIHJldHVybiBuZXcgTWFya2Rvd25QYXJzZXIobm9kZVNldCwgYmxvY2tQYXJzZXJzLCBsZWFmQmxvY2tQYXJzZXJzLCBibG9ja05hbWVzLCBlbmRMZWFmQmxvY2ssIHNraXBDb250ZXh0TWFya3VwLCBpbmxpbmVQYXJzZXJzLCBpbmxpbmVOYW1lcywgd3JhcHBlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldE5vZGVUeXBlKG5hbWUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5ub2RlVHlwZXNbbmFtZV07XG4gICAgICAgIGlmIChmb3VuZCA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVua25vd24gbm9kZSB0eXBlICcke25hbWV9J2ApO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlIHRoZSBnaXZlbiBwaWVjZSBvZiBpbmxpbmUgdGV4dCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LFxuICAgIHJldHVybmluZyBhbiBhcnJheSBvZiBbYEVsZW1lbnRgXSgjRWxlbWVudCkgb2JqZWN0cyByZXByZXNlbnRpbmdcbiAgICB0aGUgaW5saW5lIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwYXJzZUlubGluZSh0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGN4ID0gbmV3IElubGluZUNvbnRleHQodGhpcywgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgb3V0ZXI6IGZvciAobGV0IHBvcyA9IG9mZnNldDsgcG9zIDwgY3guZW5kOykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjeC5jaGFyKHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b2tlbiBvZiB0aGlzLmlubGluZVBhcnNlcnMpXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0b2tlbihjeCwgbmV4dCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjeC5yZXNvbHZlTWFya2VycygwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub25FbXB0eShhKSB7XG4gICAgcmV0dXJuIGEgIT0gbnVsbCAmJiBhLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiByZXNvbHZlQ29uZmlnKHNwZWMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3BlYykpXG4gICAgICAgIHJldHVybiBzcGVjO1xuICAgIGlmIChzcGVjLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgY29uZiA9IHJlc29sdmVDb25maWcoc3BlY1swXSk7XG4gICAgaWYgKHNwZWMubGVuZ3RoID09IDEpXG4gICAgICAgIHJldHVybiBjb25mO1xuICAgIGxldCByZXN0ID0gcmVzb2x2ZUNvbmZpZyhzcGVjLnNsaWNlKDEpKTtcbiAgICBpZiAoIXJlc3QgfHwgIWNvbmYpXG4gICAgICAgIHJldHVybiBjb25mIHx8IHJlc3Q7XG4gICAgbGV0IGNvbmMgPSAoYSwgYikgPT4gKGEgfHwgbm9uZSkuY29uY2F0KGIgfHwgbm9uZSk7XG4gICAgbGV0IHdyYXBBID0gY29uZi53cmFwLCB3cmFwQiA9IHJlc3Qud3JhcDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wczogY29uYyhjb25mLnByb3BzLCByZXN0LnByb3BzKSxcbiAgICAgICAgZGVmaW5lTm9kZXM6IGNvbmMoY29uZi5kZWZpbmVOb2RlcywgcmVzdC5kZWZpbmVOb2RlcyksXG4gICAgICAgIHBhcnNlQmxvY2s6IGNvbmMoY29uZi5wYXJzZUJsb2NrLCByZXN0LnBhcnNlQmxvY2spLFxuICAgICAgICBwYXJzZUlubGluZTogY29uYyhjb25mLnBhcnNlSW5saW5lLCByZXN0LnBhcnNlSW5saW5lKSxcbiAgICAgICAgcmVtb3ZlOiBjb25jKGNvbmYucmVtb3ZlLCByZXN0LnJlbW92ZSksXG4gICAgICAgIHdyYXA6ICF3cmFwQSA/IHdyYXBCIDogIXdyYXBCID8gd3JhcEEgOlxuICAgICAgICAgICAgKGlubmVyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpID0+IHdyYXBBKHdyYXBCKGlubmVyLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmROYW1lKG5hbWVzLCBuYW1lKSB7XG4gICAgbGV0IGZvdW5kID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHVua25vd24gcGFyc2VyICR7bmFtZX1gKTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5sZXQgbm9kZVR5cGVzID0gW05vZGVUeXBlLm5vbmVdO1xuZm9yIChsZXQgaSA9IDEsIG5hbWU7IG5hbWUgPSBUeXBlW2ldOyBpKyspIHtcbiAgICBub2RlVHlwZXNbaV0gPSBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICBpZDogaSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcHJvcHM6IGkgPj0gVHlwZS5Fc2NhcGUgPyBbXSA6IFtbTm9kZVByb3AuZ3JvdXAsIGkgaW4gRGVmYXVsdFNraXBNYXJrdXAgPyBbXCJCbG9ja1wiLCBcIkJsb2NrQ29udGV4dFwiXSA6IFtcIkJsb2NrXCIsIFwiTGVhZkJsb2NrXCJdXV0sXG4gICAgICAgIHRvcDogbmFtZSA9PSBcIkRvY3VtZW50XCJcbiAgICB9KTtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmNsYXNzIEJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3Iobm9kZVNldCkge1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cbiAgICB3cml0ZSh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4gPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5wdXNoKHR5cGUsIGZyb20sIHRvLCA0ICsgY2hpbGRyZW4gKiA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdyaXRlRWxlbWVudHMoZWx0cywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBmb3IgKGxldCBlIG9mIGVsdHMpXG4gICAgICAgICAgICBlLndyaXRlVG8odGhpcywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCh0eXBlLCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFRyZWUuYnVpbGQoe1xuICAgICAgICAgICAgYnVmZmVyOiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBub2RlU2V0OiB0aGlzLm5vZGVTZXQsXG4gICAgICAgICAgICByZXVzZWQ6IHRoaXMubm9kZXMsXG4gICAgICAgICAgICB0b3BJRDogdHlwZSxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbkVsZW1lbnRzIGFyZSB1c2VkIHRvIGNvbXBvc2Ugc3ludGF4IG5vZGVzIGR1cmluZyBwYXJzaW5nLlxuKi9cbmNsYXNzIEVsZW1lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUnc1xuICAgIFtpZF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbW9uLk5vZGVUeXBlLmlkKS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbm9kZSwgYXMgYW4gb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG5vZGUncyBjaGlsZCBub2RlcyBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoaWxkcmVuID0gbm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3cml0ZVRvKGJ1Ziwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzdGFydE9mZiA9IGJ1Zi5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgYnVmLndyaXRlRWxlbWVudHModGhpcy5jaGlsZHJlbiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmLmNvbnRlbnQucHVzaCh0aGlzLnR5cGUsIHRoaXMuZnJvbSArIG9mZnNldCwgdGhpcy50byArIG9mZnNldCwgYnVmLmNvbnRlbnQubGVuZ3RoICsgNCAtIHN0YXJ0T2ZmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1RyZWUobm9kZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihub2RlU2V0KS53cml0ZUVsZW1lbnRzKHRoaXMuY2hpbGRyZW4sIC10aGlzLmZyb20pLmZpbmlzaCh0aGlzLnR5cGUsIHRoaXMudG8gLSB0aGlzLmZyb20pO1xuICAgIH1cbn1cbmNsYXNzIFRyZWVFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlLCBmcm9tKSB7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMudHJlZS5sZW5ndGg7IH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMudHJlZS50eXBlLmlkOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9uZTsgfVxuICAgIHdyaXRlVG8oYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgYnVmLm5vZGVzLnB1c2godGhpcy50cmVlKTtcbiAgICAgICAgYnVmLmNvbnRlbnQucHVzaChidWYubm9kZXMubGVuZ3RoIC0gMSwgdGhpcy5mcm9tICsgb2Zmc2V0LCB0aGlzLnRvICsgb2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMudHJlZTsgfVxufVxuZnVuY3Rpb24gZWx0KHR5cGUsIGZyb20sIHRvLCBjaGlsZHJlbikge1xuICAgIHJldHVybiBuZXcgRWxlbWVudCh0eXBlLCBmcm9tLCB0bywgY2hpbGRyZW4pO1xufVxuY29uc3QgRW1waGFzaXNVbmRlcnNjb3JlID0geyByZXNvbHZlOiBcIkVtcGhhc2lzXCIsIG1hcms6IFwiRW1waGFzaXNNYXJrXCIgfTtcbmNvbnN0IEVtcGhhc2lzQXN0ZXJpc2sgPSB7IHJlc29sdmU6IFwiRW1waGFzaXNcIiwgbWFyazogXCJFbXBoYXNpc01hcmtcIiB9O1xuY29uc3QgTGlua1N0YXJ0ID0ge30sIEltYWdlU3RhcnQgPSB7fTtcbmNsYXNzIElubGluZURlbGltaXRlciB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgZnJvbSwgdG8sIHNpZGUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgIH1cbn1cbmNvbnN0IEVzY2FwYWJsZSA9IFwiIVxcXCIjJCUmJygpKissLS4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIjtcbmxldCBQdW5jdHVhdGlvbiA9IC9bIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AXFxbXFxcXFxcXV5fYHt8fX5cXHhBMVxcdTIwMTAtXFx1MjAyN10vO1xudHJ5IHtcbiAgICBQdW5jdHVhdGlvbiA9IG5ldyBSZWdFeHAoXCJbXFxcXHB7U318XFxcXHB7UH1dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmNvbnN0IERlZmF1bHRJbmxpbmUgPSB7XG4gICAgRXNjYXBlKGN4LCBuZXh0LCBzdGFydCkge1xuICAgICAgICBpZiAobmV4dCAhPSA5MiAvKiAnXFxcXCcgKi8gfHwgc3RhcnQgPT0gY3guZW5kIC0gMSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IGVzY2FwZWQgPSBjeC5jaGFyKHN0YXJ0ICsgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRXNjYXBhYmxlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKEVzY2FwYWJsZS5jaGFyQ29kZUF0KGkpID09IGVzY2FwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5Fc2NhcGUsIHN0YXJ0LCBzdGFydCArIDIpKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG4gICAgRW50aXR5KGN4LCBuZXh0LCBzdGFydCkge1xuICAgICAgICBpZiAobmV4dCAhPSAzOCAvKiAnJicgKi8pXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBtID0gL14oPzojXFxkK3wjeFthLWZcXGRdK3xcXHcrKTsvaS5leGVjKGN4LnNsaWNlKHN0YXJ0ICsgMSwgc3RhcnQgKyAzMSkpO1xuICAgICAgICByZXR1cm4gbSA/IGN4LmFwcGVuZChlbHQoVHlwZS5FbnRpdHksIHN0YXJ0LCBzdGFydCArIDEgKyBtWzBdLmxlbmd0aCkpIDogLTE7XG4gICAgfSxcbiAgICBJbmxpbmVDb2RlKGN4LCBuZXh0LCBzdGFydCkge1xuICAgICAgICBpZiAobmV4dCAhPSA5NiAvKiAnYCcgKi8gfHwgc3RhcnQgJiYgY3guY2hhcihzdGFydCAtIDEpID09IDk2KVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgcG9zID0gc3RhcnQgKyAxO1xuICAgICAgICB3aGlsZSAocG9zIDwgY3guZW5kICYmIGN4LmNoYXIocG9zKSA9PSA5NilcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICBsZXQgc2l6ZSA9IHBvcyAtIHN0YXJ0LCBjdXJTaXplID0gMDtcbiAgICAgICAgZm9yICg7IHBvcyA8IGN4LmVuZDsgcG9zKyspIHtcbiAgICAgICAgICAgIGlmIChjeC5jaGFyKHBvcykgPT0gOTYpIHtcbiAgICAgICAgICAgICAgICBjdXJTaXplKys7XG4gICAgICAgICAgICAgICAgaWYgKGN1clNpemUgPT0gc2l6ZSAmJiBjeC5jaGFyKHBvcyArIDEpICE9IDk2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLklubGluZUNvZGUsIHN0YXJ0LCBwb3MgKyAxLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHQoVHlwZS5Db2RlTWFyaywgc3RhcnQsIHN0YXJ0ICsgc2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHQoVHlwZS5Db2RlTWFyaywgcG9zICsgMSAtIHNpemUsIHBvcyArIDEpXG4gICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1clNpemUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIEhUTUxUYWcoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDYwIC8qICc8JyAqLyB8fCBzdGFydCA9PSBjeC5lbmQgLSAxKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjeC5zbGljZShzdGFydCArIDEsIGN4LmVuZCk7XG4gICAgICAgIGxldCB1cmwgPSAvXig/OlthLXpdWy1cXHcrLl0rOlteXFxzPl0rfFthLXpcXGQuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpcXGRdKD86W2EtelxcZC1dezAsNjF9W2EtelxcZF0pPyg/OlxcLlthLXpcXGRdKD86W2EtelxcZC1dezAsNjF9W2EtelxcZF0pPykqKT4vaS5leGVjKGFmdGVyKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5BdXRvbGluaywgc3RhcnQsIHN0YXJ0ICsgMSArIHVybFswXS5sZW5ndGgsIFtcbiAgICAgICAgICAgICAgICBlbHQoVHlwZS5MaW5rTWFyaywgc3RhcnQsIHN0YXJ0ICsgMSksXG4gICAgICAgICAgICAgICAgLy8gdXJsWzBdIGluY2x1ZGVzIHRoZSBjbG9zaW5nIGJyYWNrZXQsIHNvIGV4Y2x1ZGUgaXQgZnJvbSB0aGlzIHNsaWNlXG4gICAgICAgICAgICAgICAgZWx0KFR5cGUuVVJMLCBzdGFydCArIDEsIHN0YXJ0ICsgdXJsWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgZWx0KFR5cGUuTGlua01hcmssIHN0YXJ0ICsgdXJsWzBdLmxlbmd0aCwgc3RhcnQgKyAxICsgdXJsWzBdLmxlbmd0aClcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tbWVudCA9IC9eIS0tW14+XSg/Oi1bXi1dfFteLV0pKj8tLT4vaS5leGVjKGFmdGVyKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkNvbW1lbnQsIHN0YXJ0LCBzdGFydCArIDEgKyBjb21tZW50WzBdLmxlbmd0aCkpO1xuICAgICAgICBsZXQgcHJvY0luc3QgPSAvXlxcP1teXSo/XFw/Pi8uZXhlYyhhZnRlcik7XG4gICAgICAgIGlmIChwcm9jSW5zdClcbiAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBzdGFydCwgc3RhcnQgKyAxICsgcHJvY0luc3RbMF0ubGVuZ3RoKSk7XG4gICAgICAgIGxldCBtID0gL14oPzohW0EtWl1bXl0qPz58IVxcW0NEQVRBXFxbW15dKj9cXF1cXF0+fFxcL1xccypbYS16QS1aXVtcXHctXSpcXHMqPnxcXHMqW2EtekEtWl1bXFx3LV0qKFxccytbYS16QS1aOl9dW1xcdy0uOl0qKD86XFxzKj1cXHMqKD86W15cXHNcIic9PD5gXSt8J1teJ10qJ3xcIlteXCJdKlwiKSk/KSpcXHMqKFxcL1xccyopPz4pLy5leGVjKGFmdGVyKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gY3guYXBwZW5kKGVsdChUeXBlLkhUTUxUYWcsIHN0YXJ0LCBzdGFydCArIDEgKyBtWzBdLmxlbmd0aCkpO1xuICAgIH0sXG4gICAgRW1waGFzaXMoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDk1ICYmIG5leHQgIT0gNDIpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydCArIDE7XG4gICAgICAgIHdoaWxlIChjeC5jaGFyKHBvcykgPT0gbmV4dClcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICBsZXQgYmVmb3JlID0gY3guc2xpY2Uoc3RhcnQgLSAxLCBzdGFydCksIGFmdGVyID0gY3guc2xpY2UocG9zLCBwb3MgKyAxKTtcbiAgICAgICAgbGV0IHBCZWZvcmUgPSBQdW5jdHVhdGlvbi50ZXN0KGJlZm9yZSksIHBBZnRlciA9IFB1bmN0dWF0aW9uLnRlc3QoYWZ0ZXIpO1xuICAgICAgICBsZXQgc0JlZm9yZSA9IC9cXHN8XiQvLnRlc3QoYmVmb3JlKSwgc0FmdGVyID0gL1xcc3xeJC8udGVzdChhZnRlcik7XG4gICAgICAgIGxldCBsZWZ0RmxhbmtpbmcgPSAhc0FmdGVyICYmICghcEFmdGVyIHx8IHNCZWZvcmUgfHwgcEJlZm9yZSk7XG4gICAgICAgIGxldCByaWdodEZsYW5raW5nID0gIXNCZWZvcmUgJiYgKCFwQmVmb3JlIHx8IHNBZnRlciB8fCBwQWZ0ZXIpO1xuICAgICAgICBsZXQgY2FuT3BlbiA9IGxlZnRGbGFua2luZyAmJiAobmV4dCA9PSA0MiB8fCAhcmlnaHRGbGFua2luZyB8fCBwQmVmb3JlKTtcbiAgICAgICAgbGV0IGNhbkNsb3NlID0gcmlnaHRGbGFua2luZyAmJiAobmV4dCA9PSA0MiB8fCAhbGVmdEZsYW5raW5nIHx8IHBBZnRlcik7XG4gICAgICAgIHJldHVybiBjeC5hcHBlbmQobmV3IElubGluZURlbGltaXRlcihuZXh0ID09IDk1ID8gRW1waGFzaXNVbmRlcnNjb3JlIDogRW1waGFzaXNBc3Rlcmlzaywgc3RhcnQsIHBvcywgKGNhbk9wZW4gPyAxIC8qIE1hcmsuT3BlbiAqLyA6IDAgLyogTWFyay5Ob25lICovKSB8IChjYW5DbG9zZSA/IDIgLyogTWFyay5DbG9zZSAqLyA6IDAgLyogTWFyay5Ob25lICovKSkpO1xuICAgIH0sXG4gICAgSGFyZEJyZWFrKGN4LCBuZXh0LCBzdGFydCkge1xuICAgICAgICBpZiAobmV4dCA9PSA5MiAvKiAnXFxcXCcgKi8gJiYgY3guY2hhcihzdGFydCArIDEpID09IDEwIC8qICdcXG4nICovKVxuICAgICAgICAgICAgcmV0dXJuIGN4LmFwcGVuZChlbHQoVHlwZS5IYXJkQnJlYWssIHN0YXJ0LCBzdGFydCArIDIpKTtcbiAgICAgICAgaWYgKG5leHQgPT0gMzIpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydCArIDE7XG4gICAgICAgICAgICB3aGlsZSAoY3guY2hhcihwb3MpID09IDMyKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgaWYgKGN4LmNoYXIocG9zKSA9PSAxMCAmJiBwb3MgPj0gc3RhcnQgKyAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjeC5hcHBlbmQoZWx0KFR5cGUuSGFyZEJyZWFrLCBzdGFydCwgcG9zICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIExpbmsoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBuZXh0ID09IDkxIC8qICdbJyAqLyA/IGN4LmFwcGVuZChuZXcgSW5saW5lRGVsaW1pdGVyKExpbmtTdGFydCwgc3RhcnQsIHN0YXJ0ICsgMSwgMSAvKiBNYXJrLk9wZW4gKi8pKSA6IC0xO1xuICAgIH0sXG4gICAgSW1hZ2UoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBuZXh0ID09IDMzIC8qICchJyAqLyAmJiBjeC5jaGFyKHN0YXJ0ICsgMSkgPT0gOTEgLyogJ1snICovXG4gICAgICAgICAgICA/IGN4LmFwcGVuZChuZXcgSW5saW5lRGVsaW1pdGVyKEltYWdlU3RhcnQsIHN0YXJ0LCBzdGFydCArIDIsIDEgLyogTWFyay5PcGVuICovKSkgOiAtMTtcbiAgICB9LFxuICAgIExpbmtFbmQoY3gsIG5leHQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXh0ICE9IDkzIC8qICddJyAqLylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgLy8gU2Nhbm5pbmcgYmFjayB0byB0aGUgbmV4dCBsaW5rL2ltYWdlIHN0YXJ0IG1hcmtlclxuICAgICAgICBmb3IgKGxldCBpID0gY3gucGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gY3gucGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiAocGFydC50eXBlID09IExpbmtTdGFydCB8fCBwYXJ0LnR5cGUgPT0gSW1hZ2VTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIG9uZSBoYXMgYmVlbiBzZXQgaW52YWxpZCAoYmVjYXVzZSBpdCB3b3VsZCBwcm9kdWNlXG4gICAgICAgICAgICAgICAgLy8gYSBuZXN0ZWQgbGluaykgb3IgdGhlcmUncyBubyB2YWxpZCBsaW5rIGhlcmUgaWdub3JlIGJvdGguXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0LnNpZGUgfHwgY3guc2tpcFNwYWNlKHBhcnQudG8pID09IHN0YXJ0ICYmICEvWyhcXFtdLy50ZXN0KGN4LnNsaWNlKHN0YXJ0ICsgMSwgc3RhcnQgKyAyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3gucGFydHNbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmlzaCB0aGUgY29udGVudCBhbmQgcmVwbGFjZSB0aGUgZW50aXJlIHJhbmdlIGluXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5wYXJ0cyB3aXRoIHRoZSBsaW5rL2ltYWdlIG5vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBjeC50YWtlQ29udGVudChpKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluayA9IGN4LnBhcnRzW2ldID0gZmluaXNoTGluayhjeCwgY29udGVudCwgcGFydC50eXBlID09IExpbmtTdGFydCA/IFR5cGUuTGluayA6IFR5cGUuSW1hZ2UsIHBhcnQuZnJvbSwgc3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYW55IG9wZW4tbGluayBtYXJrZXJzIGJlZm9yZSB0aGlzIGxpbmsgdG8gaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09IExpbmtTdGFydClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwID0gY3gucGFydHNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiBwLnR5cGUgPT0gTGlua1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuc2lkZSA9IDAgLyogTWFyay5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmsudG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn07XG5mdW5jdGlvbiBmaW5pc2hMaW5rKGN4LCBjb250ZW50LCB0eXBlLCBzdGFydCwgc3RhcnRQb3MpIHtcbiAgICBsZXQgeyB0ZXh0IH0gPSBjeCwgbmV4dCA9IGN4LmNoYXIoc3RhcnRQb3MpLCBlbmRQb3MgPSBzdGFydFBvcztcbiAgICBjb250ZW50LnVuc2hpZnQoZWx0KFR5cGUuTGlua01hcmssIHN0YXJ0LCBzdGFydCArICh0eXBlID09IFR5cGUuSW1hZ2UgPyAyIDogMSkpKTtcbiAgICBjb250ZW50LnB1c2goZWx0KFR5cGUuTGlua01hcmssIHN0YXJ0UG9zIC0gMSwgc3RhcnRQb3MpKTtcbiAgICBpZiAobmV4dCA9PSA0MCAvKiAnKCcgKi8pIHtcbiAgICAgICAgbGV0IHBvcyA9IGN4LnNraXBTcGFjZShzdGFydFBvcyArIDEpO1xuICAgICAgICBsZXQgZGVzdCA9IHBhcnNlVVJMKHRleHQsIHBvcyAtIGN4Lm9mZnNldCwgY3gub2Zmc2V0KSwgdGl0bGU7XG4gICAgICAgIGlmIChkZXN0KSB7XG4gICAgICAgICAgICBwb3MgPSBjeC5za2lwU3BhY2UoZGVzdC50byk7XG4gICAgICAgICAgICAvLyBUaGUgZGVzdGluYXRpb24gYW5kIHRpdGxlIG11c3QgYmUgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGlmIChwb3MgIT0gZGVzdC50bykge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gcGFyc2VMaW5rVGl0bGUodGV4dCwgcG9zIC0gY3gub2Zmc2V0LCBjeC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aXRsZSlcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gY3guc2tpcFNwYWNlKHRpdGxlLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3guY2hhcihwb3MpID09IDQxIC8qICcpJyAqLykge1xuICAgICAgICAgICAgY29udGVudC5wdXNoKGVsdChUeXBlLkxpbmtNYXJrLCBzdGFydFBvcywgc3RhcnRQb3MgKyAxKSk7XG4gICAgICAgICAgICBlbmRQb3MgPSBwb3MgKyAxO1xuICAgICAgICAgICAgaWYgKGRlc3QpXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGRlc3QpO1xuICAgICAgICAgICAgaWYgKHRpdGxlKVxuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh0aXRsZSk7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goZWx0KFR5cGUuTGlua01hcmssIHBvcywgZW5kUG9zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dCA9PSA5MSAvKiAnWycgKi8pIHtcbiAgICAgICAgbGV0IGxhYmVsID0gcGFyc2VMaW5rTGFiZWwodGV4dCwgc3RhcnRQb3MgLSBjeC5vZmZzZXQsIGN4Lm9mZnNldCwgZmFsc2UpO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChsYWJlbCk7XG4gICAgICAgICAgICBlbmRQb3MgPSBsYWJlbC50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWx0KHR5cGUsIHN0YXJ0LCBlbmRQb3MsIGNvbnRlbnQpO1xufVxuLy8gVGhlc2UgcmV0dXJuIGBudWxsYCB3aGVuIGZhbGxpbmcgb2ZmIHRoZSBlbmQgb2YgdGhlIGlucHV0LCBgZmFsc2VgXG4vLyB3aGVuIHBhcnNpbmcgZmFpbHMgb3RoZXJ3aXNlIChmb3IgdXNlIGluIHRoZSBpbmNyZW1lbnRhbCBsaW5rXG4vLyByZWZlcmVuY2UgcGFyc2VyKS5cbmZ1bmN0aW9uIHBhcnNlVVJMKHRleHQsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICBsZXQgbmV4dCA9IHRleHQuY2hhckNvZGVBdChzdGFydCk7XG4gICAgaWYgKG5leHQgPT0gNjAgLyogJzwnICovKSB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN0YXJ0ICsgMTsgcG9zIDwgdGV4dC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgICAgICBsZXQgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PSA2MiAvKiAnPicgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsdChUeXBlLlVSTCwgc3RhcnQgKyBvZmZzZXQsIHBvcyArIDEgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNoID09IDYwIHx8IGNoID09IDEwIC8qICc8XFxuJyAqLylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgZGVwdGggPSAwLCBwb3MgPSBzdGFydDtcbiAgICAgICAgZm9yIChsZXQgZXNjYXBlZCA9IGZhbHNlOyBwb3MgPCB0ZXh0Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IDQwIC8qICcoJyAqLykge1xuICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PSA0MSAvKiAnKScgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTIgLyogJ1xcXFwnICovKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyA+IHN0YXJ0ID8gZWx0KFR5cGUuVVJMLCBzdGFydCArIG9mZnNldCwgcG9zICsgb2Zmc2V0KSA6IHBvcyA9PSB0ZXh0Lmxlbmd0aCA/IG51bGwgOiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUxpbmtUaXRsZSh0ZXh0LCBzdGFydCwgb2Zmc2V0KSB7XG4gICAgbGV0IG5leHQgPSB0ZXh0LmNoYXJDb2RlQXQoc3RhcnQpO1xuICAgIGlmIChuZXh0ICE9IDM5ICYmIG5leHQgIT0gMzQgJiYgbmV4dCAhPSA0MCAvKiAnXCJcXCcoJyAqLylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlbmQgPSBuZXh0ID09IDQwID8gNDEgOiBuZXh0O1xuICAgIGZvciAobGV0IHBvcyA9IHN0YXJ0ICsgMSwgZXNjYXBlZCA9IGZhbHNlOyBwb3MgPCB0ZXh0Lmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgbGV0IGNoID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmIChlc2NhcGVkKVxuICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PSBlbmQpXG4gICAgICAgICAgICByZXR1cm4gZWx0KFR5cGUuTGlua1RpdGxlLCBzdGFydCArIG9mZnNldCwgcG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgIGVsc2UgaWYgKGNoID09IDkyIC8qICdcXFxcJyAqLylcbiAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHRleHQsIHN0YXJ0LCBvZmZzZXQsIHJlcXVpcmVOb25XUykge1xuICAgIGZvciAobGV0IGVzY2FwZWQgPSBmYWxzZSwgcG9zID0gc3RhcnQgKyAxLCBlbmQgPSBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgcG9zICsgOTk5KTsgcG9zIDwgZW5kOyBwb3MrKykge1xuICAgICAgICBsZXQgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKGVzY2FwZWQpXG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKGNoID09IDkzIC8qICddJyAqLylcbiAgICAgICAgICAgIHJldHVybiByZXF1aXJlTm9uV1MgPyBmYWxzZSA6IGVsdChUeXBlLkxpbmtMYWJlbCwgc3RhcnQgKyBvZmZzZXQsIHBvcyArIDEgKyBvZmZzZXQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlTm9uV1MgJiYgIXNwYWNlKGNoKSlcbiAgICAgICAgICAgICAgICByZXF1aXJlTm9uV1MgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjaCA9PSA5MSAvKiAnWycgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5JbmxpbmUgcGFyc2luZyBmdW5jdGlvbnMgZ2V0IGFjY2VzcyB0byB0aGlzIGNvbnRleHQsIGFuZCB1c2UgaXQgdG9cbnJlYWQgdGhlIGNvbnRlbnQgYW5kIGVtaXQgc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIElubGluZUNvbnRleHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBhcnNlciB0aGF0IGlzIGJlaW5nIHVzZWQuXG4gICAgKi9cbiAgICBwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IG9mIHRoaXMgaW5saW5lIHNlY3Rpb24uXG4gICAgKi9cbiAgICB0ZXh0LCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgb2Zmc2V0IG9mIHRoZSBzZWN0aW9uIGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIG9mZnNldCkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoYXJhY3RlciBjb2RlIGF0IHRoZSBnaXZlbiAoZG9jdW1lbnQtcmVsYXRpdmUpXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBjaGFyKHBvcykgeyByZXR1cm4gcG9zID49IHRoaXMuZW5kID8gLTEgOiB0aGlzLnRleHQuY2hhckNvZGVBdChwb3MgLSB0aGlzLm9mZnNldCk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiB0aGlzIGlubGluZSBzZWN0aW9uLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMub2Zmc2V0ICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCBhIHN1YnN0cmluZyBvZiB0aGlzIGlubGluZSBzZWN0aW9uLiBBZ2FpbiB1c2VzXG4gICAgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb25zLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tIC0gdGhpcy5vZmZzZXQsIHRvIC0gdGhpcy5vZmZzZXQpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBlbmQoZWx0KSB7XG4gICAgICAgIHRoaXMucGFydHMucHVzaChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0LnRvO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBbZGVsaW1pdGVyXSgjRGVsaW1pdGVyVHlwZSkgYXQgdGhpcyBnaXZlbiBwb3NpdGlvbi4gYG9wZW5gXG4gICAgYW5kIGBjbG9zZWAgaW5kaWNhdGUgd2hldGhlciB0aGlzIGRlbGltaXRlciBpcyBvcGVuaW5nLCBjbG9zaW5nLFxuICAgIG9yIGJvdGguIFJldHVybnMgdGhlIGVuZCBvZiB0aGUgZGVsaW1pdGVyLCBmb3IgY29udmVuaWVudFxuICAgIHJldHVybmluZyBmcm9tIFtwYXJzZSBmdW5jdGlvbnNdKCNJbmxpbmVQYXJzZXIucGFyc2UpLlxuICAgICovXG4gICAgYWRkRGVsaW1pdGVyKHR5cGUsIGZyb20sIHRvLCBvcGVuLCBjbG9zZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmQobmV3IElubGluZURlbGltaXRlcih0eXBlLCBmcm9tLCB0bywgKG9wZW4gPyAxIC8qIE1hcmsuT3BlbiAqLyA6IDAgLyogTWFyay5Ob25lICovKSB8IChjbG9zZSA/IDIgLyogTWFyay5DbG9zZSAqLyA6IDAgLyogTWFyay5Ob25lICovKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGVyZSBpcyBhbiB1bm1hdGNoZWQgbGluayBvciBpbWFnZSBvcGVuaW5nXG4gICAgdG9rZW4gYmVmb3JlIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IGhhc09wZW5MaW5rKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBJbmxpbmVEZWxpbWl0ZXIgJiYgKHBhcnQudHlwZSA9PSBMaW5rU3RhcnQgfHwgcGFydC50eXBlID09IEltYWdlU3RhcnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFuIGlubGluZSBlbGVtZW50LiBSZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBhZGRFbGVtZW50KGVsdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmQoZWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzb2x2ZSBtYXJrZXJzIGJldHdlZW4gdGhpcy5wYXJ0cy5sZW5ndGggYW5kIGZyb20sIHdyYXBwaW5nIG1hdGNoZWQgbWFya2VycyBpbiB0aGVcbiAgICBhcHByb3ByaWF0ZSBub2RlIGFuZCB1cGRhdGluZyB0aGUgY29udGVudCBvZiB0aGlzLnBhcnRzLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVNYXJrZXJzKGZyb20pIHtcbiAgICAgICAgLy8gU2NhbiBmb3J3YXJkLCBsb29raW5nIGZvciBjbG9zaW5nIHRva2Vuc1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRoaXMucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjbG9zZSA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICBpZiAoIShjbG9zZSBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiBjbG9zZS50eXBlLnJlc29sdmUgJiYgKGNsb3NlLnNpZGUgJiAyIC8qIE1hcmsuQ2xvc2UgKi8pKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBlbXAgPSBjbG9zZS50eXBlID09IEVtcGhhc2lzVW5kZXJzY29yZSB8fCBjbG9zZS50eXBlID09IEVtcGhhc2lzQXN0ZXJpc2s7XG4gICAgICAgICAgICBsZXQgY2xvc2VTaXplID0gY2xvc2UudG8gLSBjbG9zZS5mcm9tO1xuICAgICAgICAgICAgbGV0IG9wZW4sIGogPSBpIC0gMTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHNjYW5uaW5nIGZvciBhIG1hdGNoaW5nIG9wZW5pbmcgdG9rZW5cbiAgICAgICAgICAgIGZvciAoOyBqID49IGZyb207IGotLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gdGhpcy5wYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIElubGluZURlbGltaXRlciAmJiAocGFydC5zaWRlICYgMSAvKiBNYXJrLk9wZW4gKi8pICYmIHBhcnQudHlwZSA9PSBjbG9zZS50eXBlICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlbXBoYXNpcyBkZWxpbWl0ZXJzIHdoZXJlIHRoZSBjaGFyYWN0ZXIgY291bnQgZG9lc24ndCBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAhKGVtcCAmJiAoKGNsb3NlLnNpZGUgJiAxIC8qIE1hcmsuT3BlbiAqLykgfHwgKHBhcnQuc2lkZSAmIDIgLyogTWFyay5DbG9zZSAqLykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydC50byAtIHBhcnQuZnJvbSArIGNsb3NlU2l6ZSkgJSAzID09IDAgJiYgKChwYXJ0LnRvIC0gcGFydC5mcm9tKSAlIDMgfHwgY2xvc2VTaXplICUgMykpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wZW4pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNsb3NlLnR5cGUucmVzb2x2ZSwgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gb3Blbi5mcm9tLCBlbmQgPSBjbG9zZS50bztcbiAgICAgICAgICAgIC8vIEVtcGhhc2lzIG1hcmtlciBlZmZlY3QgZGVwZW5kcyBvbiB0aGUgY2hhcmFjdGVyIGNvdW50LiBTaXplIGNvbnN1bWVkIGlzIG1pbmltdW0gb2YgdGhlIHR3b1xuICAgICAgICAgICAgLy8gbWFya2Vycy5cbiAgICAgICAgICAgIGlmIChlbXApIHtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IE1hdGgubWluKDIsIG9wZW4udG8gLSBvcGVuLmZyb20sIGNsb3NlU2l6ZSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBvcGVuLnRvIC0gc2l6ZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBjbG9zZS5mcm9tICsgc2l6ZTtcbiAgICAgICAgICAgICAgICB0eXBlID0gc2l6ZSA9PSAxID8gXCJFbXBoYXNpc1wiIDogXCJTdHJvbmdFbXBoYXNpc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSB0aGUgY292ZXJlZCByZWdpb24gaW50byBjb250ZW50LCBvcHRpb25hbGx5IGFkZGluZyBtYXJrZXIgbm9kZXNcbiAgICAgICAgICAgIGlmIChvcGVuLnR5cGUubWFyaylcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2godGhpcy5lbHQob3Blbi50eXBlLm1hcmssIHN0YXJ0LCBvcGVuLnRvKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gaiArIDE7IGsgPCBpOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJ0c1trXSBpbnN0YW5jZW9mIEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh0aGlzLnBhcnRzW2tdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRzW2tdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbG9zZS50eXBlLm1hcmspXG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHRoaXMuZWx0KGNsb3NlLnR5cGUubWFyaywgY2xvc2UuZnJvbSwgZW5kKSk7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuZWx0KHR5cGUsIHN0YXJ0LCBlbmQsIGNvbnRlbnQpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGxlZnRvdmVyIGVtcGhhc2lzIG1hcmtlciBjaGFyYWN0ZXJzLCBzaHJpbmsgdGhlIGNsb3NlL29wZW4gbWFya2Vycy4gT3RoZXJ3aXNlLCBjbGVhciB0aGVtLlxuICAgICAgICAgICAgdGhpcy5wYXJ0c1tqXSA9IGVtcCAmJiBvcGVuLmZyb20gIT0gc3RhcnQgPyBuZXcgSW5saW5lRGVsaW1pdGVyKG9wZW4udHlwZSwgb3Blbi5mcm9tLCBzdGFydCwgb3Blbi5zaWRlKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQga2VlcCA9IHRoaXMucGFydHNbaV0gPSBlbXAgJiYgY2xvc2UudG8gIT0gZW5kID8gbmV3IElubGluZURlbGltaXRlcihjbG9zZS50eXBlLCBlbmQsIGNsb3NlLnRvLCBjbG9zZS5zaWRlKSA6IG51bGw7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBlbGVtZW50IGluIHRoaXMucGFydHNcbiAgICAgICAgICAgIGlmIChrZWVwKVxuICAgICAgICAgICAgICAgIHRoaXMucGFydHMuc3BsaWNlKGksIDAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucGFydHNbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbGxlY3QgdGhlIGVsZW1lbnRzIHJlbWFpbmluZyBpbiB0aGlzLnBhcnRzIGludG8gYW4gYXJyYXkuXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0aGlzLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhbiBvcGVuaW5nIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gdHlwZS4gUmV0dXJucyBgbnVsbGAgaWZcbiAgICBubyBkZWxpbWl0ZXIgaXMgZm91bmQsIG9yIGFuIGluZGV4IHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgIFtgdGFrZUNvbnRlbnRgXSgjSW5saW5lQ29udGV4dC50YWtlQ29udGVudCkgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZmluZE9wZW5pbmdEZWxpbWl0ZXIodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBJbmxpbmVEZWxpbWl0ZXIgJiYgcGFydC50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhbGwgaW5saW5lIGVsZW1lbnRzIGFuZCBkZWxpbWl0ZXJzIHN0YXJ0aW5nIGZyb20gdGhlXG4gICAgZ2l2ZW4gaW5kZXggKHdoaWNoIHlvdSBzaG91bGQgZ2V0IGZyb21cbiAgICBbYGZpbmRPcGVuaW5nRGVsaW1pdGVyYF0oI0lubGluZUNvbnRleHQuZmluZE9wZW5pbmdEZWxpbWl0ZXIpLFxuICAgIHJlc29sdmUgZGVsaW1pdGVycyBpbnNpZGUgb2YgdGhlbSwgYW5kIHJldHVybiB0aGVtIGFzIGFuIGFycmF5XG4gICAgb2YgZWxlbWVudHMuXG4gICAgKi9cbiAgICB0YWtlQ29udGVudChzdGFydEluZGV4KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5yZXNvbHZlTWFya2VycyhzdGFydEluZGV4KTtcbiAgICAgICAgdGhpcy5wYXJ0cy5sZW5ndGggPSBzdGFydEluZGV4O1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2tpcCBzcGFjZSBhZnRlciB0aGUgZ2l2ZW4gKGRvY3VtZW50KSBwb3NpdGlvbiwgcmV0dXJuaW5nIGVpdGhlclxuICAgIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCBub24tc3BhY2UgY2hhcmFjdGVyIG9yIHRoZSBlbmQgb2YgdGhlXG4gICAgc2VjdGlvbi5cbiAgICAqL1xuICAgIHNraXBTcGFjZShmcm9tKSB7IHJldHVybiBza2lwU3BhY2UodGhpcy50ZXh0LCBmcm9tIC0gdGhpcy5vZmZzZXQpICsgdGhpcy5vZmZzZXQ7IH1cbiAgICBlbHQodHlwZSwgZnJvbSwgdG8sIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGVsdCh0aGlzLnBhcnNlci5nZXROb2RlVHlwZSh0eXBlKSwgZnJvbSwgdG8sIGNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlRWxlbWVudCh0eXBlLCBmcm9tKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbmplY3RNYXJrcyhlbGVtZW50cywgbWFya3MpIHtcbiAgICBpZiAoIW1hcmtzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIGlmICghZWxlbWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgbGV0IGVsdHMgPSBlbGVtZW50cy5zbGljZSgpLCBlSSA9IDA7XG4gICAgZm9yIChsZXQgbWFyayBvZiBtYXJrcykge1xuICAgICAgICB3aGlsZSAoZUkgPCBlbHRzLmxlbmd0aCAmJiBlbHRzW2VJXS50byA8IG1hcmsudG8pXG4gICAgICAgICAgICBlSSsrO1xuICAgICAgICBpZiAoZUkgPCBlbHRzLmxlbmd0aCAmJiBlbHRzW2VJXS5mcm9tIDwgbWFyay5mcm9tKSB7XG4gICAgICAgICAgICBsZXQgZSA9IGVsdHNbZUldO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFbGVtZW50KVxuICAgICAgICAgICAgICAgIGVsdHNbZUldID0gbmV3IEVsZW1lbnQoZS50eXBlLCBlLmZyb20sIGUudG8sIGluamVjdE1hcmtzKGUuY2hpbGRyZW4sIFttYXJrXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0cy5zcGxpY2UoZUkrKywgMCwgbWFyayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsdHM7XG59XG4vLyBUaGVzZSBhcmUgYmxvY2tzIHRoYXQgY2FuIHNwYW4gYmxhbmsgbGluZXMsIGFuZCBzaG91bGQgdGh1cyBvbmx5IGJlXG4vLyByZXVzZWQgaWYgdGhlaXIgbmV4dCBzaWJsaW5nIGlzIGFsc28gYmVpbmcgcmV1c2VkLlxuY29uc3QgTm90TGFzdCA9IFtUeXBlLkNvZGVCbG9jaywgVHlwZS5MaXN0SXRlbSwgVHlwZS5PcmRlcmVkTGlzdCwgVHlwZS5CdWxsZXRMaXN0XTtcbmNsYXNzIEZyYWdtZW50Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMsIGlucHV0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIC8vIEluZGV4IGludG8gZnJhZ21lbnQgYXJyYXlcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgLy8gQWN0aXZlIGZyYWdtZW50XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdtZW50RW5kID0gLTE7XG4gICAgICAgIC8vIEN1cnNvciBpbnRvIHRoZSBjdXJyZW50IGZyYWdtZW50LCBpZiBhbnkuIFdoZW4gYG1vdmVUb2AgcmV0dXJuc1xuICAgICAgICAvLyB0cnVlLCB0aGlzIHBvaW50cyBhdCB0aGUgZmlyc3QgYmxvY2sgYWZ0ZXIgYHBvc2AuXG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgaWYgKGZyYWdtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICB9XG4gICAgbmV4dEZyYWdtZW50KCkge1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gdGhpcy5pIDwgdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gdGhpcy5mcmFnbWVudHNbdGhpcy5pKytdIDogbnVsbDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmZyYWdtZW50RW5kID0gLTE7XG4gICAgfVxuICAgIG1vdmVUbyhwb3MsIGxpbmVTdGFydCkge1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFnbWVudCAmJiB0aGlzLmZyYWdtZW50LnRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudCB8fCB0aGlzLmZyYWdtZW50LmZyb20gPiAocG9zID8gcG9zIC0gMSA6IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudEVuZCA8IDApIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLmZyYWdtZW50LnRvO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA+IDAgJiYgdGhpcy5pbnB1dC5yZWFkKGVuZCAtIDEsIGVuZCkgIT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICBlbmQtLTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRFbmQgPSBlbmQgPyBlbmQgLSAxIDogMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYyA9IHRoaXMuY3Vyc29yO1xuICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgIGMgPSB0aGlzLmN1cnNvciA9IHRoaXMuZnJhZ21lbnQudHJlZS5jdXJzb3IoKTtcbiAgICAgICAgICAgIGMuZmlyc3RDaGlsZCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByUG9zID0gcG9zICsgdGhpcy5mcmFnbWVudC5vZmZzZXQ7XG4gICAgICAgIHdoaWxlIChjLnRvIDw9IHJQb3MpXG4gICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoYy5mcm9tID49IHJQb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuZnJvbSA8PSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICBpZiAoIWMuY2hpbGRBZnRlcihyUG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hlcyhoYXNoKSB7XG4gICAgICAgIGxldCB0cmVlID0gdGhpcy5jdXJzb3IudHJlZTtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wKE5vZGVQcm9wLmNvbnRleHRIYXNoKSA9PSBoYXNoO1xuICAgIH1cbiAgICB0YWtlTm9kZXMoY3gpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXMuY3Vyc29yLCBvZmYgPSB0aGlzLmZyYWdtZW50Lm9mZnNldCwgZnJhZ0VuZCA9IHRoaXMuZnJhZ21lbnRFbmQgLSAodGhpcy5mcmFnbWVudC5vcGVuRW5kID8gMSA6IDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBjeC5hYnNvbHV0ZUxpbmVTdGFydCwgZW5kID0gc3RhcnQsIGJsb2NrSSA9IGN4LmJsb2NrLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IHByZXZFbmQgPSBlbmQsIHByZXZJID0gYmxvY2tJO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoY3VyLnRvIC0gb2ZmID4gZnJhZ0VuZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIudHlwZS5pc0Fub255bW91cyAmJiBjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb3MgPSB0b1JlbGF0aXZlKGN1ci5mcm9tIC0gb2ZmLCBjeC5yYW5nZXMpO1xuICAgICAgICAgICAgaWYgKGN1ci50byAtIG9mZiA8PSBjeC5yYW5nZXNbY3gucmFuZ2VJXS50bykgeyAvLyBGaXRzIGluIGN1cnJlbnQgcmFuZ2VcbiAgICAgICAgICAgICAgICBjeC5hZGROb2RlKGN1ci50cmVlLCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGR1bW15ID0gbmV3IFRyZWUoY3gucGFyc2VyLm5vZGVTZXQudHlwZXNbVHlwZS5QYXJhZ3JhcGhdLCBbXSwgW10sIDAsIGN4LmJsb2NrLmhhc2hQcm9wKTtcbiAgICAgICAgICAgICAgICBjeC5yZXVzZVBsYWNlaG9sZGVycy5zZXQoZHVtbXksIGN1ci50cmVlKTtcbiAgICAgICAgICAgICAgICBjeC5hZGROb2RlKGR1bW15LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGFrZW4gY29udGVudCBtdXN0IGFsd2F5cyBlbmQgaW4gYSBibG9jaywgYmVjYXVzZSBpbmNyZW1lbnRhbFxuICAgICAgICAgICAgLy8gcGFyc2luZyBoYXBwZW5zIG9uIGJsb2NrIGJvdW5kYXJpZXMuIE5ldmVyIHN0b3AgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFmdGVyIGFuIGluZGVudGVkIGNvZGUgYmxvY2ssIHNpbmNlIHRob3NlIGNhbiBjb250aW51ZSBhZnRlclxuICAgICAgICAgICAgLy8gYW55IG51bWJlciBvZiBibGFuayBsaW5lcy5cbiAgICAgICAgICAgIGlmIChjdXIudHlwZS5pcyhcIkJsb2NrXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE5vdExhc3QuaW5kZXhPZihjdXIudHlwZS5pZCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGN1ci50byAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tJID0gY3guYmxvY2suY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tJID0gcHJldkk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZFbmQgPSBjdXIudG8gLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgIHByZXZJID0gY3guYmxvY2suY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN4LmJsb2NrLmNoaWxkcmVuLmxlbmd0aCA+IGJsb2NrSSkge1xuICAgICAgICAgICAgY3guYmxvY2suY2hpbGRyZW4ucG9wKCk7XG4gICAgICAgICAgICBjeC5ibG9jay5wb3NpdGlvbnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICAgIH1cbn1cbi8vIENvbnZlcnQgYW4gaW5wdXQtc3RyZWFtLXJlbGF0aXZlIHBvc2l0aW9uIHRvIGFcbi8vIE1hcmtkb3duLWRvYy1yZWxhdGl2ZSBwb3NpdGlvbiBieSBzdWJ0cmFjdGluZyB0aGUgc2l6ZSBvZiBhbGwgaW5wdXRcbi8vIGdhcHMgYmVmb3JlIGBhYnNgLlxuZnVuY3Rpb24gdG9SZWxhdGl2ZShhYnMsIHJhbmdlcykge1xuICAgIGxldCBwb3MgPSBhYnM7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGdhcEZyb20gPSByYW5nZXNbaSAtIDFdLnRvLCBnYXBUbyA9IHJhbmdlc1tpXS5mcm9tO1xuICAgICAgICBpZiAoZ2FwRnJvbSA8IGFicylcbiAgICAgICAgICAgIHBvcyAtPSBnYXBUbyAtIGdhcEZyb207XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5jb25zdCBtYXJrZG93bkhpZ2hsaWdodGluZyA9IHN0eWxlVGFncyh7XG4gICAgXCJCbG9ja3F1b3RlLy4uLlwiOiB0YWdzLnF1b3RlLFxuICAgIEhvcml6b250YWxSdWxlOiB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsXG4gICAgXCJBVFhIZWFkaW5nMS8uLi4gU2V0ZXh0SGVhZGluZzEvLi4uXCI6IHRhZ3MuaGVhZGluZzEsXG4gICAgXCJBVFhIZWFkaW5nMi8uLi4gU2V0ZXh0SGVhZGluZzIvLi4uXCI6IHRhZ3MuaGVhZGluZzIsXG4gICAgXCJBVFhIZWFkaW5nMy8uLi5cIjogdGFncy5oZWFkaW5nMyxcbiAgICBcIkFUWEhlYWRpbmc0Ly4uLlwiOiB0YWdzLmhlYWRpbmc0LFxuICAgIFwiQVRYSGVhZGluZzUvLi4uXCI6IHRhZ3MuaGVhZGluZzUsXG4gICAgXCJBVFhIZWFkaW5nNi8uLi5cIjogdGFncy5oZWFkaW5nNixcbiAgICBcIkNvbW1lbnQgQ29tbWVudEJsb2NrXCI6IHRhZ3MuY29tbWVudCxcbiAgICBFc2NhcGU6IHRhZ3MuZXNjYXBlLFxuICAgIEVudGl0eTogdGFncy5jaGFyYWN0ZXIsXG4gICAgXCJFbXBoYXNpcy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICBcIlN0cm9uZ0VtcGhhc2lzLy4uLlwiOiB0YWdzLnN0cm9uZyxcbiAgICBcIkxpbmsvLi4uIEltYWdlLy4uLlwiOiB0YWdzLmxpbmssXG4gICAgXCJPcmRlcmVkTGlzdC8uLi4gQnVsbGV0TGlzdC8uLi5cIjogdGFncy5saXN0LFxuICAgIFwiQmxvY2tRdW90ZS8uLi5cIjogdGFncy5xdW90ZSxcbiAgICBcIklubGluZUNvZGUgQ29kZVRleHRcIjogdGFncy5tb25vc3BhY2UsXG4gICAgXCJVUkwgQXV0b2xpbmtcIjogdGFncy51cmwsXG4gICAgXCJIZWFkZXJNYXJrIEhhcmRCcmVhayBRdW90ZU1hcmsgTGlzdE1hcmsgTGlua01hcmsgRW1waGFzaXNNYXJrIENvZGVNYXJrXCI6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLFxuICAgIFwiQ29kZUluZm8gTGlua0xhYmVsXCI6IHRhZ3MubGFiZWxOYW1lLFxuICAgIExpbmtUaXRsZTogdGFncy5zdHJpbmcsXG4gICAgUGFyYWdyYXBoOiB0YWdzLmNvbnRlbnRcbn0pO1xuLyoqXG5UaGUgZGVmYXVsdCBDb21tb25NYXJrIHBhcnNlci5cbiovXG5jb25zdCBwYXJzZXIgPSBuZXcgTWFya2Rvd25QYXJzZXIobmV3IE5vZGVTZXQobm9kZVR5cGVzKS5leHRlbmQobWFya2Rvd25IaWdobGlnaHRpbmcpLCBPYmplY3Qua2V5cyhEZWZhdWx0QmxvY2tQYXJzZXJzKS5tYXAobiA9PiBEZWZhdWx0QmxvY2tQYXJzZXJzW25dKSwgT2JqZWN0LmtleXMoRGVmYXVsdEJsb2NrUGFyc2VycykubWFwKG4gPT4gRGVmYXVsdExlYWZCbG9ja3Nbbl0pLCBPYmplY3Qua2V5cyhEZWZhdWx0QmxvY2tQYXJzZXJzKSwgRGVmYXVsdEVuZExlYWYsIERlZmF1bHRTa2lwTWFya3VwLCBPYmplY3Qua2V5cyhEZWZhdWx0SW5saW5lKS5tYXAobiA9PiBEZWZhdWx0SW5saW5lW25dKSwgT2JqZWN0LmtleXMoRGVmYXVsdElubGluZSksIFtdKTtcblxuZnVuY3Rpb24gbGVmdE92ZXJTcGFjZShub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gbm9kZS5maXJzdENoaWxkLCBwb3MgPSBmcm9tOzsgbiA9IG4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5leHRQb3MgPSBuID8gbi5mcm9tIDogdG87XG4gICAgICAgIGlmIChuZXh0UG9zID4gcG9zKVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBuZXh0UG9zIH0pO1xuICAgICAgICBpZiAoIW4pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gbi50bztcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8qKlxuQ3JlYXRlIGEgTWFya2Rvd24gZXh0ZW5zaW9uIHRvIGVuYWJsZSBuZXN0ZWQgcGFyc2luZyBvbiBjb2RlXG5ibG9ja3MgYW5kL29yIGVtYmVkZGVkIEhUTUwuXG4qL1xuZnVuY3Rpb24gcGFyc2VDb2RlKGNvbmZpZykge1xuICAgIGxldCB7IGNvZGVQYXJzZXIsIGh0bWxQYXJzZXIgfSA9IGNvbmZpZztcbiAgICBsZXQgd3JhcCA9IHBhcnNlTWl4ZWQoKG5vZGUsIGlucHV0KSA9PiB7XG4gICAgICAgIGxldCBpZCA9IG5vZGUudHlwZS5pZDtcbiAgICAgICAgaWYgKGNvZGVQYXJzZXIgJiYgKGlkID09IFR5cGUuQ29kZUJsb2NrIHx8IGlkID09IFR5cGUuRmVuY2VkQ29kZSkpIHtcbiAgICAgICAgICAgIGxldCBpbmZvID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChpZCA9PSBUeXBlLkZlbmNlZENvZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5mb05vZGUgPSBub2RlLm5vZGUuZ2V0Q2hpbGQoVHlwZS5Db2RlSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm9Ob2RlKVxuICAgICAgICAgICAgICAgICAgICBpbmZvID0gaW5wdXQucmVhZChpbmZvTm9kZS5mcm9tLCBpbmZvTm9kZS50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VyID0gY29kZVBhcnNlcihpbmZvKTtcbiAgICAgICAgICAgIGlmIChwYXJzZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VyLCBvdmVybGF5OiBub2RlID0+IG5vZGUudHlwZS5pZCA9PSBUeXBlLkNvZGVUZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHRtbFBhcnNlciAmJiAoaWQgPT0gVHlwZS5IVE1MQmxvY2sgfHwgaWQgPT0gVHlwZS5IVE1MVGFnIHx8IGlkID09IFR5cGUuQ29tbWVudEJsb2NrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VyOiBodG1sUGFyc2VyLCBvdmVybGF5OiBsZWZ0T3ZlclNwYWNlKG5vZGUubm9kZSwgbm9kZS5mcm9tLCBub2RlLnRvKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHdyYXAgfTtcbn1cblxuY29uc3QgU3RyaWtldGhyb3VnaERlbGltID0geyByZXNvbHZlOiBcIlN0cmlrZXRocm91Z2hcIiwgbWFyazogXCJTdHJpa2V0aHJvdWdoTWFya1wiIH07XG4vKipcbkFuIGV4dGVuc2lvbiB0aGF0IGltcGxlbWVudHNcbltHRk0tc3R5bGVdKGh0dHBzOi8vZ2l0aHViLmdpdGh1Yi5jb20vZ2ZtLyNzdHJpa2V0aHJvdWdoLWV4dGVuc2lvbi0pXG5TdHJpa2V0aHJvdWdoIHN5bnRheCB1c2luZyBgfn5gIGRlbGltaXRlcnMuXG4qL1xuY29uc3QgU3RyaWtldGhyb3VnaCA9IHtcbiAgICBkZWZpbmVOb2RlczogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiU3RyaWtldGhyb3VnaFwiLFxuICAgICAgICAgICAgc3R5bGU6IHsgXCJTdHJpa2V0aHJvdWdoLy4uLlwiOiB0YWdzLnN0cmlrZXRocm91Z2ggfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmlrZXRocm91Z2hNYXJrXCIsXG4gICAgICAgICAgICBzdHlsZTogdGFncy5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cbiAgICAgICAgfV0sXG4gICAgcGFyc2VJbmxpbmU6IFt7XG4gICAgICAgICAgICBuYW1lOiBcIlN0cmlrZXRocm91Z2hcIixcbiAgICAgICAgICAgIHBhcnNlKGN4LCBuZXh0LCBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSAxMjYgLyogJ34nICovIHx8IGN4LmNoYXIocG9zICsgMSkgIT0gMTI2IHx8IGN4LmNoYXIocG9zICsgMikgPT0gMTI2KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IGN4LnNsaWNlKHBvcyAtIDEsIHBvcyksIGFmdGVyID0gY3guc2xpY2UocG9zICsgMiwgcG9zICsgMyk7XG4gICAgICAgICAgICAgICAgbGV0IHNCZWZvcmUgPSAvXFxzfF4kLy50ZXN0KGJlZm9yZSksIHNBZnRlciA9IC9cXHN8XiQvLnRlc3QoYWZ0ZXIpO1xuICAgICAgICAgICAgICAgIGxldCBwQmVmb3JlID0gUHVuY3R1YXRpb24udGVzdChiZWZvcmUpLCBwQWZ0ZXIgPSBQdW5jdHVhdGlvbi50ZXN0KGFmdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3guYWRkRGVsaW1pdGVyKFN0cmlrZXRocm91Z2hEZWxpbSwgcG9zLCBwb3MgKyAyLCAhc0FmdGVyICYmICghcEFmdGVyIHx8IHNCZWZvcmUgfHwgcEJlZm9yZSksICFzQmVmb3JlICYmICghcEJlZm9yZSB8fCBzQWZ0ZXIgfHwgcEFmdGVyKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWZ0ZXI6IFwiRW1waGFzaXNcIlxuICAgICAgICB9XVxufTtcbi8vIFBhcnNlIGEgbGluZSBhcyBhIHRhYmxlIHJvdyBhbmQgcmV0dXJuIHRoZSByb3cgY291bnQuIFdoZW4gYGVsdHNgXG4vLyBpcyBnaXZlbiwgcHVzaCBzeW50YXggZWxlbWVudHMgZm9yIHRoZSBjb250ZW50IG9udG8gaXQuXG5mdW5jdGlvbiBwYXJzZVJvdyhjeCwgbGluZSwgc3RhcnRJID0gMCwgZWx0cywgb2Zmc2V0ID0gMCkge1xuICAgIGxldCBjb3VudCA9IDAsIGZpcnN0ID0gdHJ1ZSwgY2VsbFN0YXJ0ID0gLTEsIGNlbGxFbmQgPSAtMSwgZXNjID0gZmFsc2U7XG4gICAgbGV0IHBhcnNlQ2VsbCA9ICgpID0+IHtcbiAgICAgICAgZWx0cy5wdXNoKGN4LmVsdChcIlRhYmxlQ2VsbFwiLCBvZmZzZXQgKyBjZWxsU3RhcnQsIG9mZnNldCArIGNlbGxFbmQsIGN4LnBhcnNlci5wYXJzZUlubGluZShsaW5lLnNsaWNlKGNlbGxTdGFydCwgY2VsbEVuZCksIG9mZnNldCArIGNlbGxTdGFydCkpKTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSBzdGFydEk7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbGluZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAxMjQgLyogJ3wnICovICYmICFlc2MpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3QgfHwgY2VsbFN0YXJ0ID4gLTEpXG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsU3RhcnQgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgZWx0cy5wdXNoKGN4LmVsdChcIlRhYmxlRGVsaW1pdGVyXCIsIGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsU3RhcnQgPSBjZWxsRW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXNjIHx8IG5leHQgIT0gMzIgJiYgbmV4dCAhPSA5KSB7XG4gICAgICAgICAgICBpZiAoY2VsbFN0YXJ0IDwgMClcbiAgICAgICAgICAgICAgICBjZWxsU3RhcnQgPSBpO1xuICAgICAgICAgICAgY2VsbEVuZCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVzYyA9ICFlc2MgJiYgbmV4dCA9PSA5MjtcbiAgICB9XG4gICAgaWYgKGNlbGxTdGFydCA+IC0xKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChlbHRzKVxuICAgICAgICAgICAgcGFyc2VDZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGhhc1BpcGUoc3RyLCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbmV4dCA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAobmV4dCA9PSAxMjQgLyogJ3wnICovKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChuZXh0ID09IDkyIC8qICdcXFxcJyAqLylcbiAgICAgICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgZGVsaW1pdGVyTGluZSA9IC9eXFx8PyhcXHMqOj8tKzo/XFxzKlxcfCkrKFxccyo6Py0rOj9cXHMqKT8kLztcbmNsYXNzIFRhYmxlUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gTnVsbCBtZWFucyB3ZSBoYXZlbid0IHNlZW4gdGhlIHNlY29uZCBsaW5lIHlldCwgZmFsc2UgbWVhbnMgdGhpc1xuICAgICAgICAvLyBpc24ndCBhIHRhYmxlLCBhbmQgYW4gYXJyYXkgbWVhbnMgdGhpcyBpcyBhIHRhYmxlIGFuZCB3ZSd2ZVxuICAgICAgICAvLyBwYXJzZWQgdGhlIGdpdmVuIHJvd3Mgc28gZmFyLlxuICAgICAgICB0aGlzLnJvd3MgPSBudWxsO1xuICAgIH1cbiAgICBuZXh0TGluZShjeCwgbGluZSwgbGVhZikge1xuICAgICAgICBpZiAodGhpcy5yb3dzID09IG51bGwpIHsgLy8gU2Vjb25kIGxpbmVcbiAgICAgICAgICAgIHRoaXMucm93cyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGxpbmVUZXh0O1xuICAgICAgICAgICAgaWYgKChsaW5lLm5leHQgPT0gNDUgfHwgbGluZS5uZXh0ID09IDU4IHx8IGxpbmUubmV4dCA9PSAxMjQgLyogJy06fCcgKi8pICYmXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyTGluZS50ZXN0KGxpbmVUZXh0ID0gbGluZS50ZXh0LnNsaWNlKGxpbmUucG9zKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RSb3cgPSBbXSwgZmlyc3RDb3VudCA9IHBhcnNlUm93KGN4LCBsZWFmLmNvbnRlbnQsIDAsIGZpcnN0Um93LCBsZWFmLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb3VudCA9PSBwYXJzZVJvdyhjeCwgbGluZVRleHQsIGxpbmUucG9zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dzID0gW2N4LmVsdChcIlRhYmxlSGVhZGVyXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCBmaXJzdFJvdyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjeC5lbHQoXCJUYWJsZURlbGltaXRlclwiLCBjeC5saW5lU3RhcnQgKyBsaW5lLnBvcywgY3gubGluZVN0YXJ0ICsgbGluZS50ZXh0Lmxlbmd0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucm93cykgeyAvLyBMaW5lIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gW107XG4gICAgICAgICAgICBwYXJzZVJvdyhjeCwgbGluZS50ZXh0LCBsaW5lLnBvcywgY29udGVudCwgY3gubGluZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKGN4LmVsdChcIlRhYmxlUm93XCIsIGN4LmxpbmVTdGFydCArIGxpbmUucG9zLCBjeC5saW5lU3RhcnQgKyBsaW5lLnRleHQubGVuZ3RoLCBjb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmaW5pc2goY3gsIGxlYWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvd3MpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN4LmFkZExlYWZFbGVtZW50KGxlYWYsIGN4LmVsdChcIlRhYmxlXCIsIGxlYWYuc3RhcnQsIGxlYWYuc3RhcnQgKyBsZWFmLmNvbnRlbnQubGVuZ3RoLCB0aGlzLnJvd3MpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLyoqXG5UaGlzIGV4dGVuc2lvbiBwcm92aWRlc1xuW0dGTS1zdHlsZV0oaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3RhYmxlcy1leHRlbnNpb24tKVxudGFibGVzLCB1c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG5gYGBcbnwgaGVhZCAxIHwgaGVhZCAyIHxcbnwgLS0tICAgIHwgLS0tICAgIHxcbnwgY2VsbCAxIHwgY2VsbCAyIHxcbmBgYFxuKi9cbmNvbnN0IFRhYmxlID0ge1xuICAgIGRlZmluZU5vZGVzOiBbXG4gICAgICAgIHsgbmFtZTogXCJUYWJsZVwiLCBibG9jazogdHJ1ZSB9LFxuICAgICAgICB7IG5hbWU6IFwiVGFibGVIZWFkZXJcIiwgc3R5bGU6IHsgXCJUYWJsZUhlYWRlci8uLi5cIjogdGFncy5oZWFkaW5nIH0gfSxcbiAgICAgICAgXCJUYWJsZVJvd1wiLFxuICAgICAgICB7IG5hbWU6IFwiVGFibGVDZWxsXCIsIHN0eWxlOiB0YWdzLmNvbnRlbnQgfSxcbiAgICAgICAgeyBuYW1lOiBcIlRhYmxlRGVsaW1pdGVyXCIsIHN0eWxlOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiB9LFxuICAgIF0sXG4gICAgcGFyc2VCbG9jazogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiVGFibGVcIixcbiAgICAgICAgICAgIGxlYWYoXywgbGVhZikgeyByZXR1cm4gaGFzUGlwZShsZWFmLmNvbnRlbnQsIDApID8gbmV3IFRhYmxlUGFyc2VyIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVuZExlYWYoY3gsIGxpbmUsIGxlYWYpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVhZi5wYXJzZXJzLnNvbWUocCA9PiBwIGluc3RhbmNlb2YgVGFibGVQYXJzZXIpIHx8ICFoYXNQaXBlKGxpbmUudGV4dCwgbGluZS5iYXNlUG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3gucGVla0xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsaW1pdGVyTGluZS50ZXN0KG5leHQpICYmIHBhcnNlUm93KGN4LCBsaW5lLnRleHQsIGxpbmUuYmFzZVBvcykgPT0gcGFyc2VSb3coY3gsIG5leHQsIGxpbmUuYmFzZVBvcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmVmb3JlOiBcIlNldGV4dEhlYWRpbmdcIlxuICAgICAgICB9XVxufTtcbmNsYXNzIFRhc2tQYXJzZXIge1xuICAgIG5leHRMaW5lKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmaW5pc2goY3gsIGxlYWYpIHtcbiAgICAgICAgY3guYWRkTGVhZkVsZW1lbnQobGVhZiwgY3guZWx0KFwiVGFza1wiLCBsZWFmLnN0YXJ0LCBsZWFmLnN0YXJ0ICsgbGVhZi5jb250ZW50Lmxlbmd0aCwgW1xuICAgICAgICAgICAgY3guZWx0KFwiVGFza01hcmtlclwiLCBsZWFmLnN0YXJ0LCBsZWFmLnN0YXJ0ICsgMyksXG4gICAgICAgICAgICAuLi5jeC5wYXJzZXIucGFyc2VJbmxpbmUobGVhZi5jb250ZW50LnNsaWNlKDMpLCBsZWFmLnN0YXJ0ICsgMylcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkV4dGVuc2lvbiBwcm92aWRpbmdcbltHRk0tc3R5bGVdKGh0dHBzOi8vZ2l0aHViLmdpdGh1Yi5jb20vZ2ZtLyN0YXNrLWxpc3QtaXRlbXMtZXh0ZW5zaW9uLSlcbnRhc2sgbGlzdCBpdGVtcywgd2hlcmUgbGlzdCBpdGVtcyBjYW4gYmUgcHJlZml4ZWQgd2l0aCBgWyBdYCBvclxuYFt4XWAgdG8gYWRkIGEgY2hlY2tib3guXG4qL1xuY29uc3QgVGFza0xpc3QgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlRhc2tcIiwgYmxvY2s6IHRydWUsIHN0eWxlOiB0YWdzLmxpc3QgfSxcbiAgICAgICAgeyBuYW1lOiBcIlRhc2tNYXJrZXJcIiwgc3R5bGU6IHRhZ3MuYXRvbSB9XG4gICAgXSxcbiAgICBwYXJzZUJsb2NrOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJUYXNrTGlzdFwiLFxuICAgICAgICAgICAgbGVhZihjeCwgbGVhZikge1xuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcW1sgeFhdXFxdWyBcXHRdLy50ZXN0KGxlYWYuY29udGVudCkgJiYgY3gucGFyZW50VHlwZSgpLm5hbWUgPT0gXCJMaXN0SXRlbVwiID8gbmV3IFRhc2tQYXJzZXIgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyOiBcIlNldGV4dEhlYWRpbmdcIlxuICAgICAgICB9XVxufTtcbmNvbnN0IGF1dG9saW5rUkUgPSAvKHd3d1xcLil8KGh0dHBzPzpcXC9cXC8pfChbXFx3ListXXsxLDEwMH1AKXwobWFpbHRvOnx4bXBwOikvZ3k7XG5jb25zdCB1cmxSRSA9IC9bXFx3LV0rKFxcLltcXHctXSspKyhcXC9bXlxcczxdKik/L2d5O1xuY29uc3QgbGFzdFR3b0RvbWFpbldvcmRzID0gL1tcXHctXStcXC5bXFx3LV0rKCR8XFwvKS87XG5jb25zdCBlbWFpbFJFID0gL1tcXHcuKy1dK0BbXFx3LV0rKFxcLltcXHcuLV0rKSsvZ3k7XG5jb25zdCB4bXBwUmVzb3VyY2VSRSA9IC9cXC9bYS16QS1aXFxkQC5dKy9neTtcbmZ1bmN0aW9uIGNvdW50KHN0ciwgZnJvbSwgdG8sIGNoKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgICBpZiAoc3RyW2ldID09IGNoKVxuICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGF1dG9saW5rVVJMRW5kKHRleHQsIGZyb20pIHtcbiAgICB1cmxSRS5sYXN0SW5kZXggPSBmcm9tO1xuICAgIGxldCBtID0gdXJsUkUuZXhlYyh0ZXh0KTtcbiAgICBpZiAoIW0gfHwgbGFzdFR3b0RvbWFpbldvcmRzLmV4ZWMobVswXSlbMF0uaW5kZXhPZihcIl9cIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBlbmQgPSBmcm9tICsgbVswXS5sZW5ndGg7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbGFzdCA9IHRleHRbZW5kIC0gMV0sIG07XG4gICAgICAgIGlmICgvWz8hLiw6Kl9+XS8udGVzdChsYXN0KSB8fFxuICAgICAgICAgICAgbGFzdCA9PSBcIilcIiAmJiBjb3VudCh0ZXh0LCBmcm9tLCBlbmQsIFwiKVwiKSA+IGNvdW50KHRleHQsIGZyb20sIGVuZCwgXCIoXCIpKVxuICAgICAgICAgICAgZW5kLS07XG4gICAgICAgIGVsc2UgaWYgKGxhc3QgPT0gXCI7XCIgJiYgKG0gPSAvJig/OiNcXGQrfCN4W2EtZlxcZF0rfFxcdyspOyQvLmV4ZWModGV4dC5zbGljZShmcm9tLCBlbmQpKSkpXG4gICAgICAgICAgICBlbmQgPSBmcm9tICsgbS5pbmRleDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBhdXRvbGlua0VtYWlsRW5kKHRleHQsIGZyb20pIHtcbiAgICBlbWFpbFJFLmxhc3RJbmRleCA9IGZyb207XG4gICAgbGV0IG0gPSBlbWFpbFJFLmV4ZWModGV4dCk7XG4gICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgbGV0IGxhc3QgPSBtWzBdW21bMF0ubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGxhc3QgPT0gXCJfXCIgfHwgbGFzdCA9PSBcIi1cIiA/IC0xIDogZnJvbSArIG1bMF0ubGVuZ3RoIC0gKGxhc3QgPT0gXCIuXCIgPyAxIDogMCk7XG59XG4vKipcbkV4dGVuc2lvbiB0aGF0IGltcGxlbWVudHMgYXV0b2xpbmtpbmcgZm9yXG5gd3d3LmAvYGh0dHA6Ly9gL2BodHRwczovL2AvYG1haWx0bzpgL2B4bXBwOmAgVVJMcyBhbmQgZW1haWxcbmFkZHJlc3Nlcy5cbiovXG5jb25zdCBBdXRvbGluayA9IHtcbiAgICBwYXJzZUlubGluZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiQXV0b2xpbmtcIixcbiAgICAgICAgICAgIHBhcnNlKGN4LCBuZXh0LCBhYnNQb3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zID0gYWJzUG9zIC0gY3gub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChwb3MgJiYgL1xcdy8udGVzdChjeC50ZXh0W3BvcyAtIDFdKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGF1dG9saW5rUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgICAgICAgICAgIGxldCBtID0gYXV0b2xpbmtSRS5leGVjKGN4LnRleHQpLCBlbmQgPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoIW0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICBpZiAobVsxXSB8fCBtWzJdKSB7IC8vIHd3dy4sIGh0dHA6Ly9cbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYXV0b2xpbmtVUkxFbmQoY3gudGV4dCwgcG9zICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gLTEgJiYgY3guaGFzT3BlbkxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub0JyYWNrZXQgPSAvKFteXFxbXFxdXXxcXFtbXlxcXV0qXFxdKSovLmV4ZWMoY3gudGV4dC5zbGljZShwb3MsIGVuZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gcG9zICsgbm9CcmFja2V0WzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtWzNdKSB7IC8vIGVtYWlsIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gYXV0b2xpbmtFbWFpbEVuZChjeC50ZXh0LCBwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gbWFpbHRvOi94bXBwOlxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBhdXRvbGlua0VtYWlsRW5kKGN4LnRleHQsIHBvcyArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCA+IC0xICYmIG1bMF0gPT0gXCJ4bXBwOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bXBwUmVzb3VyY2VSRS5sYXN0SW5kZXggPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtID0geG1wcFJlc291cmNlUkUuZXhlYyhjeC50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZW5kIDwgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGN4LmFkZEVsZW1lbnQoY3guZWx0KFwiVVJMXCIsIGFic1BvcywgZW5kICsgY3gub2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZCArIGN4Lm9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbn07XG4vKipcbkV4dGVuc2lvbiBidW5kbGUgY29udGFpbmluZyBbYFRhYmxlYF0oI1RhYmxlKSxcbltgVGFza0xpc3RgXSgjVGFza0xpc3QpLCBbYFN0cmlrZXRocm91Z2hgXSgjU3RyaWtldGhyb3VnaCksIGFuZFxuW2BBdXRvbGlua2BdKCNBdXRvbGluaykuXG4qL1xuY29uc3QgR0ZNID0gW1RhYmxlLCBUYXNrTGlzdCwgU3RyaWtldGhyb3VnaCwgQXV0b2xpbmtdO1xuZnVuY3Rpb24gcGFyc2VTdWJTdXBlcihjaCwgbm9kZSwgbWFyaykge1xuICAgIHJldHVybiAoY3gsIG5leHQsIHBvcykgPT4ge1xuICAgICAgICBpZiAobmV4dCAhPSBjaCB8fCBjeC5jaGFyKHBvcyArIDEpID09IGNoKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgZWx0cyA9IFtjeC5lbHQobWFyaywgcG9zLCBwb3MgKyAxKV07XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3MgKyAxOyBpIDwgY3guZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY3guY2hhcihpKTtcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGNoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjeC5hZGRFbGVtZW50KGN4LmVsdChub2RlLCBwb3MsIGkgKyAxLCBlbHRzLmNvbmNhdChjeC5lbHQobWFyaywgaSwgaSArIDEpKSkpO1xuICAgICAgICAgICAgaWYgKG5leHQgPT0gOTIgLyogJ1xcXFwnICovKVxuICAgICAgICAgICAgICAgIGVsdHMucHVzaChjeC5lbHQoXCJFc2NhcGVcIiwgaSwgaSsrICsgMikpO1xuICAgICAgICAgICAgaWYgKHNwYWNlKG5leHQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xufVxuLyoqXG5FeHRlbnNpb24gcHJvdmlkaW5nXG5bUGFuZG9jLXN0eWxlXShodHRwczovL3BhbmRvYy5vcmcvTUFOVUFMLmh0bWwjc3VwZXJzY3JpcHRzLWFuZC1zdWJzY3JpcHRzKVxuc3VwZXJzY3JpcHQgdXNpbmcgYF5gIG1hcmtlcnMuXG4qL1xuY29uc3QgU3VwZXJzY3JpcHQgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlN1cGVyc2NyaXB0XCIsIHN0eWxlOiB0YWdzLnNwZWNpYWwodGFncy5jb250ZW50KSB9LFxuICAgICAgICB7IG5hbWU6IFwiU3VwZXJzY3JpcHRNYXJrXCIsIHN0eWxlOiB0YWdzLnByb2Nlc3NpbmdJbnN0cnVjdGlvbiB9XG4gICAgXSxcbiAgICBwYXJzZUlubGluZTogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiU3VwZXJzY3JpcHRcIixcbiAgICAgICAgICAgIHBhcnNlOiBwYXJzZVN1YlN1cGVyKDk0IC8qICdeJyAqLywgXCJTdXBlcnNjcmlwdFwiLCBcIlN1cGVyc2NyaXB0TWFya1wiKVxuICAgICAgICB9XVxufTtcbi8qKlxuRXh0ZW5zaW9uIHByb3ZpZGluZ1xuW1BhbmRvYy1zdHlsZV0oaHR0cHM6Ly9wYW5kb2Mub3JnL01BTlVBTC5odG1sI3N1cGVyc2NyaXB0cy1hbmQtc3Vic2NyaXB0cylcbnN1YnNjcmlwdCB1c2luZyBgfmAgbWFya2Vycy5cbiovXG5jb25zdCBTdWJzY3JpcHQgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFtcbiAgICAgICAgeyBuYW1lOiBcIlN1YnNjcmlwdFwiLCBzdHlsZTogdGFncy5zcGVjaWFsKHRhZ3MuY29udGVudCkgfSxcbiAgICAgICAgeyBuYW1lOiBcIlN1YnNjcmlwdE1hcmtcIiwgc3R5bGU6IHRhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uIH1cbiAgICBdLFxuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJTdWJzY3JpcHRcIixcbiAgICAgICAgICAgIHBhcnNlOiBwYXJzZVN1YlN1cGVyKDEyNiAvKiAnficgKi8sIFwiU3Vic2NyaXB0XCIsIFwiU3Vic2NyaXB0TWFya1wiKVxuICAgICAgICB9XVxufTtcbi8qKlxuRXh0ZW5zaW9uIHRoYXQgcGFyc2VzIHR3byBjb2xvbnMgd2l0aCBvbmx5IGxldHRlcnMsIHVuZGVyc2NvcmVzLFxuYW5kIG51bWJlcnMgYmV0d2VlbiB0aGVtIGFzIGBFbW9qaWAgbm9kZXMuXG4qL1xuY29uc3QgRW1vamkgPSB7XG4gICAgZGVmaW5lTm9kZXM6IFt7IG5hbWU6IFwiRW1vamlcIiwgc3R5bGU6IHRhZ3MuY2hhcmFjdGVyIH1dLFxuICAgIHBhcnNlSW5saW5lOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJFbW9qaVwiLFxuICAgICAgICAgICAgcGFyc2UoY3gsIG5leHQsIHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSA1OCAvKiAnOicgKi8gfHwgIShtYXRjaCA9IC9eW2EtekEtWl8wLTldKzovLmV4ZWMoY3guc2xpY2UocG9zICsgMSwgY3guZW5kKSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN4LmFkZEVsZW1lbnQoY3guZWx0KFwiRW1vamlcIiwgcG9zLCBwb3MgKyAxICsgbWF0Y2hbMF0ubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG59O1xuXG5leHBvcnQgeyBBdXRvbGluaywgQmxvY2tDb250ZXh0LCBFbGVtZW50LCBFbW9qaSwgR0ZNLCBJbmxpbmVDb250ZXh0LCBMZWFmQmxvY2ssIExpbmUsIE1hcmtkb3duUGFyc2VyLCBTdHJpa2V0aHJvdWdoLCBTdWJzY3JpcHQsIFN1cGVyc2NyaXB0LCBUYWJsZSwgVGFza0xpc3QsIHBhcnNlQ29kZSwgcGFyc2VyIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js\n");

/***/ })

};
;