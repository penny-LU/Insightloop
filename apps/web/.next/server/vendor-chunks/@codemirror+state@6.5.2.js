"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror+state@6.5.2";
exports.ids = ["vendor-chunks/@codemirror+state@6.5.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/* harmony import */ var _marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @marijn/find-cluster-break */ \"(ssr)/../../node_modules/.pnpm/@marijn+find-cluster-break@1.0.2/node_modules/@marijn/find-cluster-break/src/index.js\");\n\n\n/**\nThe data structure for documents. @nonabstract\n*/\nclass Text {\n    /**\n    Get the line description around the given position.\n    */\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);\n        this.decompose(to, this.length, parts, 1 /* Open.From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */\n    slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (let skip = start, pos = start;;) {\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            pos += a.value.length;\n            if (a.done || pos >= end)\n                return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */\n    iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        }\n        else {\n            if (to == null)\n                to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */\n    toString() { return this.sliceString(0); }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */\n    constructor() { }\n    /**\n    Create a `Text` instance for the given array of lines.\n    */\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    scanIdentical() { return 0; }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode))\n            return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]\n            : [this.children.length - 1, other.children.length - 1, -1, -1];\n        for (;; iA += dir, iB += dir) {\n            if (iA == eA || iB == eB)\n                return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB)\n                return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Tree.Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for (;;) {\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0)\n                    this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                }\n                else {\n                    if (dir < 0)\n                        this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, (-this.dir));\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit)\n            skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0)\n            skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0)\n            skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() { return this.cursor.lineBreak && this.value != \"\"; }\n}\nclass LineCursor {\n    constructor(inner) {\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        }\n        else if (done) {\n            this.done = true;\n            this.value = \"\";\n        }\n        else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            }\n            else {\n                this.afterBreak = true;\n                this.next();\n            }\n        }\n        else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() { return false; }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =\n        LineCursor.prototype[Symbol.iterator] = function () { return this; };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/\nclass Line {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position of the start of the line.\n    */\n    from, \n    /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */\n    to, \n    /**\n    This line's line number (1-based).\n    */\n    number, \n    /**\n    The line's content.\n    */\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */\n    get length() { return this.to - this.from; }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [from, Math.max(from, Math.min(text.length, to))];\n}\n\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\nfunction findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (0,_marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(str, pos, forward, includeExtending);\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up in a JavaScript string.\n*/\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\nvar MapMode = /*@__PURE__*/(function (MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */\n    MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */\n    MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */\n    MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\nreturn MapMode})(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\nclass ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    sections) {\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */\n    get length() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2)\n            result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */\n    get newLength() {\n        let result = 0;\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */\n    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */\n    iterGaps(f) {\n        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            }\n            else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */\n    iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */\n    get invertedDesc() {\n        let sections = [];\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0)\n                sections.push(len, ins);\n            else\n                sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */\n    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `this` happened before the ones in `other`.\n    */\n    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos)\n                    return posB + (pos - posA);\n                posB += len;\n            }\n            else {\n                if (mode != MapMode.Simple && endA >= pos &&\n                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||\n                        mode == MapMode.TrackBefore && posA < pos ||\n                        mode == MapMode.TrackAfter && endA > pos))\n                    return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len)\n                    return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA)\n            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */\n    touchesRange(from, to = from) {\n        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from)\n                return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let result = \"\";\n        for (let i = 0; i < this.sections.length;) {\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */\n    toJSON() { return this.sections; }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != \"number\"))\n            throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */\n    static create(sections) { return new ChangeDesc(sections); }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\nclass ChangeSet extends ChangeDesc {\n    constructor(sections, \n    /**\n    @internal\n    */\n    inserted) {\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */\n    apply(doc) {\n        if (this.length != doc.length)\n            throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) { return mapSet(this, other, before, true); }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */\n    invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for (let i = 0, pos = 0; i < sections.length; i += 2) {\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while (inserted.length < index)\n                    inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */\n    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */\n    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */\n    iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */\n    get desc() { return ChangeDesc.create(this.sections); }\n    /**\n    @internal\n    */\n    filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for (let i = 0, pos = 0;;) {\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while (pos < next || pos == next && iter.len == 0) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0)\n                    addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while (pos < end) {\n                if (iter.done)\n                    break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return { changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections) };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */\n    toJSON() {\n        let parts = [];\n        for (let i = 0; i < this.sections.length; i += 2) {\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0)\n                parts.push(len);\n            else if (ins == 0)\n                parts.push([len]);\n            else\n                parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */\n    static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length)\n                return;\n            if (pos < length)\n                addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)\n                    process(sub);\n            }\n            else if (spec instanceof ChangeSet) {\n                if (spec.length != length)\n                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            }\n            else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length)\n                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0)\n                    return;\n                if (from < pos)\n                    flush();\n                if (from > pos)\n                    addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */\n    static empty(length) {\n        return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */\n    static fromJSON(json) {\n        if (!Array.isArray(json))\n            throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for (let i = 0; i < json.length; i++) {\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            }\n            else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i) => i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            }\n            else if (part.length == 1) {\n                sections.push(part[0], 0);\n            }\n            else {\n                while (inserted.length < i)\n                    inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */\n    static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0)\n        return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1])\n        sections[last] += len;\n    else if (last >= 0 && len == 0 && sections[last] == 0)\n        sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    }\n    else\n        sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0)\n        return;\n    let index = (sections.length - 2) >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    }\n    else {\n        while (values.length < index)\n            values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        }\n        else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for (;;) {\n                endA += len;\n                endB += ins;\n                if (ins && inserted)\n                    text = text.append(inserted[(i - 2) >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)\n                    break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for (let inserted = -1;;) {\n        if (a.done && b.len || b.done && a.len) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        }\n        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while (len) {\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert)\n                        addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        }\n        else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while (left) {\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                }\n                else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                }\n                else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i)\n                addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        }\n        else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for (let open = false;;) {\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        }\n        else if (a.ins == 0) { // Deletion in A\n            addSection(sections, a.len, 0, open);\n            a.next();\n        }\n        else if (b.len == 0 && !b.done) { // Insertion in B\n            addSection(sections, 0, b.ins, open);\n            if (insert)\n                addInsert(insert, sections, b.text);\n            b.next();\n        }\n        else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n        else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB)\n                    addInsert(insert, sections, b.text);\n            }\n            else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert)\n                    addInsert(insert, sections, a.textBit(len));\n            }\n            else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off)\n                    addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set) {\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        }\n        else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() { return this.ins == -2; }\n    get len2() { return this.ins < 0 ? this.len : this.ins; }\n    get text() {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = (this.i - 2) >> 1;\n        return index >= inserted.length && !len ? Text.empty\n            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len)\n            this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1)\n            this.forward(len);\n        else if (len == this.ins)\n            this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\nclass SelectionRange {\n    constructor(\n    /**\n    The lower boundary of the range.\n    */\n    from, \n    /**\n    The upper boundary of the range.\n    */\n    to, flags) {\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */\n    get anchor() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from; }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */\n    get head() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to; }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */\n    get empty() { return this.from == this.to; }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */\n    get assoc() { return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */\n    get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */\n    get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */\n    map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        }\n        else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */\n    extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor)\n            return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */\n    eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head &&\n            (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */\n    toJSON() { return { anchor: this.anchor, head: this.head }; }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */\n    static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */\n    static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/\nclass EditorSelection {\n    constructor(\n    /**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */\n    ranges, \n    /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */\n    mainIndex) {\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */\n    map(change, assoc = -1) {\n        if (change.empty)\n            return this;\n        return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */\n    eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length ||\n            this.mainIndex != other.mainIndex)\n            return false;\n        for (let i = 0; i < this.ranges.length; i++)\n            if (!this.ranges[i].eq(other.ranges[i], includeAssoc))\n                return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */\n    get main() { return this.ranges[this.mainIndex]; }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */\n    asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */\n    addRange(range, main = true) {\n        return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */\n    replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */\n    toJSON() {\n        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */\n    static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length)\n            throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */\n    static single(anchor, head = anchor) {\n        return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */\n    static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0)\n            throw new RangeError(\"A selection needs at least one range\");\n        for (let pos = 0, i = 0; i < ranges.length; i++) {\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos)\n                return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */\n    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |\n            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |\n            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */));\n    }\n    /**\n    Create a selection range.\n    */\n    static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */) |\n            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)\n            : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);\n    }\n    /**\n    @internal\n    */\n    static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b) => a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for (let i = 1; i < ranges.length; i++) {\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex)\n                    mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)\n        if (range.to > docLength)\n            throw new RangeError(\"Selection points outside of document\");\n}\n\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/\nclass Facet {\n    constructor(\n    /**\n    @internal\n    */\n    combine, \n    /**\n    @internal\n    */\n    compareInput, \n    /**\n    @internal\n    */\n    compare, isStatic, enables) {\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */\n        this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */\n    get reader() { return this; }\n    /**\n    Define a new facet.\n    */\n    static define(config = {}) {\n        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */\n    of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */, value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */\n    compute(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */\n    computeN(deps, get) {\n        if (this.isStatic)\n            throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);\n    }\n    from(field, get) {\n        if (!get)\n            get = x => x;\n        return this.compute([field], state => get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value) {\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies) {\n            if (dep == \"doc\")\n                depDoc = true;\n            else if (dep == \"selection\")\n                depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)\n                depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create(state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update(state, tr) {\n                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState) => {\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every(dep => {\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :\n                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                }\n                else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!compare(a[i], b[i]))\n            return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)\n        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)\n            changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map(p => addresses[p.id]);\n    let providerTypes = providers.map(p => p.type);\n    let dynamic = providerAddrs.filter(p => !(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for (let i = 0; i < providerAddrs.length; i++) {\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */)\n                for (let val of value)\n                    values.push(val);\n            else\n                values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create(state) {\n            for (let addr of providerAddrs)\n                ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */;\n        },\n        update(state, tr) {\n            if (!ensureAll(state, dynamic))\n                return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx]))\n                return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        },\n        reconfigure(state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */;\n        }\n    };\n}\nconst initField = /*@__PURE__*/Facet.define({ static: true });\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\nclass StateField {\n    constructor(\n    /**\n    @internal\n    */\n    id, createF, updateF, compareF, \n    /**\n    @internal\n    */\n    spec) {\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */\n        this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */\n    static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);\n        if (config.provide)\n            field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find(i => i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */\n    slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state) => {\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            },\n            update: (state, tr) => {\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value))\n                    return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */;\n            },\n            reconfigure: (state, oldState) => {\n                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;\n                if ((reInit = init.find(i => i.field == this)) && reInit != oldInit.find(i => i.field == this)) {\n                    state.values[idx] = reInit.create(state);\n                    return 1 /* SlotStatus.Changed */;\n                }\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */\n    init(create) {\n        return [this, initField.of({ field: this, create })];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */\n    get extension() { return this; }\n}\nconst Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };\nfunction prec(value) {\n    return (ext) => new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\nconst Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */\n    highest: /*@__PURE__*/prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */\n    high: /*@__PURE__*/prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */\n    default: /*@__PURE__*/prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */\n    low: /*@__PURE__*/prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */\n    lowest: /*@__PURE__*/prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec) {\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\nclass Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */\n    of(ext) { return new CompartmentInstance(this, ext); }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */\n    reconfigure(content) {\n        return Compartment.reconfigure.of({ compartment: this, extension: content });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */\n    get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner) {\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while (this.statusTemplate.length < dynamicSlots.length)\n            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)) {\n            if (ext instanceof StateField)\n                fields.push(ext);\n            else\n                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields) {\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push(a => field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for (let id in facets) {\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every(p => p.type == 0 /* Provider.Static */)) {\n                address[facet.id] = (staticValues.length << 1) | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                }\n                else {\n                    let value = facet.combine(providers.map(p => p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            }\n            else {\n                for (let p of providers) {\n                    if (p.type == 0 /* Provider.Static */) {\n                        address[p.id] = (staticValues.length << 1) | 1;\n                        staticValues.push(p.value);\n                    }\n                    else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push(a => p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map(f => f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [[], [], [], [], []];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec)\n                return;\n            let found = result[known].indexOf(ext);\n            if (found > -1)\n                result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance)\n                newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)\n                inner(e, prec);\n        }\n        else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment))\n                throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        }\n        else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        }\n        else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides)\n                inner(ext.provides, prec);\n        }\n        else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions)\n                inner(ext.facet.extensions, Prec_.default);\n        }\n        else {\n            let content = ext.extension;\n            if (!content)\n                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b) => a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1)\n        return 2 /* SlotStatus.Computed */;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */)\n        throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */)\n        return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nconst languageData = /*@__PURE__*/Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/Facet.define({\n    combine: values => values.some(v => v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/Facet.define();\nconst transactionFilter = /*@__PURE__*/Facet.define();\nconst transactionExtender = /*@__PURE__*/Facet.define();\nconst readOnly = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : false\n});\n\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\nclass Annotation {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The annotation type.\n    */\n    type, \n    /**\n    The value of this annotation.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */\n    static define() { return new AnnotationType(); }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\nclass AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */\n    of(value) { return new Annotation(this, value); }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\nclass StateEffectType {\n    /**\n    @internal\n    */\n    constructor(\n    // The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */\n    map) {\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */\n    of(value) { return new StateEffect(this, value); }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\nclass StateEffect {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    type, \n    /**\n    The value of this effect.\n    */\n    value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */\n    map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */\n    is(type) { return this.type == type; }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */\n    static define(spec = {}) {\n        return new StateEffectType(spec.map || (v => v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */\n    static mapEffects(effects, mapping) {\n        if (!effects.length)\n            return effects;\n        let result = [];\n        for (let effect of effects) {\n            let mapped = effect.map(mapping);\n            if (mapped)\n                result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/\nclass Transaction {\n    constructor(\n    /**\n    The state from which the transaction starts.\n    */\n    startState, \n    /**\n    The document changes made by this transaction.\n    */\n    changes, \n    /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */\n    selection, \n    /**\n    The effects added to the transaction.\n    */\n    effects, \n    /**\n    @internal\n    */\n    annotations, \n    /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */\n    scrollIntoView) {\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */\n        this._doc = null;\n        /**\n        @internal\n        */\n        this._state = null;\n        if (selection)\n            checkSelection(selection, changes.newLength);\n        if (!annotations.some((a) => a.type == Transaction.time))\n            this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */\n    static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */\n    get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */\n    get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */\n    get state() {\n        if (!this._state)\n            this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */\n    annotation(type) {\n        for (let ann of this.annotations)\n            if (ann.type == type)\n                return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */\n    get docChanged() { return !this.changes.empty; }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */\n    get reconfigured() { return this.startState.config != this.state.config; }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */\n    isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\nTransaction.remote = /*@__PURE__*/Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for (let iA = 0, iB = 0;;) {\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        }\n        else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        }\n        else\n            return result;\n        if (!result.length || result[result.length - 1] < from)\n            result.push(from, to);\n        else if (result[result.length - 1] < to)\n            result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    }\n    else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent)\n        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes\n            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false)\n        filter = false;\n    for (let i = 1; i < specs.length; i++) {\n        if (specs[i].filter === false)\n            filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)) {\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value))\n            result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        }\n        else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for (let i = filters.length - 1; i >= 0; i--) {\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction)\n            tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)\n            tr = filtered[0];\n        else\n            tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for (let i = extenders.length - 1; i >= 0; i--) {\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length)\n            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [value];\n}\n\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\nvar CharCategory = /*@__PURE__*/(function (CharCategory) {\n    /**\n    Word characters.\n    */\n    CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */\n    CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */\n    CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\nreturn CharCategory})(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n}\ncatch (_) { }\nfunction hasWordChar(str) {\n    if (wordChar)\n        return wordChar.test(str);\n    for (let i = 0; i < str.length; i++) {\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))\n            return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char) => {\n        if (!/\\S/.test(char))\n            return CharCategory.Space;\n        if (hasWordChar(char))\n            return CharCategory.Word;\n        for (let i = 0; i < wordChars.length; i++)\n            if (char.indexOf(wordChars[i]) > -1)\n                return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\nclass EditorState {\n    constructor(\n    /**\n    @internal\n    */\n    config, \n    /**\n    The current document.\n    */\n    doc, \n    /**\n    The current selection.\n    */\n    selection, \n    /**\n    @internal\n    */\n    values, computeSlot, tr) {\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr)\n            tr._state = this;\n        for (let i = 0; i < this.config.dynamicSlots.length; i++)\n            ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require)\n                throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */\n    update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */\n    applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects) {\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key) => compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            }\n            else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            }\n            else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        }\n        else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */\n    replaceSelection(text) {\n        if (typeof text == \"string\")\n            text = this.toText(text);\n        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },\n            range: EditorSelection.cursor(range.from + text.length) }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */\n    changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [result1.range];\n        let effects = asArray(result1.effects);\n        for (let i = 1; i < sel.ranges.length; i++) {\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for (let j = 0; j < i; j++)\n                ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */\n    changes(spec = []) {\n        if (spec instanceof ChangeSet)\n            return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */\n    toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */\n    sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */\n    facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null)\n            return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */\n    toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields)\n            for (let prop in fields) {\n                let value = fields[prop];\n                if (value instanceof StateField && this.config.address[value.id] != null)\n                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n            }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */\n    static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\")\n            throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields)\n            for (let prop in fields) {\n                if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                    let field = fields[prop], value = json[prop];\n                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));\n                }\n            }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */\n    static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc\n            : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0)\n            : config.selection instanceof EditorSelection ? config.selection\n                : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections))\n            selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */\n    get tabSize() { return this.facet(EditorState.tabSize); }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */\n    get lineBreak() { return this.facet(EditorState.lineSeparator) || \"\\n\"; }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */\n    get readOnly() { return this.facet(readOnly); }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */\n    phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))\n            if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n                phrase = map[phrase];\n                break;\n            }\n        if (insert.length)\n            phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i) => {\n                if (i == \"$\")\n                    return \"$\";\n                let n = +(i || 1);\n                return !n || n > insert.length ? m : insert[n - 1];\n            });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */\n    languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)) {\n            for (let result of provider(this, pos, side)) {\n                if (Object.prototype.hasOwnProperty.call(result, name))\n                    values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */\n    charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */\n    wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while (start > 0) {\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word)\n                break;\n            start = prev;\n        }\n        while (end < length) {\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word)\n                break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n    combine: values => values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\nEditorState.phrases = /*@__PURE__*/Facet.define({\n    compare(a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every(k => a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\nfunction combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that\ncombine = {}) {\n    let result = {};\n    for (let config of configs)\n        for (let key of Object.keys(config)) {\n            let value = config[key], current = result[key];\n            if (current === undefined)\n                result[key] = value;\n            else if (current === value || value === undefined) ; // No conflict\n            else if (Object.hasOwnProperty.call(combine, key))\n                result[key] = combine[key](current, value);\n            else\n                throw new Error(\"Config merge conflict for field \" + key);\n        }\n    for (let key in defaults)\n        if (result[key] === undefined)\n            result[key] = defaults[key];\n    return result;\n}\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */\n    range(from, to = from) { return Range.create(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */\n    static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add = add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.empty || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* C.Far */ - 1;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1\n                    : cursor.point.startSide < 0 ? active.length\n                        : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */\n    static join(sets) {\n        if (!sets.length)\n            return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for (let i = sets.length - 2; i >= 0; i--) {\n            for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)\n                result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/\nclass RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */;\n        this.lastTo = -1000000000 /* C.Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* C.ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||\n            this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)\n                this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let dEnd = (a.to + dPos) - b.to, diff = dEnd || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange)\n            comparator.boundChange(end);\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\nfunction countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for (let i = 0; i < to && i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\nfunction findColumn(string, col, tabSize, strict) {\n    for (let i = 0, n = 0;;) {\n        if (n >= col)\n            return i;\n        if (i == string.length)\n            break;\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bjb2RlbWlycm9yK3N0YXRlQDYuNS4yL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUssd0JBQXdCLFlBQVk7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsR0FBRyxLQUFLLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4QkFBOEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0RUFBa0I7QUFDN0I7QUFDQSw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUssMENBQTBDLEtBQUs7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQ0FBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVksYUFBYSxPQUFPO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBLGlFQUFpRSxNQUFNLEtBQUssSUFBSSxvQkFBb0IsT0FBTztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVDQUF1QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsSUFBSTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVcsSUFBSSxPQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLDhDQUE4QztBQUN2RyxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLE9BQU87QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQ0FBMEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QyxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUNBQWlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa1giLCJzb3VyY2VzIjpbIkQ6XFzlrbjmoKFcXHByb2plY3RcXHN0YWNrXFxpbnNpZ2h0bG9vcFxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQGNvZGVtaXJyb3Irc3RhdGVANi41LjJcXG5vZGVfbW9kdWxlc1xcQGNvZGVtaXJyb3JcXHN0YXRlXFxkaXN0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kQ2x1c3RlckJyZWFrIGFzIGZpbmRDbHVzdGVyQnJlYWskMSB9IGZyb20gJ0BtYXJpam4vZmluZC1jbHVzdGVyLWJyZWFrJztcblxuLyoqXG5UaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRvY3VtZW50cy4gQG5vbmFic3RyYWN0XG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBsaW5lIGRlc2NyaXB0aW9uIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBsaW5lQXQocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPCAwIHx8IHBvcyA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtwb3N9IGluIGRvY3VtZW50IG9mIGxlbmd0aCAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIocG9zLCBmYWxzZSwgMSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZGVzY3JpcHRpb24gZm9yIHRoZSBnaXZlbiAoMS1iYXNlZCkgbGluZSBudW1iZXIuXG4gICAgKi9cbiAgICBsaW5lKG4pIHtcbiAgICAgICAgaWYgKG4gPCAxIHx8IG4gPiB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgbGluZSBudW1iZXIgJHtufSBpbiAke3RoaXMubGluZXN9LWxpbmUgZG9jdW1lbnRgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKG4sIHRydWUsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIHRleHQgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UoMCwgZnJvbSwgcGFydHMsIDIgLyogT3Blbi5UbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8gfCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSh0bywgdGhpcy5sZW5ndGgsIHBhcnRzLCAxIC8qIE9wZW4uRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKGZyb20sIHRvLCBwYXJ0cywgMCk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0byAtIGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyB0ZXh0IGlzIGVxdWFsIHRvIGFub3RoZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob3RoZXIubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IG90aGVyLmxpbmVzICE9IHRoaXMubGluZXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgMSksIGVuZCA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKG90aGVyLCAtMSk7XG4gICAgICAgIGxldCBhID0gbmV3IFJhd1RleHRDdXJzb3IodGhpcyksIGIgPSBuZXcgUmF3VGV4dEN1cnNvcihvdGhlcik7XG4gICAgICAgIGZvciAobGV0IHNraXAgPSBzdGFydCwgcG9zID0gc3RhcnQ7Oykge1xuICAgICAgICAgICAgYS5uZXh0KHNraXApO1xuICAgICAgICAgICAgYi5uZXh0KHNraXApO1xuICAgICAgICAgICAgc2tpcCA9IDA7XG4gICAgICAgICAgICBpZiAoYS5saW5lQnJlYWsgIT0gYi5saW5lQnJlYWsgfHwgYS5kb25lICE9IGIuZG9uZSB8fCBhLnZhbHVlICE9IGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcG9zICs9IGEudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSB8fCBwb3MgPj0gZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICAgIGZyb20gZW5kIHRvIHN0YXJ0LiBUaGlzIHdpbGwgcmV0dXJuIGxpbmVzIGFuZCB0aGUgYnJlYWtzIGJldHdlZW5cbiAgICB0aGVtIGFzIHNlcGFyYXRlIHN0cmluZ3MuXG4gICAgKi9cbiAgICBpdGVyKGRpciA9IDEpIHsgcmV0dXJuIG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMsIGRpcik7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiB0aGUgdGV4dC4gV2hlbiBgZnJvbWAgPiBgdG9gLCB0aGVcbiAgICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAgICovXG4gICAgaXRlclJhbmdlKGZyb20sIHRvID0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIG5ldyBQYXJ0aWFsVGV4dEN1cnNvcih0aGlzLCBmcm9tLCB0byk7IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBjdXJzb3IgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiByYW5nZSBvZiBsaW5lcyxcbiAgICBfd2l0aG91dF8gcmV0dXJuaW5nIHRoZSBsaW5lIGJyZWFrcyBiZXR3ZWVuLCBhbmQgeWllbGRpbmcgZW1wdHlcbiAgICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgICBcbiAgICBXaGVuIGBmcm9tYCBhbmQgYHRvYCBhcmUgZ2l2ZW4sIHRoZXkgc2hvdWxkIGJlIDEtYmFzZWQgbGluZSBudW1iZXJzLlxuICAgICovXG4gICAgaXRlckxpbmVzKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBpbm5lcjtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5uZXIgPSB0aGlzLml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRvID0gdGhpcy5saW5lcyArIDE7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmxpbmUoZnJvbSkuZnJvbTtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyUmFuZ2Uoc3RhcnQsIE1hdGgubWF4KHN0YXJ0LCB0byA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogdG8gPD0gMSA/IDAgOiB0aGlzLmxpbmUodG8gLSAxKS50bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUN1cnNvcihpbm5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcsIHVzaW5nIG5ld2xpbmUgY2hhcmFjdGVycyB0b1xuICAgIHNlcGFyYXRlIGxpbmVzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKDApOyB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICAgIGRlc2VyaWFsaXplZCBhZ2FpbiB2aWEgW2BUZXh0Lm9mYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgVGV4dGAgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBsaW5lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBvZih0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEgJiYgIXRleHRbMF0pXG4gICAgICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogT3Blbi5Gcm9tICovKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRhcmdldC5wb3AoKTtcbiAgICAgICAgICAgIGxldCBqb2luZWQgPSBhcHBlbmRUZXh0KHRleHQudGV4dCwgcHJldi50ZXh0LnNsaWNlKCksIDAsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChqb2luZWQubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZCwgcHJldi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1pZCA9IGpvaW5lZC5sZW5ndGggPj4gMTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKDAsIG1pZCkpLCBuZXcgVGV4dExlYWYoam9pbmVkLnNsaWNlKG1pZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgaWYgKCEodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihsaW5lcywgbmV3TGVuKTtcbiAgICAgICAgcmV0dXJuIFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQobGluZXMsIFtdKSwgbmV3TGVuKTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMudGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmUuc2xpY2UoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0aGlzLnRleHQpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbCgpIHsgcmV0dXJuIDA7IH1cbiAgICBzdGF0aWMgc3BsaXQodGV4dCwgdGFyZ2V0KSB7XG4gICAgICAgIGxldCBwYXJ0ID0gW10sIGxlbiA9IC0xO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpIHtcbiAgICAgICAgICAgIHBhcnQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGxlbiArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT0gMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBPcGVuLkZyb20gKi8gOiAwKSB8IChlbmQgPj0gdG8gPyAyIC8qIE9wZW4uVG8gKi8gOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIGVuZCA8PSB0byAmJiAhY2hpbGRPcGVuKVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWNvbXBvc2UoZnJvbSAtIHBvcywgdG8gLSBwb3MsIHRhcmdldCwgY2hpbGRPcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8gLSAxKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQubGluZXMgPiAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShjb3B5LCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHBvcywgZW5kLCB1cGRhdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgIH1cbiAgICBzbGljZVN0cmluZyhmcm9tLCB0byA9IHRoaXMubGVuZ3RoLCBsaW5lU2VwID0gXCJcXG5cIikge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogVHJlZS5CcmFuY2ggKi8pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5mbGF0dGVuKGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVhZihmbGF0LCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaHVuayA9IE1hdGgubWF4KDMyIC8qIFRyZWUuQnJhbmNoICovLCBsaW5lcyA+PiA1IC8qIFRyZWUuQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdID0gbmV3IFRleHRMZWFmKGxhc3QudGV4dC5jb25jYXQoY2hpbGQudGV4dCksIGxhc3QubGVuZ3RoICsgMSArIGNoaWxkLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExpbmVzICsgY2hpbGQubGluZXMgPiBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgICAgICAgICAgICAgY3VycmVudExlbiArPSBjaGlsZC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TGluZXMgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjaHVua2VkLnB1c2goY3VycmVudENodW5rLmxlbmd0aCA9PSAxID8gY3VycmVudENodW5rWzBdIDogVGV4dE5vZGUuZnJvbShjdXJyZW50Q2h1bmssIGN1cnJlbnRMZW4pKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW4gPSAtMTtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lcyA9IGN1cnJlbnRDaHVuay5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgYWRkKGNoaWxkKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNodW5rZWQubGVuZ3RoID09IDEgPyBjaHVua2VkWzBdIDogbmV3IFRleHROb2RlKGNodW5rZWQsIGxlbmd0aCk7XG4gICAgfVxufVxuVGV4dC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgVGV4dExlYWYoW1wiXCJdLCAwKTtcbmZ1bmN0aW9uIHRleHRMZW5ndGgodGV4dCkge1xuICAgIGxldCBsZW5ndGggPSAtMTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHRleHQpXG4gICAgICAgIGxlbmd0aCArPSBsaW5lLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFwcGVuZFRleHQodGV4dCwgdGFyZ2V0LCBmcm9tID0gMCwgdG8gPSAxZTkpIHtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMCwgZmlyc3QgPSB0cnVlOyBpIDwgdGV4dC5sZW5ndGggJiYgcG9zIDw9IHRvOyBpKyspIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA+PSBmcm9tKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20pXG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoZnJvbSAtIHBvcyk7XG4gICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdGFyZ2V0Lmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc2xpY2VUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGFwcGVuZFRleHQodGV4dCwgW1wiXCJdLCBmcm9tLCB0byk7XG59XG5jbGFzcyBSYXdUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBkaXIgPSAxKSB7XG4gICAgICAgIHRoaXMuZGlyID0gZGlyO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdGV4dF07XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IFtkaXIgPiAwID8gMSA6ICh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyB0ZXh0LnRleHQubGVuZ3RoIDogdGV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDFdO1xuICAgIH1cbiAgICBuZXh0SW5uZXIoc2tpcCwgZGlyKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMubm9kZXNbbGFzdF0sIG9mZnNldFZhbHVlID0gdGhpcy5vZmZzZXRzW2xhc3RdLCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSA+PiAxO1xuICAgICAgICAgICAgbGV0IHNpemUgPSB0b3AgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IHRvcC50ZXh0Lmxlbmd0aCA6IHRvcC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IChkaXIgPiAwID8gc2l6ZSA6IDApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdCAtIDFdKys7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob2Zmc2V0VmFsdWUgJiAxKSA9PSAoZGlyID4gMCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9wIGluc3RhbmNlb2YgVGV4dExlYWYpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLnRleHRbb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA+IE1hdGgubWF4KDAsIHNraXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBza2lwID09IDAgPyBuZXh0IDogZGlyID4gMCA/IG5leHQuc2xpY2Uoc2tpcCkgOiBuZXh0LnNsaWNlKDAsIG5leHQubGVuZ3RoIC0gc2tpcCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0b3AuY2hpbGRyZW5bb2Zmc2V0ICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcCA+IG5leHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAgLT0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XSArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0c1tsYXN0XS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKGRpciA+IDAgPyAxIDogKG5leHQgaW5zdGFuY2VvZiBUZXh0TGVhZiA/IG5leHQudGV4dC5sZW5ndGggOiBuZXh0LmNoaWxkcmVuLmxlbmd0aCkgPDwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRJbm5lcigtc2tpcCwgKC10aGlzLmRpcikpO1xuICAgICAgICAgICAgc2tpcCA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmRpcik7XG4gICAgfVxufVxuY2xhc3MgUGFydGlhbFRleHRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRleHQsIHN0YXJ0ID4gZW5kID8gLTEgOiAxKTtcbiAgICAgICAgdGhpcy5wb3MgPSBzdGFydCA+IGVuZCA/IHRleHQubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5mcm9tID0gTWF0aC5taW4oc3RhcnQsIGVuZCk7XG4gICAgICAgIHRoaXMudG8gPSBNYXRoLm1heChzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHRoaXMucG9zIDw9IHRoaXMuZnJvbSA6IHRoaXMucG9zID49IHRoaXMudG8pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHNraXAgKz0gTWF0aC5tYXgoMCwgZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgbGV0IGxpbWl0ID0gZGlyIDwgMCA/IHRoaXMucG9zIC0gdGhpcy5mcm9tIDogdGhpcy50byAtIHRoaXMucG9zO1xuICAgICAgICBpZiAoc2tpcCA+IGxpbWl0KVxuICAgICAgICAgICAgc2tpcCA9IGxpbWl0O1xuICAgICAgICBsaW1pdCAtPSBza2lwO1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gdGhpcy5jdXJzb3IubmV4dChza2lwKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gKHZhbHVlLmxlbmd0aCArIHNraXApICogZGlyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUubGVuZ3RoIDw9IGxpbWl0ID8gdmFsdWUgOiBkaXIgPCAwID8gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gbGltaXQpIDogdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICB0aGlzLmRvbmUgPSAhdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgaWYgKHNraXAgPCAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWF4KHNraXAsIHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICAgICAgZWxzZSBpZiAoc2tpcCA+IDApXG4gICAgICAgICAgICBza2lwID0gTWF0aC5taW4oc2tpcCwgdGhpcy50byAtIHRoaXMucG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dElubmVyKHNraXAsIHRoaXMuY3Vyc29yLmRpcik7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiB0aGlzLmN1cnNvci5saW5lQnJlYWsgJiYgdGhpcy52YWx1ZSAhPSBcIlwiOyB9XG59XG5jbGFzcyBMaW5lQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcikge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgbmV4dChza2lwID0gMCkge1xuICAgICAgICBsZXQgeyBkb25lLCBsaW5lQnJlYWssIHZhbHVlIH0gPSB0aGlzLmlubmVyLm5leHQoc2tpcCk7XG4gICAgICAgIGlmIChkb25lICYmIHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hZnRlckJyZWFrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBsaW5lQnJlYWsoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFRleHQucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLml0ZXIoKTsgfTtcbiAgICBSYXdUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gUGFydGlhbFRleHRDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBMaW5lQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbi8qKlxuVGhpcyB0eXBlIGRlc2NyaWJlcyBhIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBJdCBpcyBjcmVhdGVkXG5vbi1kZW1hbmQgd2hlbiBsaW5lcyBhcmUgW3F1ZXJpZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dC5saW5lQXQpLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcbiAgICBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGlzIGxpbmUncyBsaW5lIG51bWJlciAoMS1iYXNlZCkuXG4gICAgKi9cbiAgICBudW1iZXIsIFxuICAgIC8qKlxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cbiAgICAqL1xuICAgIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTsgfVxufVxuZnVuY3Rpb24gY2xpcCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZyb20gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0ZXh0Lmxlbmd0aCwgZnJvbSkpO1xuICAgIHJldHVybiBbZnJvbSwgTWF0aC5tYXgoZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHRvKSldO1xufVxuXG4vKipcblJldHVybnMgYSBuZXh0IGdyYXBoZW1lIGNsdXN0ZXIgYnJlYWsgX2FmdGVyXyAobm90IGVxdWFsIHRvKVxuYHBvc2AsIGlmIGBmb3J3YXJkYCBpcyB0cnVlLCBvciBiZWZvcmUgb3RoZXJ3aXNlLiBSZXR1cm5zIGBwb3NgXG5pdHNlbGYgaWYgbm8gZnVydGhlciBjbHVzdGVyIGJyZWFrIGlzIGF2YWlsYWJsZSBpbiB0aGUgc3RyaW5nLlxuTW92ZXMgYWNyb3NzIHN1cnJvZ2F0ZSBwYWlycywgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgKHdoZW5cbmBpbmNsdWRlRXh0ZW5kaW5nYCBpcyB0cnVlKSwgY2hhcmFjdGVycyBqb2luZWQgd2l0aCB6ZXJvLXdpZHRoXG5qb2luZXJzLCBhbmQgZmxhZyBlbW9qaS5cbiovXG5mdW5jdGlvbiBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgcG9zLCBmb3J3YXJkID0gdHJ1ZSwgaW5jbHVkZUV4dGVuZGluZyA9IHRydWUpIHtcbiAgICByZXR1cm4gZmluZENsdXN0ZXJCcmVhayQxKHN0ciwgcG9zLCBmb3J3YXJkLCBpbmNsdWRlRXh0ZW5kaW5nKTtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgYW1vdW50IG9mIHBvc2l0aW9ucyBhIGNoYXJhY3RlciB0YWtlcyB1cCBpbiBhIEphdmFTY3JpcHQgc3RyaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludFNpemUoY29kZSkgeyByZXR1cm4gY29kZSA8IDB4MTAwMDAgPyAxIDogMjsgfVxuXG5jb25zdCBEZWZhdWx0U3BsaXQgPSAvXFxyXFxuP3xcXG4vO1xuLyoqXG5EaXN0aW5ndWlzaGVzIGRpZmZlcmVudCB3YXlzIGluIHdoaWNoIHBvc2l0aW9ucyBjYW4gYmUgbWFwcGVkLlxuKi9cbnZhciBNYXBNb2RlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoTWFwTW9kZSkge1xuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRvIGEgdmFsaWQgbmV3IHBvc2l0aW9uLCBldmVuIHdoZW4gaXRzIGNvbnRleHRcbiAgICB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlNpbXBsZVwiXSA9IDBdID0gXCJTaW1wbGVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiBkZWxldGlvbiBoYXBwZW5zIGFjcm9zcyB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0RlbFwiXSA9IDFdID0gXCJUcmFja0RlbFwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2JlZm9yZV8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0JlZm9yZVwiXSA9IDJdID0gXCJUcmFja0JlZm9yZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIHRoZSBjaGFyYWN0ZXIgX2FmdGVyXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQWZ0ZXJcIl0gPSAzXSA9IFwiVHJhY2tBZnRlclwiO1xucmV0dXJuIE1hcE1vZGV9KShNYXBNb2RlIHx8IChNYXBNb2RlID0ge30pKTtcbi8qKlxuQSBjaGFuZ2UgZGVzY3JpcHRpb24gaXMgYSB2YXJpYW50IG9mIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldClcbnRoYXQgZG9lc24ndCBzdG9yZSB0aGUgaW5zZXJ0ZWQgdGV4dC4gQXMgc3VjaCwgaXQgY2FuJ3QgYmVcbmFwcGxpZWQsIGJ1dCBpcyBjaGVhcGVyIHRvIHN0b3JlIGFuZCBtYW5pcHVsYXRlLlxuKi9cbmNsYXNzIENoYW5nZURlc2Mge1xuICAgIC8vIFNlY3Rpb25zIGFyZSBlbmNvZGVkIGFzIHBhaXJzIG9mIGludGVnZXJzLiBUaGUgZmlyc3QgaXMgdGhlXG4gICAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgICAvLyB1bmFmZmVjdGVkIHNlY3Rpb25zLCBhbmQgdGhlIGxlbmd0aCBvZiB0aGUgcmVwbGFjZW1lbnQgY29udGVudFxuICAgIC8vIG90aGVyd2lzZS4gU28gYW4gaW5zZXJ0aW9uIHdvdWxkIGJlICgwLCBuPjApLCBhIGRlbGV0aW9uIChuPjAsXG4gICAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZWN0aW9ucykge1xuICAgICAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnNlY3Rpb25zW2ldO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBhZnRlciB0aGUgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGlucyA8IDAgPyB0aGlzLnNlY3Rpb25zW2ldIDogaW5zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEZhbHNlIHdoZW4gdGhlcmUgYXJlIGFjdHVhbCBjaGFuZ2VzIGluIHRoaXMgc2V0LlxuICAgICovXG4gICAgZ2V0IGVtcHR5KCkgeyByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB1bmNoYW5nZWQgcGFydHMgbGVmdCBieSB0aGVzZSBjaGFuZ2VzLiBgcG9zQWBcbiAgICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICAgIHRoZSBuZXcgcG9zaXRpb24gaW4gdGhlIGNoYW5nZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBgZnJvbUFgL2B0b0FgIHByb3ZpZGVzIHRoZSBleHRlbnQgb2YgdGhlIGNoYW5nZSBpbiB0aGUgc3RhcnRpbmdcbiAgICBkb2N1bWVudCwgYGZyb21CYC9gdG9CYCB0aGUgZXh0ZW50IG9mIHRoZSByZXBsYWNlbWVudCBpbiB0aGVcbiAgICBjaGFuZ2VkIGRvY3VtZW50LlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgKHdoaWNoIGFyZSBrZXB0XG4gICAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gICAgcmVwb3J0ZWQgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VkUmFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGludmVydGVkIGZvcm0gb2YgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIGdldCBpbnZlcnRlZERlc2MoKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpbnMsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcHV0ZSB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFwcGx5aW5nIGFub3RoZXIgc2V0IG9mIGNoYW5nZXNcbiAgICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gICAgbWF0Y2ggdGhlIGxlbmd0aCBiZWZvcmUgYG90aGVyYC5cbiAgICAqL1xuICAgIGNvbXBvc2VEZXNjKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlcik7IH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgICBhcyBgb3RoZXJgLCBvdmVyIGFub3RoZXIgc2V0IG9mIGNoYW5nZXMsIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgYXBwbGllZCBhZnRlciBpdC4gV2hlbiBgYmVmb3JlYCBpcyB0cnVlLCBtYXAgYXMgaWYgdGhlIGNoYW5nZXNcbiAgICBpbiBgdGhpc2AgaGFwcGVuZWQgYmVmb3JlIHRoZSBvbmVzIGluIGBvdGhlcmAuXG4gICAgKi9cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUpOyB9XG4gICAgbWFwUG9zKHBvcywgYXNzb2MgPSAtMSwgbW9kZSA9IE1hcE1vZGUuU2ltcGxlKSB7XG4gICAgICAgIGxldCBwb3NBID0gMCwgcG9zQiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK10sIGVuZEEgPSBwb3NBICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc0IgKyAocG9zIC0gcG9zQSk7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPSBNYXBNb2RlLlNpbXBsZSAmJiBlbmRBID49IHBvcyAmJlxuICAgICAgICAgICAgICAgICAgICAobW9kZSA9PSBNYXBNb2RlLlRyYWNrRGVsICYmIHBvc0EgPCBwb3MgJiYgZW5kQSA+IHBvcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9PSBNYXBNb2RlLlRyYWNrQmVmb3JlICYmIHBvc0EgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0FmdGVyICYmIGVuZEEgPiBwb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZW5kQSA+IHBvcyB8fCBlbmRBID09IHBvcyAmJiBhc3NvYyA8IDAgJiYgIWxlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcyA9PSBwb3NBIHx8IGFzc29jIDwgMCA/IHBvc0IgOiBwb3NCICsgaW5zO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+IHBvc0EpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IGlzIG91dCBvZiByYW5nZSBmb3IgY2hhbmdlc2V0IG9mIGxlbmd0aCAke3Bvc0F9YCk7XG4gICAgICAgIHJldHVybiBwb3NCO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gICAgY2hhbmdlcyBlbnRpcmVseSBjb3ZlcnMgdGhlIHJhbmdlLCB0aGUgc3RyaW5nIGBcImNvdmVyXCJgIGlzXG4gICAgcmV0dXJuZWQuXG4gICAgKi9cbiAgICB0b3VjaGVzUmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmQgPSBwb3MgKyBsZW47XG4gICAgICAgICAgICBpZiAoaW5zID49IDAgJiYgcG9zIDw9IHRvICYmIGVuZCA+PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPCBmcm9tICYmIGVuZCA+IHRvID8gXCJjb3ZlclwiIDogdHJ1ZTtcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IChyZXN1bHQgPyBcIiBcIiA6IFwiXCIpICsgbGVuICsgKGlucyA+PSAwID8gXCI6XCIgKyBpbnMgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2UgZGVzYyB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2UgZGVzYyBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZFxuICAgIGJ5IFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikgfHwganNvbi5sZW5ndGggJSAyIHx8IGpzb24uc29tZShhID0+IHR5cGVvZiBhICE9IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlRGVzY1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoc2VjdGlvbnMpIHsgcmV0dXJuIG5ldyBDaGFuZ2VEZXNjKHNlY3Rpb25zKTsgfVxufVxuLyoqXG5BIGNoYW5nZSBzZXQgcmVwcmVzZW50cyBhIGdyb3VwIG9mIG1vZGlmaWNhdGlvbnMgdG8gYSBkb2N1bWVudC4gSXRcbnN0b3JlcyB0aGUgZG9jdW1lbnQgbGVuZ3RoLCBhbmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBkb2N1bWVudHNcbndpdGggZXhhY3RseSB0aGF0IGxlbmd0aC5cbiovXG5jbGFzcyBDaGFuZ2VTZXQgZXh0ZW5kcyBDaGFuZ2VEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN0aW9ucywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRlZCkge1xuICAgICAgICBzdXBlcihzZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0ZWQgPSBpbnNlcnRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICAgIGRvY3VtZW50LlxuICAgICovXG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPSBkb2MubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBcHBseWluZyBjaGFuZ2Ugc2V0IHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgd3JvbmcgbGVuZ3RoXCIpO1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCAoZnJvbUEsIHRvQSwgZnJvbUIsIF90b0IsIHRleHQpID0+IGRvYyA9IGRvYy5yZXBsYWNlKGZyb21CLCBmcm9tQiArICh0b0EgLSBmcm9tQSksIHRleHQpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgfVxuICAgIG1hcERlc2Mob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgICBjaGFuZ2Ugc2V0IHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBvZiB0aGlzIHNldCwgd2hpY2ggY291bGRcbiAgICBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgdGhlIGNoYW5nZXMgYmFjayB0b1xuICAgIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgICAqL1xuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gdGhpcy5zZWN0aW9ucy5zbGljZSgpLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gc2VjdGlvbnNbaV0sIGlucyA9IHNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2ldID0gaW5zO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zW2kgKyAxXSA9IGxlbjtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBpID4+IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2gobGVuID8gZG9jLnNsaWNlKHBvcywgcG9zICsgbGVuKSA6IFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21iaW5lIHR3byBzdWJzZXF1ZW50IGNoYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LiBgb3RoZXJgXG4gICAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICAgIGBkb2NBYCDihpIgYGRvY0JgIGFuZCBgb3RoZXJgIHJlcHJlc2VudHMgYGRvY0JgIOKGkiBgZG9jQ2AsIHRoZVxuICAgIHJldHVybmVkIHZhbHVlIHdpbGwgcmVwcmVzZW50IHRoZSBjaGFuZ2UgYGRvY0FgIOKGkiBgZG9jQ2AuXG4gICAgKi9cbiAgICBjb21wb3NlKG90aGVyKSB7IHJldHVybiB0aGlzLmVtcHR5ID8gb3RoZXIgOiBvdGhlci5lbXB0eSA/IHRoaXMgOiBjb21wb3NlU2V0cyh0aGlzLCBvdGhlciwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBHaXZlbiBhbm90aGVyIGNoYW5nZSBzZXQgc3RhcnRpbmcgaW4gdGhlIHNhbWUgZG9jdW1lbnQsIG1hcHMgdGhpc1xuICAgIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gICAgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYXBwbHlpbmcgYG90aGVyYC4gV2hlblxuICAgIGBiZWZvcmVgIGlzIGB0cnVlYCwgb3JkZXIgY2hhbmdlcyBhcyBpZiBgdGhpc2AgY29tZXMgYmVmb3JlXG4gICAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gICAgXG4gICAgR2l2ZW4gdHdvIGNoYW5nZXMgYEFgIGFuZCBgQmAsIGBBLmNvbXBvc2UoQi5tYXAoQSkpYCBhbmRcbiAgICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gICAgcHJvdmlkZXMgYSBiYXNpYyBmb3JtIG9mIFtvcGVyYXRpb25hbFxuICAgIHRyYW5zZm9ybWF0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRpb25hbF90cmFuc2Zvcm1hdGlvbiksXG4gICAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICAgKi9cbiAgICBtYXAob3RoZXIsIGJlZm9yZSA9IGZhbHNlKSB7IHJldHVybiBvdGhlci5lbXB0eSA/IHRoaXMgOiBtYXBTZXQodGhpcywgb3RoZXIsIGJlZm9yZSwgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGNoYW5nZWQgcmFuZ2VzIGluIHRoZSBkb2N1bWVudCwgY2FsbGluZyBgZmAgZm9yXG4gICAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICAgIGFuZCB0aGUgcmFuZ2UgdGhhdCByZXBsYWNlcyBpdCBpbiB0aGUgbmV3IGRvY3VtZW50XG4gICAgKGBmcm9tQmAtYHRvQmApLlxuICAgIFxuICAgIFdoZW4gYGluZGl2aWR1YWxgIGlzIHRydWUsIGFkamFjZW50IGNoYW5nZXMgYXJlIHJlcG9ydGVkXG4gICAgc2VwYXJhdGVseS5cbiAgICAqL1xuICAgIGl0ZXJDaGFuZ2VzKGYsIGluZGl2aWR1YWwgPSBmYWxzZSkge1xuICAgICAgICBpdGVyQ2hhbmdlcyh0aGlzLCBmLCBpbmRpdmlkdWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgICBzZXQuXG4gICAgKi9cbiAgICBnZXQgZGVzYygpIHsgcmV0dXJuIENoYW5nZURlc2MuY3JlYXRlKHRoaXMuc2VjdGlvbnMpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXIocmFuZ2VzKSB7XG4gICAgICAgIGxldCByZXN1bHRTZWN0aW9ucyA9IFtdLCByZXN1bHRJbnNlcnRlZCA9IFtdLCBmaWx0ZXJlZFNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBpdGVyID0gbmV3IFNlY3Rpb25JdGVyKHRoaXMpO1xuICAgICAgICBkb25lOiBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGkgPT0gcmFuZ2VzLmxlbmd0aCA/IDFlOSA6IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IG5leHQgfHwgcG9zID09IG5leHQgJiYgaXRlci5sZW4gPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBuZXh0IC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGxldCBpbnMgPSBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMDtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIGlucyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucyA+IDApXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChyZXN1bHRJbnNlcnRlZCwgcmVzdWx0U2VjdGlvbnMsIGl0ZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgZW5kIC0gcG9zKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHJlc3VsdFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKGZpbHRlcmVkU2VjdGlvbnMsIGxlbiwgaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDApO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogbmV3IENoYW5nZVNldChyZXN1bHRTZWN0aW9ucywgcmVzdWx0SW5zZXJ0ZWQpLFxuICAgICAgICAgICAgZmlsdGVyZWQ6IENoYW5nZURlc2MuY3JlYXRlKGZpbHRlcmVkU2VjdGlvbnMpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIGNoYW5nZSBzZXQgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2ldLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gobGVuKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucyA9PSAwKVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goW2xlbl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbaSA+PiAxXS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICAgIGdpdmVuIGxlbmd0aCwgdXNpbmcgYGxpbmVTZXBgIGFzIGxpbmUgc2VwYXJhdG9yLlxuICAgICovXG4gICAgc3RhdGljIG9mKGNoYW5nZXMsIGxlbmd0aCwgbGluZVNlcCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXSwgcG9zID0gMDtcbiAgICAgICAgbGV0IHRvdGFsID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gZmx1c2goZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhc2VjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChwb3MgPCBsZW5ndGgpXG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuZ3RoIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc2V0Lm1hcCh0b3RhbCkpIDogc2V0O1xuICAgICAgICAgICAgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGluc2VydGVkID0gW107XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3Moc3BlYykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3BlYykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2Ygc3BlYylcbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyhzdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3BlYyBpbnN0YW5jZW9mIENoYW5nZVNldCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLmxlbmd0aCAhPSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3RoIChnb3QgJHtzcGVjLmxlbmd0aH0sIGV4cGVjdGVkICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNwZWMubWFwKHRvdGFsKSkgOiBzcGVjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gPSBmcm9tLCBpbnNlcnQgfSA9IHNwZWM7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiB0byB8fCBmcm9tIDwgMCB8fCB0byA+IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY2hhbmdlIHJhbmdlICR7ZnJvbX0gdG8gJHt0b30gKGluIGRvYyBvZiBsZW5ndGggJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGxldCBpbnNUZXh0ID0gIWluc2VydCA/IFRleHQuZW1wdHkgOiB0eXBlb2YgaW5zZXJ0ID09IFwic3RyaW5nXCIgPyBUZXh0Lm9mKGluc2VydC5zcGxpdChsaW5lU2VwIHx8IERlZmF1bHRTcGxpdCkpIDogaW5zZXJ0O1xuICAgICAgICAgICAgICAgIGxldCBpbnNMZW4gPSBpbnNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PSB0byAmJiBpbnNMZW4gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBmcm9tIC0gcG9zLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgdG8gLSBmcm9tLCBpbnNMZW4pO1xuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnRlZCwgc2VjdGlvbnMsIGluc1RleHQpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MoY2hhbmdlcyk7XG4gICAgICAgIGZsdXNoKCF0b3RhbCk7XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IGNoYW5nZXNldCBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICovXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChsZW5ndGggPyBbbGVuZ3RoLCAtMV0gOiBbXSwgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2VzZXQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWQgYnlcbiAgICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0ganNvbltpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0LCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXJ0KSB8fCB0eXBlb2YgcGFydFswXSAhPSBcIm51bWJlclwiIHx8IHBhcnQuc29tZSgoZSwgaSkgPT4gaSAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGluc2VydGVkLmxlbmd0aCA8IGkpXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRbaV0gPSBUZXh0Lm9mKHBhcnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgaW5zZXJ0ZWRbaV0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxhc3QgPj0gMCAmJiBsZW4gPT0gMCAmJiBzZWN0aW9uc1tsYXN0XSA9PSAwKVxuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIGVsc2UgaWYgKGZvcmNlSm9pbikge1xuICAgICAgICBzZWN0aW9uc1tsYXN0XSArPSBsZW47XG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgc2VjdGlvbnMucHVzaChsZW4sIGlucyk7XG59XG5mdW5jdGlvbiBhZGRJbnNlcnQodmFsdWVzLCBzZWN0aW9ucywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgaW5kZXggPSAoc2VjdGlvbnMubGVuZ3RoIC0gMikgPj4gMTtcbiAgICBpZiAoaW5kZXggPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0gPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdLmFwcGVuZCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAodmFsdWVzLmxlbmd0aCA8IGluZGV4KVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goVGV4dC5lbXB0eSk7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyQ2hhbmdlcyhkZXNjLCBmLCBpbmRpdmlkdWFsKSB7XG4gICAgbGV0IGluc2VydGVkID0gZGVzYy5pbnNlcnRlZDtcbiAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDAsIGkgPSAwOyBpIDwgZGVzYy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK10sIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgaWYgKGlucyA8IDApIHtcbiAgICAgICAgICAgIHBvc0EgKz0gbGVuO1xuICAgICAgICAgICAgcG9zQiArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZW5kQSA9IHBvc0EsIGVuZEIgPSBwb3NCLCB0ZXh0ID0gVGV4dC5lbXB0eTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBlbmRBICs9IGxlbjtcbiAgICAgICAgICAgICAgICBlbmRCICs9IGlucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zICYmIGluc2VydGVkKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5hcHBlbmQoaW5zZXJ0ZWRbKGkgLSAyKSA+PiAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGl2aWR1YWwgfHwgaSA9PSBkZXNjLnNlY3Rpb25zLmxlbmd0aCB8fCBkZXNjLnNlY3Rpb25zW2kgKyAxXSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgICAgICBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmKHBvc0EsIGVuZEEsIHBvc0IsIGVuZEIsIHRleHQpO1xuICAgICAgICAgICAgcG9zQSA9IGVuZEE7XG4gICAgICAgICAgICBwb3NCID0gZW5kQjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcFNldChzZXRBLCBzZXRCLCBiZWZvcmUsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICAvLyBQcm9kdWNlIGEgY29weSBvZiBzZXRBIHRoYXQgYXBwbGllcyB0byB0aGUgZG9jdW1lbnQgYWZ0ZXIgc2V0QlxuICAgIC8vIGhhcyBiZWVuIGFwcGxpZWQgKGFzc3VtaW5nIGJvdGggc3RhcnQgYXQgdGhlIHNhbWUgZG9jdW1lbnQpLlxuICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYm90aCBzZXRzIGluIHBhcmFsbGVsLiBpbnNlcnRlZCB0cmFja3MsIGZvciBjaGFuZ2VzXG4gICAgLy8gaW4gQSB0aGF0IGhhdmUgdG8gYmUgcHJvY2Vzc2VkIHBpZWNlLWJ5LXBpZWNlLCB3aGV0aGVyIHRoZWlyXG4gICAgLy8gY29udGVudCBoYXMgYmVlbiBpbnNlcnRlZCBhbHJlYWR5LCBhbmQgcmVmZXJzIHRvIHRoZSBzZWN0aW9uXG4gICAgLy8gaW5kZXguXG4gICAgZm9yIChsZXQgaW5zZXJ0ZWQgPSAtMTs7KSB7XG4gICAgICAgIGlmIChhLmRvbmUgJiYgYi5sZW4gfHwgYi5kb25lICYmIGEubGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA9PSAtMSAmJiBiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgLy8gTW92ZSBhY3Jvc3MgcmFuZ2VzIHNraXBwZWQgYnkgYm90aCBzZXRzLlxuICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGEubGVuLCBiLmxlbik7XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgYi5mb3J3YXJkKGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5pbnMgPj0gMCAmJiAoYS5pbnMgPCAwIHx8IGluc2VydGVkID09IGEuaSB8fCBhLm9mZiA9PSAwICYmIChiLmxlbiA8IGEubGVuIHx8IGIubGVuID09IGEubGVuICYmICFiZWZvcmUpKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIGNoYW5nZSBpbiBCIHRoYXQgY29tZXMgYmVmb3JlIHRoZSBuZXh0IGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gQSAob3JkZXJlZCBieSBzdGFydCBwb3MsIHRoZW4gbGVuLCB0aGVuIGJlZm9yZSBmbGFnKSwgc2tpcFxuICAgICAgICAgICAgLy8gdGhhdCAoYW5kIHByb2Nlc3MgYW55IGNoYW5nZXMgaW4gQSBpdCBjb3ZlcnMpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IGIubGVuO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYi5pbnMsIC0xKTtcbiAgICAgICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBNYXRoLm1pbihhLmxlbiwgbGVuKTtcbiAgICAgICAgICAgICAgICBpZiAoYS5pbnMgPj0gMCAmJiBpbnNlcnRlZCA8IGEuaSAmJiBhLmxlbiA8PSBwaWVjZSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBhLmlucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgbGVuIC09IHBpZWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPj0gMCkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgcGFydCBvZiBhIGNoYW5nZSBpbiBBIHVwIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbm9uLWRlbGV0aW9uIGNoYW5nZSBpbiBCIChpZiBvdmVybGFwcGluZykuXG4gICAgICAgICAgICBsZXQgbGVuID0gMCwgbGVmdCA9IGEubGVuO1xuICAgICAgICAgICAgd2hpbGUgKGxlZnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4obGVmdCwgYi5sZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gcGllY2U7XG4gICAgICAgICAgICAgICAgICAgIGIuZm9yd2FyZChwaWVjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IDAgJiYgYi5sZW4gPCBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gYi5sZW47XG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnNlcnRlZCA8IGEuaSA/IGEuaW5zIDogMCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0ICYmIGluc2VydGVkIDwgYS5pKVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhLmk7XG4gICAgICAgICAgICBhLmZvcndhcmQoYS5sZW4gLSBsZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgJiYgYi5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0ID8gQ2hhbmdlU2V0LmNyZWF0ZVNldChzZWN0aW9ucywgaW5zZXJ0KSA6IENoYW5nZURlc2MuY3JlYXRlKHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGhzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNldHMoc2V0QSwgc2V0QiwgbWtTZXQgPSBmYWxzZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgIGxldCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICBmb3IgKGxldCBvcGVuID0gZmFsc2U7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gMCkgeyAvLyBEZWxldGlvbiBpbiBBXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLmxlbiwgMCwgb3Blbik7XG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmxlbiA9PSAwICYmICFiLmRvbmUpIHsgLy8gSW5zZXJ0aW9uIGluIEJcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIDAsIGIuaW5zLCBvcGVuKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRvbmUgfHwgYi5kb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbjIsIGIubGVuKSwgc2VjdGlvbkxlbiA9IHNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpbnNCID0gYi5pbnMgPT0gLTEgPyAtMSA6IGIub2ZmID8gMCA6IGIuaW5zO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zQiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNCKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5vZmYgPyAwIDogYS5sZW4sIGxlbiwgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dEJpdChsZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBiLm9mZiA/IDAgOiBiLmlucywgb3Blbik7XG4gICAgICAgICAgICAgICAgaWYgKGluc2VydCAmJiAhYi5vZmYpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3BlbiA9IChhLmlucyA+IGxlbiB8fCBiLmlucyA+PSAwICYmIGIubGVuID4gbGVuKSAmJiAob3BlbiB8fCBzZWN0aW9ucy5sZW5ndGggPiBzZWN0aW9uTGVuKTtcbiAgICAgICAgICAgIGEuZm9yd2FyZDIobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2VjdGlvbkl0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHNldCkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB7IHNlY3Rpb25zIH0gPSB0aGlzLnNldDtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5sZW4gPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgICAgICB0aGlzLmlucyA9IHNlY3Rpb25zW3RoaXMuaSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5zID0gLTI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmYgPSAwO1xuICAgIH1cbiAgICBnZXQgZG9uZSgpIHsgcmV0dXJuIHRoaXMuaW5zID09IC0yOyB9XG4gICAgZ2V0IGxlbjIoKSB7IHJldHVybiB0aGlzLmlucyA8IDAgPyB0aGlzLmxlbiA6IHRoaXMuaW5zOyB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCA/IFRleHQuZW1wdHkgOiBpbnNlcnRlZFtpbmRleF07XG4gICAgfVxuICAgIHRleHRCaXQobGVuKSB7XG4gICAgICAgIGxldCB7IGluc2VydGVkIH0gPSB0aGlzLnNldCwgaW5kZXggPSAodGhpcy5pIC0gMikgPj4gMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IGluc2VydGVkLmxlbmd0aCAmJiAhbGVuID8gVGV4dC5lbXB0eVxuICAgICAgICAgICAgOiBpbnNlcnRlZFtpbmRleF0uc2xpY2UodGhpcy5vZmYsIGxlbiA9PSBudWxsID8gdW5kZWZpbmVkIDogdGhpcy5vZmYgKyBsZW4pO1xuICAgIH1cbiAgICBmb3J3YXJkKGxlbikge1xuICAgICAgICBpZiAobGVuID09IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZW4gLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcndhcmQyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbnMgPT0gLTEpXG4gICAgICAgICAgICB0aGlzLmZvcndhcmQobGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuID09IHRoaXMuaW5zKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnMgLT0gbGVuO1xuICAgICAgICAgICAgdGhpcy5vZmYgKz0gbGVuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbkEgc2luZ2xlIHNlbGVjdGlvbiByYW5nZS4gV2hlblxuW2BhbGxvd011bHRpcGxlU2VsZWN0aW9uc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpXG5pcyBlbmFibGVkLCBhIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uKSBtYXkgaG9sZFxubXVsdGlwbGUgcmFuZ2VzLiBCeSBkZWZhdWx0LCBzZWxlY3Rpb25zIGhvbGQgZXhhY3RseSBvbmUgcmFuZ2UuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG8sIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZeKAlHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XG4gICAgZXh0ZW5kIGl0LlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgVGhlIGhlYWQgb2YgdGhlIHJhbmdlLCB3aGljaCBpcyBtb3ZlZCB3aGVuIHRoZSByYW5nZSBpc1xuICAgIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy5mcm9tIDogdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiBgYW5jaG9yYCBhbmQgYGhlYWRgIGFyZSBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvOyB9XG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBhIGN1cnNvciB0aGF0IGlzIGV4cGxpY2l0bHkgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gICAgdGhlIGNoYXJhY3RlciBiZWZvcmUgaXRzIHBvc2l0aW9uLCAxIHRoZSBjaGFyYWN0ZXIgYWZ0ZXIsIGFuZCAwXG4gICAgbWVhbnMgbm8gYXNzb2NpYXRpb24uXG4gICAgKi9cbiAgICBnZXQgYXNzb2MoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gPyAtMSA6IHRoaXMuZmxhZ3MgJiAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyA/IDEgOiAwOyB9XG4gICAgLyoqXG4gICAgVGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBsZXZlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjdXJzb3IsIGlmXG4gICAgYW55LlxuICAgICovXG4gICAgZ2V0IGJpZGlMZXZlbCgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gdGhpcy5mbGFncyAmIDcgLyogUmFuZ2VGbGFnLkJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSA3ID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi87XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICAgIHVwZGF0ZWQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGZyb20gPSB0byA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gY2hhbmdlLm1hcFBvcyh0aGlzLmZyb20sIDEpO1xuICAgICAgICAgICAgdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMudG8sIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbSA9PSB0aGlzLmZyb20gJiYgdG8gPT0gdGhpcy50byA/IHRoaXMgOiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgICAqL1xuICAgIGV4dGVuZChmcm9tLCB0byA9IGZyb20pIHtcbiAgICAgICAgaWYgKGZyb20gPD0gdGhpcy5hbmNob3IgJiYgdG8gPj0gdGhpcy5hbmNob3IpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGhlYWQgPSBNYXRoLmFicyhmcm9tIC0gdGhpcy5hbmNob3IpID4gTWF0aC5hYnModG8gLSB0aGlzLmFuY2hvcikgPyBmcm9tIDogdG87XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodGhpcy5hbmNob3IsIGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgcmFuZ2UgdG8gYW5vdGhlciByYW5nZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmNob3IgPT0gb3RoZXIuYW5jaG9yICYmIHRoaXMuaGVhZCA9PSBvdGhlci5oZWFkICYmXG4gICAgICAgICAgICAoIWluY2x1ZGVBc3NvYyB8fCAhdGhpcy5lbXB0eSB8fCB0aGlzLmFzc29jID09IG90aGVyLmFzc29jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgZmxhZ3MpO1xuICAgIH1cbn1cbi8qKlxuQW4gZWRpdG9yIHNlbGVjdGlvbiBob2xkcyBvbmUgb3IgbW9yZSBzZWxlY3Rpb24gcmFuZ2VzLlxuKi9cbmNsYXNzIEVkaXRvclNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJhbmdlcyBpbiB0aGUgc2VsZWN0aW9uLCBzb3J0ZWQgYnkgcG9zaXRpb24uIFJhbmdlcyBjYW5ub3RcbiAgICBvdmVybGFwIChidXQgdGhleSBtYXkgdG91Y2gsIGlmIHRoZXkgYXJlbid0IGVtcHR5KS5cbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgVGhlIGluZGV4IG9mIHRoZSBfbWFpbl8gcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbiAod2hpY2ggaXNcbiAgICB1c3VhbGx5IHRoZSByYW5nZSB0aGF0IHdhcyBhZGRlZCBsYXN0KS5cbiAgICAqL1xuICAgIG1haW5JbmRleCkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5tYWluSW5kZXggPSBtYWluSW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHNlbGVjdGlvbiB0aHJvdWdoIGEgY2hhbmdlLiBVc2VkIHRvIGFkanVzdCB0aGUgc2VsZWN0aW9uXG4gICAgcG9zaXRpb24gZm9yIGNoYW5nZXMuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlLCBhc3NvYyA9IC0xKSB7XG4gICAgICAgIGlmIChjaGFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUodGhpcy5yYW5nZXMubWFwKHIgPT4gci5tYXAoY2hhbmdlLCBhc3NvYykpLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBzZWxlY3Rpb24gdG8gYW5vdGhlciBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQsIHJhbmdlc1xuICAgIGFyZSBjb21wYXJlZCBvbmx5IGJ5IHBvc2l0aW9uLiBXaGVuIGBpbmNsdWRlQXNzb2NgIGlzIHRydWUsXG4gICAgY3Vyc29yIHJhbmdlcyBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZVxuICAgIFtgYXNzb2NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmFzc29jKSB2YWx1ZS5cbiAgICAqL1xuICAgIGVxKG90aGVyLCBpbmNsdWRlQXNzb2MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5yYW5nZXMubGVuZ3RoICE9IG90aGVyLnJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMubWFpbkluZGV4ICE9IG90aGVyLm1haW5JbmRleClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5yYW5nZXNbaV0uZXEob3RoZXIucmFuZ2VzW2ldLCBpbmNsdWRlQXNzb2MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ubm9ybWFsaXplZChyYW5nZXMuc2xpY2UoKSwgbWFpbkluZGV4KTtcbiAgICAgICAgICAgIHBvcyA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHNlbGVjdGlvbiByYW5nZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uIFlvdSBjYW5cbiAgICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGN1cnNvcihwb3MsIGFzc29jID0gMCwgYmlkaUxldmVsLCBnb2FsQ29sdW1uKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUocG9zLCBwb3MsIChhc3NvYyA9PSAwID8gMCA6IGFzc29jIDwgMCA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKSB8XG4gICAgICAgICAgICAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbENvbHVtbiwgYmlkaUxldmVsKSB7XG4gICAgICAgIGxldCBmbGFncyA9ICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLykgPDwgNiAvKiBSYW5nZUZsYWcuR29hbENvbHVtbk9mZnNldCAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gNyA6IE1hdGgubWluKDYsIGJpZGlMZXZlbCkpO1xuICAgICAgICByZXR1cm4gaGVhZCA8IGFuY2hvciA/IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShoZWFkLCBhbmNob3IsIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyB8IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovIHwgZmxhZ3MpXG4gICAgICAgICAgICA6IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShhbmNob3IsIGhlYWQsIChoZWFkID4gYW5jaG9yID8gOCAvKiBSYW5nZUZsYWcuQXNzb2NCZWZvcmUgKi8gOiAwKSB8IGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgbGV0IG1haW4gPSByYW5nZXNbbWFpbkluZGV4XTtcbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBwcmV2LmZyb20sIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHByZXYudG8pO1xuICAgICAgICAgICAgICAgIGlmIChpIDw9IG1haW5JbmRleClcbiAgICAgICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIHJhbmdlLmFuY2hvciA+IHJhbmdlLmhlYWQgPyBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgcmFuZ2Ugb2Ygc2VsZWN0aW9uLnJhbmdlcylcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZG9jTGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcG9pbnRzIG91dHNpZGUgb2YgZG9jdW1lbnRcIik7XG59XG5cbmxldCBuZXh0SUQgPSAwO1xuLyoqXG5BIGZhY2V0IGlzIGEgbGFiZWxlZCB2YWx1ZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3JcbnN0YXRlLiBJdCB0YWtlcyBpbnB1dHMgZnJvbSBhbnkgbnVtYmVyIG9mIGV4dGVuc2lvbnMsIGFuZCBjb21iaW5lc1xudGhvc2UgaW50byBhIHNpbmdsZSBvdXRwdXQgdmFsdWUuXG5cbkV4YW1wbGVzIG9mIHVzZXMgb2YgZmFjZXRzIGFyZSB0aGUgW3RhYlxuc2l6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSwgW2VkaXRvclxuYXR0cmlidXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdG9yQXR0cmlidXRlcyksIGFuZCBbdXBkYXRlXG5saXN0ZW5lcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnVwZGF0ZUxpc3RlbmVyKS5cblxuTm90ZSB0aGF0IGBGYWNldGAgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFueXdoZXJlIHdoZXJlXG5bYEZhY2V0UmVhZGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldFJlYWRlcikgaXMgZXhwZWN0ZWQuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIGVuYWJsZXMpIHtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZTtcbiAgICAgICAgdGhpcy5jb21wYXJlSW5wdXQgPSBjb21wYXJlSW5wdXQ7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IGNvbWJpbmUoW10pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB0eXBlb2YgZW5hYmxlcyA9PSBcImZ1bmN0aW9uXCIgPyBlbmFibGVzKHRoaXMpIDogZW5hYmxlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIGZhY2V0IHJlYWRlciBmb3IgdGhpcyBmYWNldCwgd2hpY2ggY2FuIGJlIHVzZWQgdG9cbiAgICBbcmVhZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5mYWNldCkgaXQgYnV0IG5vdCB0byBkZWZpbmUgdmFsdWVzIGZvciBpdC5cbiAgICAqL1xuICAgIGdldCByZWFkZXIoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0KGNvbmZpZy5jb21iaW5lIHx8ICgoYSkgPT4gYSksIGNvbmZpZy5jb21wYXJlSW5wdXQgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnLmNvbXBhcmUgfHwgKCFjb25maWcuY29tYmluZSA/IHNhbWVBcnJheSA6IChhLCBiKSA9PiBhID09PSBiKSwgISFjb25maWcuc3RhdGljLCBjb25maWcuZW5hYmxlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihbXSwgdGhpcywgMCAvKiBQcm92aWRlci5TdGF0aWMgKi8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIGEgdmFsdWUgZm9yIHRoZSBmYWNldCBmcm9tIGFcbiAgICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gICAgdGhpcyB2YWx1ZSBkZXBlbmRzIG9uLCBzaW5jZSB5b3VyIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGFnYWluXG4gICAgZm9yIGEgbmV3IHN0YXRlIHdoZW4gb25lIG9mIHRob3NlIHBhcnRzIGNoYW5nZWQuXG4gICAgXG4gICAgSW4gY2FzZXMgd2hlcmUgeW91ciB2YWx1ZSBkZXBlbmRzIG9ubHkgb24gYSBzaW5nbGUgZmllbGQsIHlvdSdsbFxuICAgIHdhbnQgdG8gdXNlIHRoZSBbYGZyb21gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0LmZyb20pIG1ldGhvZCBpbnN0ZWFkLlxuICAgICovXG4gICAgY29tcHV0ZShkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMSAvKiBQcm92aWRlci5TaW5nbGUgKi8sIGdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyB6ZXJvIG9yIG1vcmUgdmFsdWVzIGZvciB0aGlzXG4gICAgZmFjZXQgZnJvbSBhIHN0YXRlLlxuICAgICovXG4gICAgY29tcHV0ZU4oZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDIgLyogUHJvdmlkZXIuTXVsdGkgKi8sIGdldCk7XG4gICAgfVxuICAgIGZyb20oZmllbGQsIGdldCkge1xuICAgICAgICBpZiAoIWdldClcbiAgICAgICAgICAgIGdldCA9IHggPT4geDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZShbZmllbGRdLCBzdGF0ZSA9PiBnZXQoc3RhdGUuZmllbGQoZmllbGQpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8IGEubGVuZ3RoID09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IGUgPT09IGJbaV0pO1xufVxuY2xhc3MgRmFjZXRQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLCBmYWNldCwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gICAgICAgIHRoaXMuZmFjZXQgPSBmYWNldDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlkID0gbmV4dElEKys7XG4gICAgfVxuICAgIGR5bmFtaWNTbG90KGFkZHJlc3Nlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBnZXR0ZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgY29tcGFyZSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0O1xuICAgICAgICBsZXQgaWQgPSB0aGlzLmlkLCBpZHggPSBhZGRyZXNzZXNbaWRdID4+IDEsIG11bHRpID0gdGhpcy50eXBlID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi87XG4gICAgICAgIGxldCBkZXBEb2MgPSBmYWxzZSwgZGVwU2VsID0gZmFsc2UsIGRlcEFkZHJzID0gW107XG4gICAgICAgIGZvciAobGV0IGRlcCBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgaWYgKGRlcCA9PSBcImRvY1wiKVxuICAgICAgICAgICAgICAgIGRlcERvYyA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmIChkZXAgPT0gXCJzZWxlY3Rpb25cIilcbiAgICAgICAgICAgICAgICBkZXBTZWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoKCgoX2EgPSBhZGRyZXNzZXNbZGVwLmlkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSkgJiAxKSA9PSAwKVxuICAgICAgICAgICAgICAgIGRlcEFkZHJzLnB1c2goYWRkcmVzc2VzW2RlcC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8IGVuc3VyZUFsbChzdGF0ZSwgZGVwQWRkcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGkgPyAhY29tcGFyZUFycmF5KG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0sIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBzdGF0ZS52YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCwgb2xkQWRkciA9IG9sZFN0YXRlLmNvbmZpZy5hZGRyZXNzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkQWRkciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBnZXRBZGRyKG9sZFN0YXRlLCBvbGRBZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmV2ZXJ5KGRlcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVwIGluc3RhbmNlb2YgRmFjZXQgPyBvbGRTdGF0ZS5mYWNldChkZXApID09PSBzdGF0ZS5mYWNldChkZXApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXAgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkID8gb2xkU3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgPT0gc3RhdGUuZmllbGQoZGVwLCBmYWxzZSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KSB8fCAobXVsdGkgPyBjb21wYXJlQXJyYXkobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsLCBjb21wYXJlKSA6IGNvbXBhcmUobmV3VmFsID0gZ2V0dGVyKHN0YXRlKSwgb2xkVmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5zdXJlQWxsKHN0YXRlLCBhZGRycykge1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgYWRkciBvZiBhZGRycylcbiAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpICYgMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi8pXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNGYWNldFNsb3QoYWRkcmVzc2VzLCBmYWNldCwgcHJvdmlkZXJzKSB7XG4gICAgbGV0IHByb3ZpZGVyQWRkcnMgPSBwcm92aWRlcnMubWFwKHAgPT4gYWRkcmVzc2VzW3AuaWRdKTtcbiAgICBsZXQgcHJvdmlkZXJUeXBlcyA9IHByb3ZpZGVycy5tYXAocCA9PiBwLnR5cGUpO1xuICAgIGxldCBkeW5hbWljID0gcHJvdmlkZXJBZGRycy5maWx0ZXIocCA9PiAhKHAgJiAxKSk7XG4gICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1tmYWNldC5pZF0gPj4gMTtcbiAgICBmdW5jdGlvbiBnZXQoc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3ZpZGVyQWRkcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGdldEFkZHIoc3RhdGUsIHByb3ZpZGVyQWRkcnNbaV0pO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyVHlwZXNbaV0gPT0gMiAvKiBQcm92aWRlci5NdWx0aSAqLylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWNldC5jb21iaW5lKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYWRkciBvZiBwcm92aWRlckFkZHJzKVxuICAgICAgICAgICAgICAgIGVuc3VyZUFkZHIoc3RhdGUsIGFkZHIpO1xuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICBpZiAoIWVuc3VyZUFsbChzdGF0ZSwgZHluYW1pYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIHN0YXRlLnZhbHVlc1tpZHhdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29uZmlndXJlKHN0YXRlLCBvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGRlcENoYW5nZWQgPSBlbnN1cmVBbGwoc3RhdGUsIHByb3ZpZGVyQWRkcnMpO1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZFN0YXRlLmNvbmZpZy5mYWNldHNbZmFjZXQuaWRdLCBvbGRWYWx1ZSA9IG9sZFN0YXRlLmZhY2V0KGZhY2V0KTtcbiAgICAgICAgICAgIGlmIChvbGRQcm92aWRlcnMgJiYgIWRlcENoYW5nZWQgJiYgc2FtZUFycmF5KHByb3ZpZGVycywgb2xkUHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXQoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IGluaXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBzdGF0aWM6IHRydWUgfSk7XG4vKipcbkZpZWxkcyBjYW4gc3RvcmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBpbiBhbiBlZGl0b3Igc3RhdGUsIGFuZFxua2VlcCBpdCBpbiBzeW5jIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YXRlRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIGNyZWF0ZUYsIHVwZGF0ZUYsIGNvbXBhcmVGLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmNyZWF0ZUYgPSBjcmVhdGVGO1xuICAgICAgICB0aGlzLnVwZGF0ZUYgPSB1cGRhdGVGO1xuICAgICAgICB0aGlzLmNvbXBhcmVGID0gY29tcGFyZUY7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm92aWRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RhdGUgZmllbGQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNvbmZpZykge1xuICAgICAgICBsZXQgZmllbGQgPSBuZXcgU3RhdGVGaWVsZChuZXh0SUQrKywgY29uZmlnLmNyZWF0ZSwgY29uZmlnLnVwZGF0ZSwgY29uZmlnLmNvbXBhcmUgfHwgKChhLCBiKSA9PiBhID09PSBiKSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlKVxuICAgICAgICAgICAgZmllbGQucHJvdmlkZXMgPSBjb25maWcucHJvdmlkZShmaWVsZCk7XG4gICAgICAgIHJldHVybiBmaWVsZDtcbiAgICB9XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIGxldCBpbml0ID0gc3RhdGUuZmFjZXQoaW5pdEZpZWxkKS5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKTtcbiAgICAgICAgcmV0dXJuICgoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmNyZWF0ZSkgfHwgdGhpcy5jcmVhdGVGKShzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgbGV0IGlkeCA9IGFkZHJlc3Nlc1t0aGlzLmlkXSA+PiAxO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlOiAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IHN0YXRlLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlRihvbGRWYWwsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjb25maWd1cmU6IChzdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCksIG9sZEluaXQgPSBvbGRTdGF0ZS5mYWNldChpbml0RmllbGQpLCByZUluaXQ7XG4gICAgICAgICAgICAgICAgaWYgKChyZUluaXQgPSBpbml0LmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpKSAmJiByZUluaXQgIT0gb2xkSW5pdC5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHJlSW5pdC5jcmVhdGUoc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1t0aGlzLmlkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gb2xkU3RhdGUuZmllbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHRoaXMuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyB0aGlzIGZpZWxkIGFuZCBvdmVycmlkZXMgdGhlXG4gICAgd2F5IGl0IGlzIGluaXRpYWxpemVkLiBDYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcHJvdmlkZSBhXG4gICAgbm9uLWRlZmF1bHQgc3RhcnRpbmcgdmFsdWUgZm9yIHRoZSBmaWVsZC5cbiAgICAqL1xuICAgIGluaXQoY3JlYXRlKSB7XG4gICAgICAgIHJldHVybiBbdGhpcywgaW5pdEZpZWxkLm9mKHsgZmllbGQ6IHRoaXMsIGNyZWF0ZSB9KV07XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXRlIGZpZWxkIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhc1xuICAgIFtgRXh0ZW5zaW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pIHZhbHVlcyB0byBlbmFibGUgdGhlIGZpZWxkIGluIGFcbiAgICBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBleHRlbnNpb24oKSB7IHJldHVybiB0aGlzOyB9XG59XG5jb25zdCBQcmVjXyA9IHsgbG93ZXN0OiA0LCBsb3c6IDMsIGRlZmF1bHQ6IDIsIGhpZ2g6IDEsIGhpZ2hlc3Q6IDAgfTtcbmZ1bmN0aW9uIHByZWModmFsdWUpIHtcbiAgICByZXR1cm4gKGV4dCkgPT4gbmV3IFByZWNFeHRlbnNpb24oZXh0LCB2YWx1ZSk7XG59XG4vKipcbkJ5IGRlZmF1bHQgZXh0ZW5zaW9ucyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZm91bmRcbmluIHRoZSBmbGF0dGVuZWQgZm9ybSBvZiBuZXN0ZWQgYXJyYXkgdGhhdCB3YXMgcHJvdmlkZWQuXG5JbmRpdmlkdWFsIGV4dGVuc2lvbiB2YWx1ZXMgY2FuIGJlIGFzc2lnbmVkIGEgcHJlY2VkZW5jZSB0b1xub3ZlcnJpZGUgdGhpcy4gRXh0ZW5zaW9ucyB0aGF0IGRvIG5vdCBoYXZlIGEgcHJlY2VkZW5jZSBzZXQgZ2V0XG50aGUgcHJlY2VkZW5jZSBvZiB0aGUgbmVhcmVzdCBwYXJlbnQgd2l0aCBhIHByZWNlZGVuY2UsIG9yXG5bYGRlZmF1bHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlByZWMuZGVmYXVsdCkgaWYgdGhlcmUgaXMgbm8gc3VjaCBwYXJlbnQuIFRoZVxuZmluYWwgb3JkZXJpbmcgb2YgZXh0ZW5zaW9ucyBpcyBkZXRlcm1pbmVkIGJ5IGZpcnN0IHNvcnRpbmcgYnlcbnByZWNlZGVuY2UgYW5kIHRoZW4gYnkgb3JkZXIgd2l0aGluIGVhY2ggcHJlY2VkZW5jZS5cbiovXG5jb25zdCBQcmVjID0ge1xuICAgIC8qKlxuICAgIFRoZSBoaWdoZXN0IHByZWNlZGVuY2UgbGV2ZWwsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBwcmVjZWRlbmNlIG9yZGVyaW5nLlxuICAgICovXG4gICAgaGlnaGVzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaGVzdCksXG4gICAgLyoqXG4gICAgQSBoaWdoZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zIHRoYXQgc2hvdWxkXG4gICAgY29tZSBiZWZvcmUgdGhvc2Ugd2l0aCBkZWZhdWx0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBoaWdoOiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoKSxcbiAgICAvKipcbiAgICBUaGUgZGVmYXVsdCBwcmVjZWRlbmNlLCB3aGljaCBpcyBhbHNvIHVzZWQgZm9yIGV4dGVuc2lvbnNcbiAgICB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBkZWZhdWx0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5kZWZhdWx0KSxcbiAgICAvKipcbiAgICBBIGxvd2VyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgbG93OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3cpLFxuICAgIC8qKlxuICAgIFRoZSBsb3dlc3QgcHJlY2VkZW5jZSBsZXZlbC4gTWVhbnQgZm9yIHRoaW5ncyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBlbmQgb2YgdGhlIGV4dGVuc2lvbiBvcmRlci5cbiAgICAqL1xuICAgIGxvd2VzdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93ZXN0KVxufTtcbmNsYXNzIFByZWNFeHRlbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKGlubmVyLCBwcmVjKSB7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICAgICAgdGhpcy5wcmVjID0gcHJlYztcbiAgICB9XG59XG4vKipcbkV4dGVuc2lvbiBjb21wYXJ0bWVudHMgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIGNvbmZpZ3VyYXRpb25cbmR5bmFtaWMuIEJ5IFt3cmFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5vZikgcGFydCBvZiB5b3VyXG5jb25maWd1cmF0aW9uIGluIGEgY29tcGFydG1lbnQsIHlvdSBjYW4gbGF0ZXJcbltyZXBsYWNlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKSB0aGF0IHBhcnQgdGhyb3VnaCBhXG50cmFuc2FjdGlvbi5cbiovXG5jbGFzcyBDb21wYXJ0bWVudCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY29tcGFydG1lbnQgdG8gYWRkIHRvIHlvdXIgW3N0YXRlXG4gICAgY29uZmlndXJhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZUNvbmZpZy5leHRlbnNpb25zKS5cbiAgICAqL1xuICAgIG9mKGV4dCkgeyByZXR1cm4gbmV3IENvbXBhcnRtZW50SW5zdGFuY2UodGhpcywgZXh0KTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBbZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0aGF0XG4gICAgcmVjb25maWd1cmVzIHRoaXMgY29tcGFydG1lbnQuXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZS5vZih7IGNvbXBhcnRtZW50OiB0aGlzLCBleHRlbnNpb246IGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCBjb250ZW50IG9mIHRoZSBjb21wYXJ0bWVudCBpbiB0aGUgc3RhdGUsIG9yXG4gICAgYHVuZGVmaW5lZGAgaWYgaXQgaXNuJ3QgcHJlc2VudC5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29uZmlnLmNvbXBhcnRtZW50cy5nZXQodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgQ29tcGFydG1lbnRJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IoY29tcGFydG1lbnQsIGlubmVyKSB7XG4gICAgICAgIHRoaXMuY29tcGFydG1lbnQgPSBjb21wYXJ0bWVudDtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgIH1cbn1cbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGJhc2UsIGNvbXBhcnRtZW50cywgZHluYW1pY1Nsb3RzLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cykge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50cyA9IGNvbXBhcnRtZW50cztcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RhdGljVmFsdWVzID0gc3RhdGljVmFsdWVzO1xuICAgICAgICB0aGlzLmZhY2V0cyA9IGZhY2V0cztcbiAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZSA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5zdGF0dXNUZW1wbGF0ZS5sZW5ndGggPCBkeW5hbWljU2xvdHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZW1wbGF0ZS5wdXNoKDAgLyogU2xvdFN0YXR1cy5VbnJlc29sdmVkICovKTtcbiAgICB9XG4gICAgc3RhdGljRmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICByZXR1cm4gYWRkciA9PSBudWxsID8gZmFjZXQuZGVmYXVsdCA6IHRoaXMuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgZmFjZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIGZsYXR0ZW4oYmFzZSwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmYWNldHNbZXh0LmZhY2V0LmlkXSB8fCAoZmFjZXRzW2V4dC5mYWNldC5pZF0gPSBbXSkpLnB1c2goZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBzdGF0aWNWYWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGFkZHJlc3NbZmllbGQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBmaWVsZC5zbG90KGEpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkRmFjZXRzID0gb2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLmNvbmZpZy5mYWNldHM7XG4gICAgICAgIGZvciAobGV0IGlkIGluIGZhY2V0cykge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVycyA9IGZhY2V0c1tpZF0sIGZhY2V0ID0gcHJvdmlkZXJzWzBdLmZhY2V0O1xuICAgICAgICAgICAgbGV0IG9sZFByb3ZpZGVycyA9IG9sZEZhY2V0cyAmJiBvbGRGYWNldHNbaWRdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVycy5ldmVyeShwID0+IHAudHlwZSA9PSAwIC8qIFByb3ZpZGVyLlN0YXRpYyAqLykpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IChzdGF0aWNWYWx1ZXMubGVuZ3RoIDw8IDEpIHwgMTtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZUFycmF5KG9sZFByb3ZpZGVycywgcHJvdmlkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZS5mYWNldChmYWNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChvbGRTdGF0ZSAmJiBmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRTdGF0ZS5mYWNldChmYWNldCkpID8gb2xkU3RhdGUuZmFjZXQoZmFjZXQpIDogdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaChwLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NbcC5pZF0gPSBkeW5hbWljU2xvdHMubGVuZ3RoIDw8IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IHAuZHluYW1pY1Nsb3QoYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZHluYW1pY0ZhY2V0U2xvdChhLCBmYWNldCwgcHJvdmlkZXJzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR5bmFtaWMgPSBkeW5hbWljU2xvdHMubWFwKGYgPT4gZihhZGRyZXNzKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbihiYXNlLCBuZXdDb21wYXJ0bWVudHMsIGR5bmFtaWMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcywgZmFjZXRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuKGV4dGVuc2lvbiwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdLCBbXV07XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaW5uZXIoZXh0LCBwcmVjKSB7XG4gICAgICAgIGxldCBrbm93biA9IHNlZW4uZ2V0KGV4dCk7XG4gICAgICAgIGlmIChrbm93biAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa25vd24gPD0gcHJlYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm91bmQgPSByZXN1bHRba25vd25dLmluZGV4T2YoZXh0KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrbm93bl0uc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKVxuICAgICAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5kZWxldGUoZXh0LmNvbXBhcnRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNldChleHQsIHByZWMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGV4dClcbiAgICAgICAgICAgICAgICBpbm5lcihlLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAobmV3Q29tcGFydG1lbnRzLmhhcyhleHQuY29tcGFydG1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIGNvbXBhcnRtZW50IGluIGV4dGVuc2lvbnNgKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gY29tcGFydG1lbnRzLmdldChleHQuY29tcGFydG1lbnQpIHx8IGV4dC5pbm5lcjtcbiAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5zZXQoZXh0LmNvbXBhcnRtZW50LCBjb250ZW50KTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFByZWNFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlubmVyKGV4dC5pbm5lciwgZXh0LnByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LnByb3ZpZGVzKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5wcm92aWRlcywgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgRmFjZXRQcm92aWRlcikge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQuZmFjZXQuZXh0ZW5zaW9ucylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQuZmFjZXQuZXh0ZW5zaW9ucywgUHJlY18uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGV4dC5leHRlbnNpb247XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZXh0ZW5zaW9uIHZhbHVlIGluIGV4dGVuc2lvbiBzZXQgKCR7ZXh0fSkuIFRoaXMgc29tZXRpbWVzIGhhcHBlbnMgYmVjYXVzZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgQGNvZGVtaXJyb3Ivc3RhdGUgYXJlIGxvYWRlZCwgYnJlYWtpbmcgaW5zdGFuY2VvZiBjaGVja3MuYCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbm5lcihleHRlbnNpb24sIFByZWNfLmRlZmF1bHQpO1xuICAgIHJldHVybiByZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG59XG5mdW5jdGlvbiBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgaWYgKGFkZHIgJiAxKVxuICAgICAgICByZXR1cm4gMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovO1xuICAgIGxldCBpZHggPSBhZGRyID4+IDE7XG4gICAgbGV0IHN0YXR1cyA9IHN0YXRlLnN0YXR1c1tpZHhdO1xuICAgIGlmIChzdGF0dXMgPT0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGljIGRlcGVuZGVuY3kgYmV0d2VlbiBmaWVsZHMgYW5kL29yIGZhY2V0c1wiKTtcbiAgICBpZiAoc3RhdHVzICYgMiAvKiBTbG90U3RhdHVzLkNvbXB1dGVkICovKVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIHN0YXRlLnN0YXR1c1tpZHhdID0gNCAvKiBTbG90U3RhdHVzLkNvbXB1dGluZyAqLztcbiAgICBsZXQgY2hhbmdlZCA9IHN0YXRlLmNvbXB1dGVTbG90KHN0YXRlLCBzdGF0ZS5jb25maWcuZHluYW1pY1Nsb3RzW2lkeF0pO1xuICAgIHJldHVybiBzdGF0ZS5zdGF0dXNbaWR4XSA9IDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLyB8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBnZXRBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgcmV0dXJuIGFkZHIgJiAxID8gc3RhdGUuY29uZmlnLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdIDogc3RhdGUudmFsdWVzW2FkZHIgPj4gMV07XG59XG5cbmNvbnN0IGxhbmd1YWdlRGF0YSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHYgPT4gdiksXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGxpbmVTZXBhcmF0b3IgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IHVuZGVmaW5lZCxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgY2hhbmdlRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25GaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkV4dGVuZGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgcmVhZE9ubHkgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IGZhbHNlXG59KTtcblxuLyoqXG5Bbm5vdGF0aW9ucyBhcmUgdGFnZ2VkIHZhbHVlcyB0aGF0IGFyZSB1c2VkIHRvIGFkZCBtZXRhZGF0YSB0b1xudHJhbnNhY3Rpb25zIGluIGFuIGV4dGVuc2libGUgd2F5LiBUaGV5IHNob3VsZCBiZSB1c2VkIHRvIG1vZGVsXG50aGluZ3MgdGhhdCBlZmZlY3QgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiAoc3VjaCBhcyBpdHMgW3RpbWVcbnN0YW1wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnRpbWUpIG9yIGluZm9ybWF0aW9uIGFib3V0IGl0c1xuW29yaWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpKS4gRm9yIGVmZmVjdHMgdGhhdCBoYXBwZW5cbl9hbG9uZ3NpZGVfIHRoZSBvdGhlciBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLCBbc3RhdGVcbmVmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGFyZSBtb3JlIGFwcHJvcHJpYXRlLlxuKi9cbmNsYXNzIEFubm90YXRpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGFubm90YXRpb24gdHlwZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyB0eXBlIG9mIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKCkgeyByZXR1cm4gbmV3IEFubm90YXRpb25UeXBlKCk7IH1cbn1cbi8qKlxuTWFya2VyIHRoYXQgaWRlbnRpZmllcyBhIHR5cGUgb2YgW2Fubm90YXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQW5ub3RhdGlvbikuXG4qL1xuY2xhc3MgQW5ub3RhdGlvblR5cGUge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGFubm90YXRpb24uXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IEFubm90YXRpb24odGhpcywgdmFsdWUpOyB9XG59XG4vKipcblJlcHJlc2VudGF0aW9uIG9mIGEgdHlwZSBvZiBzdGF0ZSBlZmZlY3QuIERlZmluZWQgd2l0aFxuW2BTdGF0ZUVmZmVjdC5kZWZpbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmRlZmluZSkuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3RUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBgYW55YCB0eXBlcyBpbiB0aGVzZSBmdW5jdGlvbiB0eXBlcyBhcmUgdGhlcmUgdG8gd29ya1xuICAgIC8vIGFyb3VuZCBUeXBlU2NyaXB0IGlzc3VlICMzNzYzMSwgd2hlcmUgdGhlIHR5cGUgZ3VhcmQgb25cbiAgICAvLyBgU3RhdGVFZmZlY3QuaXNgIG15c3RlcmlvdXNseSBzdG9wcyB3b3JraW5nIHdoZW4gdGhlc2UgcHJvcGVybHlcbiAgICAvLyBoYXZlIHR5cGUgYFZhbHVlYC5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3N0YXRlIGVmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgaW5zdGFuY2Ugb2YgdGhpc1xuICAgIHR5cGUuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkgeyByZXR1cm4gbmV3IFN0YXRlRWZmZWN0KHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5TdGF0ZSBlZmZlY3RzIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhZGRpdGlvbmFsIGVmZmVjdHNcbmFzc29jaWF0ZWQgd2l0aCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5lZmZlY3RzKS4gVGhleVxuYXJlIG9mdGVuIHVzZWZ1bCB0byBtb2RlbCBjaGFuZ2VzIHRvIGN1c3RvbSBbc3RhdGVcbmZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkKSwgd2hlbiB0aG9zZSBjaGFuZ2VzIGFyZW4ndCBpbXBsaWNpdCBpblxuZG9jdW1lbnQgb3Igc2VsZWN0aW9uIGNoYW5nZXMuXG4qL1xuY2xhc3MgU3RhdGVFZmZlY3Qge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBlZmZlY3QuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIGVmZmVjdCB0aHJvdWdoIGEgcG9zaXRpb24gbWFwcGluZy4gV2lsbCByZXR1cm5cbiAgICBgdW5kZWZpbmVkYCB3aGVuIHRoYXQgZW5kcyB1cCBkZWxldGluZyB0aGUgZWZmZWN0LlxuICAgICovXG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IHRoaXMudHlwZS5tYXAodGhpcy52YWx1ZSwgbWFwcGluZyk7XG4gICAgICAgIHJldHVybiBtYXBwZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1hcHBlZCA9PSB0aGlzLnZhbHVlID8gdGhpcyA6IG5ldyBTdGF0ZUVmZmVjdCh0aGlzLnR5cGUsIG1hcHBlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgZWZmZWN0IG9iamVjdCBpcyBvZiBhIGdpdmVuXG4gICAgW3R5cGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RUeXBlKS5cbiAgICAqL1xuICAgIGlzKHR5cGUpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlOyB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IGVmZmVjdCB0eXBlLiBUaGUgdHlwZSBwYXJhbWV0ZXIgaW5kaWNhdGVzIHRoZSB0eXBlXG4gICAgb2YgdmFsdWVzIHRoYXQgaGlzIGVmZmVjdCBob2xkcy4gSXQgc2hvdWxkIGJlIGEgdHlwZSB0aGF0XG4gICAgZG9lc24ndCBpbmNsdWRlIGB1bmRlZmluZWRgLCBzaW5jZSB0aGF0IGlzIHVzZWQgaW5cbiAgICBbbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRvIGluZGljYXRlIHRoYXQgYW4gZWZmZWN0IGlzXG4gICAgcmVtb3ZlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVFZmZlY3RUeXBlKHNwZWMubWFwIHx8ICh2ID0+IHYpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFwRWZmZWN0cyhlZmZlY3RzLCBtYXBwaW5nKSB7XG4gICAgICAgIGlmICghZWZmZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgZWZmZWN0cykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGVmZmVjdC5tYXAobWFwcGluZyk7XG4gICAgICAgICAgICBpZiAobWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoaXMgZWZmZWN0IGNhbiBiZSB1c2VkIHRvIHJlY29uZmlndXJlIHRoZSByb290IGV4dGVuc2lvbnMgb2ZcbnRoZSBlZGl0b3IuIERvaW5nIHRoaXMgd2lsbCBkaXNjYXJkIGFueSBleHRlbnNpb25zXG5bYXBwZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReYXBwZW5kQ29uZmlnKSwgYnV0IGRvZXMgbm90IHJlc2V0XG50aGUgY29udGVudCBvZiBbcmVjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50LnJlY29uZmlndXJlKVxuY29tcGFydG1lbnRzLlxuKi9cblN0YXRlRWZmZWN0LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5BcHBlbmQgZXh0ZW5zaW9ucyB0byB0aGUgdG9wLWxldmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGVkaXRvci5cbiovXG5TdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkNoYW5nZXMgdG8gdGhlIGVkaXRvciBzdGF0ZSBhcmUgZ3JvdXBlZCBpbnRvIHRyYW5zYWN0aW9ucy5cblR5cGljYWxseSwgYSB1c2VyIGFjdGlvbiBjcmVhdGVzIGEgc2luZ2xlIHRyYW5zYWN0aW9uLCB3aGljaCBtYXlcbmNvbnRhaW4gYW55IG51bWJlciBvZiBkb2N1bWVudCBjaGFuZ2VzLCBtYXkgY2hhbmdlIHRoZSBzZWxlY3Rpb24sXG5vciBoYXZlIG90aGVyIGVmZmVjdHMuIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGJ5IGNhbGxpbmdcbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpLCBvciBpbW1lZGlhdGVseVxuZGlzcGF0Y2ggb25lIGJ5IGNhbGxpbmdcbltgRWRpdG9yVmlldy5kaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKS5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXRlIGZyb20gd2hpY2ggdGhlIHRyYW5zYWN0aW9uIHN0YXJ0cy5cbiAgICAqL1xuICAgIHN0YXJ0U3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBjaGFuZ2VzIG1hZGUgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGNoYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24gc2V0IGJ5IHRoaXMgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiBpdFxuICAgIGRvZXNuJ3QgZXhwbGljaXRseSBzZXQgYSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIFRoZSBlZmZlY3RzIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGVmZmVjdHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYW5ub3RhdGlvbnMsIFxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIHRoaXNcbiAgICB0cmFuc2FjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvYyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBjaGFuZ2VzLm5ld0xlbmd0aCk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMuc29tZSgoYSkgPT4gYS50eXBlID09IFRyYW5zYWN0aW9uLnRpbWUpKVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi50aW1lLm9mKERhdGUubm93KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oc3RhcnRTdGF0ZSwgY2hhbmdlcywgc2VsZWN0aW9uLCBlZmZlY3RzLCBhbm5vdGF0aW9ucywgc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29udHJhcnkgdG9cbiAgICBbYC5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpYC5kb2NgLCBhY2Nlc3NpbmcgdGhpcyB3b24ndFxuICAgIGZvcmNlIHRoZSBlbnRpcmUgbmV3IHN0YXRlIHRvIGJlIGNvbXB1dGVkIHJpZ2h0IGF3YXksIHNvIGl0IGlzXG4gICAgcmVjb21tZW5kZWQgdGhhdCBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB1c2UgdGhpcyBnZXR0ZXJcbiAgICB3aGVuIHRoZXkgbmVlZCB0byBsb29rIGF0IHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgbmV3RG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jIHx8ICh0aGlzLl9kb2MgPSB0aGlzLmNoYW5nZXMuYXBwbHkodGhpcy5zdGFydFN0YXRlLmRvYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHNlbGVjdGlvbiBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIElmXG4gICAgW2B0aGlzLnNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2VsZWN0aW9uKSBpcyB1bmRlZmluZWQsXG4gICAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcbiAgICBjdXJyZW50IHNlbGVjdGlvbiB0aHJvdWdoIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uIHx8IHRoaXMuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFwKHRoaXMuY2hhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBuZXcgc3RhdGUgY3JlYXRlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbXB1dGVkIG9uIGRlbWFuZFxuICAgIChidXQgcmV0YWluZWQgZm9yIHN1YnNlcXVlbnQgYWNjZXNzKSwgc28gaXQgaXMgcmVjb21tZW5kZWQgbm90IHRvXG4gICAgYWNjZXNzIGl0IGluIFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHdoZW4gcG9zc2libGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhbm5vdGF0aW9uIHR5cGUsIGlmIGFueS5cbiAgICAqL1xuICAgIGFubm90YXRpb24odHlwZSkge1xuICAgICAgICBmb3IgKGxldCBhbm4gb2YgdGhpcy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgIGlmIChhbm4udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbm4udmFsdWU7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2VkIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkgeyByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgdHJhbnNhY3Rpb24gcmVjb25maWd1cmVzIHRoZSBzdGF0ZVxuICAgICh0aHJvdWdoIGEgW2NvbmZpZ3VyYXRpb24gY29tcGFydG1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQpIG9yXG4gICAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXG4gICAgW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5yZWNvbmZpZ3VyZSkuXG4gICAgKi9cbiAgICBnZXQgcmVjb25maWd1cmVkKCkgeyByZXR1cm4gdGhpcy5zdGFydFN0YXRlLmNvbmZpZyAhPSB0aGlzLnN0YXRlLmNvbmZpZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgW3VzZXJcbiAgICBldmVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpIGFubm90YXRpb24gdGhhdCBpcyBlcXVhbCB0b1xuICAgIG9yIG1vcmUgc3BlY2lmaWMgdGhhbiBgZXZlbnRgLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRyYW5zYWN0aW9uXG4gICAgaGFzIGBcInNlbGVjdC5wb2ludGVyXCJgIGFzIHVzZXIgZXZlbnQsIGBcInNlbGVjdFwiYCBhbmRcbiAgICBgXCJzZWxlY3QucG9pbnRlclwiYCB3aWxsIG1hdGNoIGl0LlxuICAgICovXG4gICAgaXNVc2VyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgcmV0dXJuICEhKGUgJiYgKGUgPT0gZXZlbnQgfHwgZS5sZW5ndGggPiBldmVudC5sZW5ndGggJiYgZS5zbGljZSgwLCBldmVudC5sZW5ndGgpID09IGV2ZW50ICYmIGVbZXZlbnQubGVuZ3RoXSA9PSBcIi5cIikpO1xuICAgIH1cbn1cbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIHN0b3JlIHRyYW5zYWN0aW9uIHRpbWVzdGFtcHMuIEF1dG9tYXRpY2FsbHlcbmFkZGVkIHRvIGV2ZXJ5IHRyYW5zYWN0aW9uLCBob2xkaW5nIGBEYXRlLm5vdygpYC5cbiovXG5UcmFuc2FjdGlvbi50aW1lID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBhc3NvY2lhdGUgYSB0cmFuc2FjdGlvbiB3aXRoIGEgdXNlciBpbnRlcmZhY2VcbmV2ZW50LiBIb2xkcyBhIHN0cmluZyBpZGVudGlmeWluZyB0aGUgZXZlbnQsIHVzaW5nIGFcbmRvdC1zZXBhcmF0ZWQgZm9ybWF0IHRvIHN1cHBvcnQgYXR0YWNoaW5nIG1vcmUgc3BlY2lmaWNcbmluZm9ybWF0aW9uLiBUaGUgZXZlbnRzIHVzZWQgYnkgdGhlIGNvcmUgbGlicmFyaWVzIGFyZTpcblxuIC0gYFwiaW5wdXRcImAgd2hlbiBjb250ZW50IGlzIGVudGVyZWRcbiAgIC0gYFwiaW5wdXQudHlwZVwiYCBmb3IgdHlwZWQgaW5wdXRcbiAgICAgLSBgXCJpbnB1dC50eXBlLmNvbXBvc2VcImAgZm9yIGNvbXBvc2l0aW9uXG4gICAtIGBcImlucHV0LnBhc3RlXCJgIGZvciBwYXN0ZWQgaW5wdXRcbiAgIC0gYFwiaW5wdXQuZHJvcFwiYCB3aGVuIGFkZGluZyBjb250ZW50IHdpdGggZHJhZy1hbmQtZHJvcFxuICAgLSBgXCJpbnB1dC5jb21wbGV0ZVwiYCB3aGVuIGF1dG9jb21wbGV0aW5nXG4gLSBgXCJkZWxldGVcImAgd2hlbiB0aGUgdXNlciBkZWxldGVzIGNvbnRlbnRcbiAgIC0gYFwiZGVsZXRlLnNlbGVjdGlvblwiYCB3aGVuIGRlbGV0aW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmZvcndhcmRcImAgd2hlbiBkZWxldGluZyBmb3J3YXJkIGZyb20gdGhlIHNlbGVjdGlvblxuICAgLSBgXCJkZWxldGUuYmFja3dhcmRcImAgd2hlbiBkZWxldGluZyBiYWNrd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmN1dFwiYCB3aGVuIGN1dHRpbmcgdG8gdGhlIGNsaXBib2FyZFxuIC0gYFwibW92ZVwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWRcbiAgIC0gYFwibW92ZS5kcm9wXCJgIHdoZW4gY29udGVudCBpcyBtb3ZlZCB3aXRoaW4gdGhlIGVkaXRvciB0aHJvdWdoIGRyYWctYW5kLWRyb3BcbiAtIGBcInNlbGVjdFwiYCB3aGVuIGV4cGxpY2l0bHkgY2hhbmdpbmcgdGhlIHNlbGVjdGlvblxuICAgLSBgXCJzZWxlY3QucG9pbnRlclwiYCB3aGVuIHNlbGVjdGluZyB3aXRoIGEgbW91c2Ugb3Igb3RoZXIgcG9pbnRpbmcgZGV2aWNlXG4gLSBgXCJ1bmRvXCJgIGFuZCBgXCJyZWRvXCJgIGZvciBoaXN0b3J5IGFjdGlvbnNcblxuVXNlIFtgaXNVc2VyRXZlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmlzVXNlckV2ZW50KSB0byBjaGVja1xud2hldGhlciB0aGUgYW5ub3RhdGlvbiBtYXRjaGVzIGEgZ2l2ZW4gZXZlbnQuXG4qL1xuVHJhbnNhY3Rpb24udXNlckV2ZW50ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyB3aGV0aGVyIGEgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdW5kbyBoaXN0b3J5IG9yIG5vdC5cbiovXG5UcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuQW5ub3RhdGlvbiBpbmRpY2F0aW5nICh3aGVuIHByZXNlbnQgYW5kIHRydWUpIHRoYXQgYSB0cmFuc2FjdGlvblxucmVwcmVzZW50cyBhIGNoYW5nZSBtYWRlIGJ5IHNvbWUgb3RoZXIgYWN0b3IsIG5vdCB0aGUgdXNlci4gVGhpc1xuaXMgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIHRhZyBvdGhlciBwZW9wbGUncyBjaGFuZ2VzIGluXG5jb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4qL1xuVHJhbnNhY3Rpb24ucmVtb3RlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBqb2luUmFuZ2VzKGEsIGIpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmIChpQSA8IGEubGVuZ3RoICYmIChpQiA9PSBiLmxlbmd0aCB8fCBiW2lCXSA+PSBhW2lBXSkpIHtcbiAgICAgICAgICAgIGZyb20gPSBhW2lBKytdO1xuICAgICAgICAgICAgdG8gPSBhW2lBKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlCIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyb20gPSBiW2lCKytdO1xuICAgICAgICAgICAgdG8gPSBiW2lCKytdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCB8fCByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdIDwgZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IHRvKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVHJhbnNhY3Rpb24oYSwgYiwgc2VxdWVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbWFwRm9yQSwgbWFwRm9yQiwgY2hhbmdlcztcbiAgICBpZiAoc2VxdWVudGlhbCkge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzO1xuICAgICAgICBtYXBGb3JCID0gQ2hhbmdlU2V0LmVtcHR5KGIuY2hhbmdlcy5sZW5ndGgpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UoYi5jaGFuZ2VzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcEZvckEgPSBiLmNoYW5nZXMubWFwKGEuY2hhbmdlcyk7XG4gICAgICAgIG1hcEZvckIgPSBhLmNoYW5nZXMubWFwRGVzYyhiLmNoYW5nZXMsIHRydWUpO1xuICAgICAgICBjaGFuZ2VzID0gYS5jaGFuZ2VzLmNvbXBvc2UobWFwRm9yQSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXMsXG4gICAgICAgIHNlbGVjdGlvbjogYi5zZWxlY3Rpb24gPyBiLnNlbGVjdGlvbi5tYXAobWFwRm9yQikgOiAoX2EgPSBhLnNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChtYXBGb3JBKSxcbiAgICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhLmVmZmVjdHMsIG1hcEZvckEpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGIuZWZmZWN0cywgbWFwRm9yQikpLFxuICAgICAgICBhbm5vdGF0aW9uczogYS5hbm5vdGF0aW9ucy5sZW5ndGggPyBhLmFubm90YXRpb25zLmNvbmNhdChiLmFubm90YXRpb25zKSA6IGIuYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiBhLnNjcm9sbEludG9WaWV3IHx8IGIuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWMsIGRvY1NpemUpIHtcbiAgICBsZXQgc2VsID0gc3BlYy5zZWxlY3Rpb24sIGFubm90YXRpb25zID0gYXNBcnJheShzcGVjLmFubm90YXRpb25zKTtcbiAgICBpZiAoc3BlYy51c2VyRXZlbnQpXG4gICAgICAgIGFubm90YXRpb25zID0gYW5ub3RhdGlvbnMuY29uY2F0KFRyYW5zYWN0aW9uLnVzZXJFdmVudC5vZihzcGVjLnVzZXJFdmVudCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IHNwZWMuY2hhbmdlcyBpbnN0YW5jZW9mIENoYW5nZVNldCA/IHNwZWMuY2hhbmdlc1xuICAgICAgICAgICAgOiBDaGFuZ2VTZXQub2Yoc3BlYy5jaGFuZ2VzIHx8IFtdLCBkb2NTaXplLCBzdGF0ZS5mYWNldChsaW5lU2VwYXJhdG9yKSksXG4gICAgICAgIHNlbGVjdGlvbjogc2VsICYmIChzZWwgaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBzZWwgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHNlbC5hbmNob3IsIHNlbC5oZWFkKSksXG4gICAgICAgIGVmZmVjdHM6IGFzQXJyYXkoc3BlYy5lZmZlY3RzKSxcbiAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgIHNjcm9sbEludG9WaWV3OiAhIXNwZWMuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBzcGVjcywgZmlsdGVyKSB7XG4gICAgbGV0IHMgPSByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3MubGVuZ3RoID8gc3BlY3NbMF0gOiB7fSwgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgaWYgKHNwZWNzLmxlbmd0aCAmJiBzcGVjc1swXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICBmaWx0ZXIgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwZWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzcGVjc1tpXS5maWx0ZXIgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXEgPSAhIXNwZWNzW2ldLnNlcXVlbnRpYWw7XG4gICAgICAgIHMgPSBtZXJnZVRyYW5zYWN0aW9uKHMsIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjc1tpXSwgc2VxID8gcy5jaGFuZ2VzLm5ld0xlbmd0aCA6IHN0YXRlLmRvYy5sZW5ndGgpLCBzZXEpO1xuICAgIH1cbiAgICBsZXQgdHIgPSBUcmFuc2FjdGlvbi5jcmVhdGUoc3RhdGUsIHMuY2hhbmdlcywgcy5zZWxlY3Rpb24sIHMuZWZmZWN0cywgcy5hbm5vdGF0aW9ucywgcy5zY3JvbGxJbnRvVmlldyk7XG4gICAgcmV0dXJuIGV4dGVuZFRyYW5zYWN0aW9uKGZpbHRlciA/IGZpbHRlclRyYW5zYWN0aW9uKHRyKSA6IHRyKTtcbn1cbi8vIEZpbmlzaCBhIHRyYW5zYWN0aW9uIGJ5IGFwcGx5aW5nIGZpbHRlcnMgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gZmlsdGVyVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlO1xuICAgIC8vIENoYW5nZSBmaWx0ZXJzXG4gICAgbGV0IHJlc3VsdCA9IHRydWU7XG4gICAgZm9yIChsZXQgZmlsdGVyIG9mIHN0YXRlLmZhY2V0KGNoYW5nZUZpbHRlcikpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZmlsdGVyKHRyKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHRydWUgPyB2YWx1ZSA6IGpvaW5SYW5nZXMocmVzdWx0LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMsIGJhY2s7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBiYWNrID0gdHIuY2hhbmdlcy5pbnZlcnRlZERlc2M7XG4gICAgICAgICAgICBjaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZpbHRlcmVkID0gdHIuY2hhbmdlcy5maWx0ZXIocmVzdWx0KTtcbiAgICAgICAgICAgIGNoYW5nZXMgPSBmaWx0ZXJlZC5jaGFuZ2VzO1xuICAgICAgICAgICAgYmFjayA9IGZpbHRlcmVkLmZpbHRlcmVkLm1hcERlc2MoZmlsdGVyZWQuY2hhbmdlcykuaW52ZXJ0ZWREZXNjO1xuICAgICAgICB9XG4gICAgICAgIHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBjaGFuZ2VzLCB0ci5zZWxlY3Rpb24gJiYgdHIuc2VsZWN0aW9uLm1hcChiYWNrKSwgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyh0ci5lZmZlY3RzLCBiYWNrKSwgdHIuYW5ub3RhdGlvbnMsIHRyLnNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLy8gVHJhbnNhY3Rpb24gZmlsdGVyc1xuICAgIGxldCBmaWx0ZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25GaWx0ZXIpO1xuICAgIGZvciAobGV0IGkgPSBmaWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IGZpbHRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZmlsdGVyZWQgaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWQ7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyZWQpICYmIGZpbHRlcmVkLmxlbmd0aCA9PSAxICYmIGZpbHRlcmVkWzBdIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ciA9IHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgYXNBcnJheShmaWx0ZXJlZCksIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuZnVuY3Rpb24gZXh0ZW5kVHJhbnNhY3Rpb24odHIpIHtcbiAgICBsZXQgc3RhdGUgPSB0ci5zdGFydFN0YXRlLCBleHRlbmRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkV4dGVuZGVyKSwgc3BlYyA9IHRyO1xuICAgIGZvciAobGV0IGkgPSBleHRlbmRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuZGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChleHRlbnNpb24gJiYgT2JqZWN0LmtleXMoZXh0ZW5zaW9uKS5sZW5ndGgpXG4gICAgICAgICAgICBzcGVjID0gbWVyZ2VUcmFuc2FjdGlvbihzcGVjLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgZXh0ZW5zaW9uLCB0ci5jaGFuZ2VzLm5ld0xlbmd0aCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBub25lIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8qKlxuVGhlIGNhdGVnb3JpZXMgcHJvZHVjZWQgYnkgYSBbY2hhcmFjdGVyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxuZG8gdGhpbmdzIGxpa2Ugc2VsZWN0aW5nIGJ5IHdvcmQuXG4qL1xudmFyIENoYXJDYXRlZ29yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xuICAgIC8qKlxuICAgIFdvcmQgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICAvKipcbiAgICBXaGl0ZXNwYWNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIlNwYWNlXCJdID0gMV0gPSBcIlNwYWNlXCI7XG4gICAgLyoqXG4gICAgQW55dGhpbmcgZWxzZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xucmV0dXJuIENoYXJDYXRlZ29yeX0pKENoYXJDYXRlZ29yeSB8fCAoQ2hhckNhdGVnb3J5ID0ge30pKTtcbmNvbnN0IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vO1xubGV0IHdvcmRDaGFyO1xudHJ5IHtcbiAgICB3b3JkQ2hhciA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmZ1bmN0aW9uIGhhc1dvcmRDaGFyKHN0cikge1xuICAgIGlmICh3b3JkQ2hhcilcbiAgICAgICAgcmV0dXJuIHdvcmRDaGFyLnRlc3Qoc3RyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XG4gICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIChjaGFyKSA9PiB7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuU3BhY2U7XG4gICAgICAgIGlmIChoYXNXb3JkQ2hhcihjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hhci5pbmRleE9mKHdvcmRDaGFyc1tpXSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuT3RoZXI7XG4gICAgfTtcbn1cblxuLyoqXG5UaGUgZWRpdG9yIHN0YXRlIGNsYXNzIGlzIGEgcGVyc2lzdGVudCAoaW1tdXRhYmxlKSBkYXRhIHN0cnVjdHVyZS5cblRvIHVwZGF0ZSBhIHN0YXRlLCB5b3UgW2NyZWF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpIGFcblt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbiksIHdoaWNoIHByb2R1Y2VzIGEgX25ld18gc3RhdGVcbmluc3RhbmNlLCB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuXG5BcyBzdWNoLCBfbmV2ZXJfIG11dGF0ZSBwcm9wZXJ0aWVzIG9mIGEgc3RhdGUgZGlyZWN0bHkuIFRoYXQnbGxcbmp1c3QgYnJlYWsgdGhpbmdzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbmZpZywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHNlbGVjdGlvbiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWx1ZXMsIGNvbXB1dGVTbG90LCB0cikge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBjb25maWcuc3RhdHVzVGVtcGxhdGUuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jb21wdXRlU2xvdCA9IGNvbXB1dGVTbG90O1xuICAgICAgICAvLyBGaWxsIGluIHRoZSBjb21wdXRlZCBzdGF0ZSBpbW1lZGlhdGVseSwgc28gdGhhdCBmdXJ0aGVyIHF1ZXJpZXNcbiAgICAgICAgLy8gZm9yIGl0IG1hZGUgZHVyaW5nIHRoZSB1cGRhdGUgcmV0dXJuIHRoaXMgc3RhdGVcbiAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgdHIuX3N0YXRlID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5keW5hbWljU2xvdHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGkgPDwgMSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBudWxsO1xuICAgIH1cbiAgICBmaWVsZChmaWVsZCwgcmVxdWlyZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZpZWxkLmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGaWVsZCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSB0aGF0IHVwZGF0ZXMgdGhpc1xuICAgIHN0YXRlLiBBbnkgbnVtYmVyIG9mIFt0cmFuc2FjdGlvbiBzcGVjc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpXG4gICAgY2FuIGJlIHBhc3NlZC4gVW5sZXNzXG4gICAgW2BzZXF1ZW50aWFsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VxdWVudGlhbCkgaXMgc2V0LCB0aGVcbiAgICBbY2hhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuY2hhbmdlcykgKGlmIGFueSkgb2YgZWFjaCBzcGVjXG4gICAgYXJlIGFzc3VtZWQgdG8gc3RhcnQgaW4gdGhlIF9jdXJyZW50XyBkb2N1bWVudCAobm90IHRoZSBkb2N1bWVudFxuICAgIHByb2R1Y2VkIGJ5IHByZXZpb3VzIHNwZWNzKSwgYW5kIGl0c1xuICAgIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgYW5kXG4gICAgW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIGFyZSBhc3N1bWVkIHRvIHJlZmVyXG4gICAgdG8gdGhlIGRvY3VtZW50IGNyZWF0ZWQgYnkgaXRzIF9vd25fIGNoYW5nZXMuIFRoZSByZXN1bHRpbmdcbiAgICB0cmFuc2FjdGlvbiBjb250YWlucyB0aGUgY29tYmluZWQgZWZmZWN0IG9mIGFsbCB0aGUgZGlmZmVyZW50XG4gICAgc3BlY3MuIEZvciBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pLCBsYXRlclxuICAgIHNwZWNzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGVhcmxpZXIgb25lcy5cbiAgICAqL1xuICAgIHVwZGF0ZSguLi5zcGVjcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVRyYW5zYWN0aW9uKHRoaXMsIHNwZWNzLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHRyKSB7XG4gICAgICAgIGxldCBjb25mID0gdGhpcy5jb25maWcsIHsgYmFzZSwgY29tcGFydG1lbnRzIH0gPSBjb25mO1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhDb21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZikge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMgPSBuZXcgTWFwO1xuICAgICAgICAgICAgICAgICAgICBjb25mLmNvbXBhcnRtZW50cy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gY29tcGFydG1lbnRzLnNldChrZXksIHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tcGFydG1lbnRzLnNldChlZmZlY3QudmFsdWUuY29tcGFydG1lbnQsIGVmZmVjdC52YWx1ZS5leHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJhc2UgPSBhc0FycmF5KGJhc2UpLmNvbmNhdChlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFZhbHVlcztcbiAgICAgICAgaWYgKCFjb25mKSB7XG4gICAgICAgICAgICBjb25mID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgdGhpcyk7XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdGhpcy5kb2MsIHRoaXMuc2VsZWN0aW9uLCBjb25mLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5yZWNvbmZpZ3VyZShzdGF0ZSwgdGhpcyksIG51bGwpO1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSBpbnRlcm1lZGlhdGVTdGF0ZS52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHRyLnN0YXJ0U3RhdGUudmFsdWVzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRyLnN0YXJ0U3RhdGUuZmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpID8gdHIubmV3U2VsZWN0aW9uIDogdHIubmV3U2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIG5ldyBFZGl0b3JTdGF0ZShjb25mLCB0ci5uZXdEb2MsIHNlbGVjdGlvbiwgc3RhcnRWYWx1ZXMsIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC51cGRhdGUoc3RhdGUsIHRyKSwgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIHRvVGV4dChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRleHQub2Yoc3RyaW5nLnNwbGl0KHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLlxuICAgICovXG4gICAgc2xpY2VEb2MoZnJvbSA9IDAsIHRvID0gdGhpcy5kb2MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgdGhpcy5saW5lQnJlYWspO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgICAqL1xuICAgIGZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmYWNldC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFjZXQuZGVmYXVsdDtcbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQsIHlvdSBjYW4gcGFzcyB0aGVtIGluIGFzIGFuIG9iamVjdFxuICAgIG1hcHBpbmcgcHJvcGVydHkgbmFtZXMgKGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LCB3aGljaCBzaG91bGRcbiAgICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICAgKi9cbiAgICB0b0pTT04oZmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGZpZWxkcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmllbGRzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0YXRlRmllbGQgJiYgdGhpcy5jb25maWcuYWRkcmVzc1t2YWx1ZS5pZF0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdLCB2YWx1ZSA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgIGRvYzoganNvbi5kb2MsXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnNlbGVjdGlvbiksXG4gICAgICAgICAgICBleHRlbnNpb25zOiBjb25maWcuZXh0ZW5zaW9ucyA/IGZpZWxkSW5pdC5jb25jYXQoW2NvbmZpZy5leHRlbnNpb25zXSkgOiBmaWVsZEluaXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZS4gWW91J2xsIHVzdWFsbHkgb25seSBuZWVkIHRoaXMgd2hlblxuICAgIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICAgIHRyYW5zYWN0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgbGV0IGNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uLnJlc29sdmUoY29uZmlnLmV4dGVuc2lvbnMgfHwgW10sIG5ldyBNYXApO1xuICAgICAgICBsZXQgZG9jID0gY29uZmlnLmRvYyBpbnN0YW5jZW9mIFRleHQgPyBjb25maWcuZG9jXG4gICAgICAgICAgICA6IFRleHQub2YoKGNvbmZpZy5kb2MgfHwgXCJcIikuc3BsaXQoY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICFjb25maWcuc2VsZWN0aW9uID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSgwKVxuICAgICAgICAgICAgOiBjb25maWcuc2VsZWN0aW9uIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gY29uZmlnLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShjb25maWcuc2VsZWN0aW9uLmFuY2hvciwgY29uZmlnLnNlbGVjdGlvbi5oZWFkKTtcbiAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBkb2MubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSlcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKGNvbmZpZ3VyYXRpb24sIGRvYywgc2VsZWN0aW9uLCBjb25maWd1cmF0aW9uLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzdGF0ZSwgc2xvdCkgPT4gc2xvdC5jcmVhdGUoc3RhdGUpLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgKGluIGNvbHVtbnMpIG9mIGEgdGFiIGluIHRoZSBkb2N1bWVudCwgZGV0ZXJtaW5lZCBieVxuICAgIHRoZSBbYHRhYlNpemVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRhYlNpemUpIGZhY2V0LlxuICAgICovXG4gICAgZ2V0IHRhYlNpemUoKSB7IHJldHVybiB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLnRhYlNpemUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwcm9wZXIgW2xpbmUtYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvcilcbiAgICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBcIlxcblwiOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICAgIFtjb25maWd1cmVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnJlYWRPbmx5KSB0byBiZSByZWFkLW9ubHkuXG4gICAgKi9cbiAgICBnZXQgcmVhZE9ubHkoKSB7IHJldHVybiB0aGlzLmZhY2V0KHJlYWRPbmx5KTsgfVxuICAgIC8qKlxuICAgIExvb2sgdXAgYSB0cmFuc2xhdGlvbiBmb3IgdGhlIGdpdmVuIHBocmFzZSAodmlhIHRoZVxuICAgIFtgcGhyYXNlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVecGhyYXNlcykgZmFjZXQpLCBvciByZXR1cm4gdGhlXG4gICAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICAgIFxuICAgIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwYXNzZWQsIHRoZXkgd2lsbCBiZSBpbnNlcnRlZCBpblxuICAgIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICAgIEEgc2luZ2xlIGAkYCBpcyBlcXVpdmFsZW50IHRvIGAkMWAsIGFuZCBgJCRgIHdpbGwgcHJvZHVjZSBhXG4gICAgbGl0ZXJhbCBkb2xsYXIgc2lnbi5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UsIC4uLmluc2VydCkge1xuICAgICAgICBmb3IgKGxldCBtYXAgb2YgdGhpcy5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBwaHJhc2UpKSB7XG4gICAgICAgICAgICAgICAgcGhyYXNlID0gbWFwW3BocmFzZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnQubGVuZ3RoKVxuICAgICAgICAgICAgcGhyYXNlID0gcGhyYXNlLnJlcGxhY2UoL1xcJChcXCR8XFxkKikvZywgKG0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBcIiRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICAgICAgICAgIGxldCBuID0gKyhpIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhbiB8fCBuID4gaW5zZXJ0Lmxlbmd0aCA/IG0gOiBpbnNlcnRbbiAtIDFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgXG4gICAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gICAgXG4gICAgLSBbYFwiY29tbWVudFRva2Vuc1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBmb3Igc3BlY2lmeWluZ1xuICAgICAgY29tbWVudCBzeW50YXguXG4gICAgLSBbYFwiYXV0b2NvbXBsZXRlXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5hdXRvY29tcGxldGlvbl5jb25maWcub3ZlcnJpZGUpXG4gICAgICBmb3IgcHJvdmlkaW5nIGxhbmd1YWdlLXNwZWNpZmljIGNvbXBsZXRpb24gc291cmNlcy5cbiAgICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgICBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB3b3JkcyBpbiB0aGlzXG4gICAgICBsYW5ndWFnZS5cbiAgICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgICBicmFja2V0IGNsb3NpbmcgYmVoYXZpb3IuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKSlcbiAgICBpbnRvIG9uZSBvZjpcbiAgICBcbiAgICAgLSBXb3JkIChjb250YWlucyBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyIG9yIGEgY2hhcmFjdGVyXG4gICAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgICAgbGFuZ3VhZ2UgZGF0YSwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nKVxuICAgICAtIFNwYWNlIChjb250YWlucyBvbmx5IHdoaXRlc3BhY2UpXG4gICAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICAgKi9cbiAgICBjaGFyQ2F0ZWdvcml6ZXIoYXQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDYXRlZ29yaXplcih0aGlzLmxhbmd1YWdlRGF0YUF0KFwid29yZENoYXJzXCIsIGF0KS5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIG1lYW5pbmcgdGhlIHJhbmdlXG4gICAgY29udGFpbmluZyBhbGwgW3dvcmRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhckNhdGVnb3J5LldvcmQpIGNoYXJhY3RlcnNcbiAgICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICAgIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICovXG4gICAgd29yZEF0KHBvcykge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tLCBsZW5ndGggfSA9IHRoaXMuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgY2F0ID0gdGhpcy5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gZnJvbSwgZW5kID0gcG9zIC0gZnJvbTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UocHJldiwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN0YXJ0ID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgZW5kKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShlbmQsIG5leHQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVuZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09IGVuZCA/IG51bGwgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2Uoc3RhcnQgKyBmcm9tLCBlbmQgKyBmcm9tKTtcbiAgICB9XG59XG4vKipcbkEgZmFjZXQgdGhhdCwgd2hlbiBlbmFibGVkLCBjYXVzZXMgdGhlIGVkaXRvciB0byBhbGxvdyBtdWx0aXBsZVxucmFuZ2VzIHRvIGJlIHNlbGVjdGVkLiBCZSBjYXJlZnVsIHRob3VnaCwgYmVjYXVzZSBieSBkZWZhdWx0IHRoZVxuZWRpdG9yIHJlbGllcyBvbiB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24sIHdoaWNoIGNhbm5vdCBoYW5kbGVcbm11bHRpcGxlIHNlbGVjdGlvbnMuIEFuIGV4dGVuc2lvbiBsaWtlXG5bYGRyYXdTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuZHJhd1NlbGVjdGlvbikgY2FuIGJlIHVzZWQgdG8gbWFrZVxuc2Vjb25kYXJ5IHNlbGVjdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlci5cbiovXG5FZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zO1xuLyoqXG5Db25maWd1cmVzIHRoZSB0YWIgc2l6ZSB0byB1c2UgaW4gdGhpcyBzdGF0ZS4gVGhlIGZpcnN0XG4oaGlnaGVzdC1wcmVjZWRlbmNlKSB2YWx1ZSBvZiB0aGUgZmFjZXQgaXMgdXNlZC4gSWYgbm8gdmFsdWUgaXNcbmdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIDQuXG4qL1xuRWRpdG9yU3RhdGUudGFiU2l6ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogNFxufSk7XG4vKipcblRoZSBsaW5lIHNlcGFyYXRvciB0byB1c2UuIEJ5IGRlZmF1bHQsIGFueSBvZiBgXCJcXG5cImAsIGBcIlxcclxcblwiYFxuYW5kIGBcIlxcclwiYCBpcyB0cmVhdGVkIGFzIGEgc2VwYXJhdG9yIHdoZW4gc3BsaXR0aW5nIGxpbmVzLCBhbmRcbmxpbmVzIGFyZSBqb2luZWQgd2l0aCBgXCJcXG5cImAuXG5cbldoZW4geW91IGNvbmZpZ3VyZSBhIHZhbHVlIGhlcmUsIG9ubHkgdGhhdCBwcmVjaXNlIHNlcGFyYXRvclxud2lsbCBiZSB1c2VkLCBhbGxvd2luZyB5b3UgdG8gcm91bmQtdHJpcCBkb2N1bWVudHMgdGhyb3VnaCB0aGVcbmVkaXRvciB3aXRob3V0IG5vcm1hbGl6aW5nIGxpbmUgc2VwYXJhdG9ycy5cbiovXG5FZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yID0gbGluZVNlcGFyYXRvcjtcbi8qKlxuVGhpcyBmYWNldCBjb250cm9scyB0aGUgdmFsdWUgb2YgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZ2V0dGVyLCB3aGljaCBpc1xuY29uc3VsdGVkIGJ5IGNvbW1hbmRzIGFuZCBleHRlbnNpb25zIHRoYXQgaW1wbGVtZW50IGVkaXRpbmdcbmZ1bmN0aW9uYWxpdHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBzaG91bGQgYXBwbHkuIEl0XG5kZWZhdWx0cyB0byBmYWxzZSwgYnV0IHdoZW4gaXRzIGhpZ2hlc3QtcHJlY2VkZW5jZSB2YWx1ZSBpc1xuYHRydWVgLCBzdWNoIGZ1bmN0aW9uYWxpdHkgZGlzYWJsZXMgaXRzZWxmLlxuXG5Ob3QgdG8gYmUgY29uZnVzZWQgd2l0aFxuW2BFZGl0b3JWaWV3LmVkaXRhYmxlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZWRpdGFibGUpLCB3aGljaFxuY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yJ3MgRE9NIGlzIHNldCB0byBiZSBlZGl0YWJsZSAoYW5kXG50aHVzIGZvY3VzYWJsZSkuXG4qL1xuRWRpdG9yU3RhdGUucmVhZE9ubHkgPSByZWFkT25seTtcbi8qKlxuUmVnaXN0ZXJzIHRyYW5zbGF0aW9uIHBocmFzZXMuIFRoZVxuW2BwaHJhc2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnBocmFzZSkgbWV0aG9kIHdpbGwgbG9vayB0aHJvdWdoXG5hbGwgb2JqZWN0cyByZWdpc3RlcmVkIHdpdGggdGhpcyBmYWNldCB0byBmaW5kIHRyYW5zbGF0aW9ucyBmb3Jcbml0cyBhcmd1bWVudC5cbiovXG5FZGl0b3JTdGF0ZS5waHJhc2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tcGFyZShhLCBiKSB7XG4gICAgICAgIGxldCBrQSA9IE9iamVjdC5rZXlzKGEpLCBrQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga0EubGVuZ3RoID09IGtCLmxlbmd0aCAmJiBrQS5ldmVyeShrID0+IGFba10gPT0gYltrXSk7XG4gICAgfVxufSk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlcnMgaW5kaWNhdGluZyB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhXG5yYW5nZS4gU28gZm9yIGV4YW1wbGUgYFsxMCwgMjAsIDEwMCwgMTEwXWAgc3VwcHJlc3NlcyBjaGFuZ2VzXG5iZXR3ZWVuIDEwIGFuZCAyMCwgYW5kIGJldHdlZW4gMTAwIGFuZCAxMTAuXG4qL1xuRWRpdG9yU3RhdGUuY2hhbmdlRmlsdGVyID0gY2hhbmdlRmlsdGVyO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGEgaG9vayB0aGF0IGdldHMgYSBjaGFuY2UgdG8gdXBkYXRlIG9yXG5yZXBsYWNlIHRyYW5zYWN0aW9uIHNwZWNzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLiBUaGlzIHdpbGxcbm9ubHkgYmUgYXBwbGllZCBmb3IgdHJhbnNhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZVxuW2BmaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpIHNldCB0byBgZmFsc2VgLiBZb3VcbmNhbiBlaXRoZXIgcmV0dXJuIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHNwZWMgKHBvc3NpYmx5IHRoZSBpbnB1dFxudHJhbnNhY3Rpb24pLCBvciBhbiBhcnJheSBvZiBzcGVjcyAod2hpY2ggd2lsbCBiZSBjb21iaW5lZCBpblxudGhlIHNhbWUgd2F5IGFzIHRoZSBhcmd1bWVudHMgdG9cbltgRWRpdG9yU3RhdGUudXBkYXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpKS5cblxuV2hlbiBwb3NzaWJsZSwgaXQgaXMgcmVjb21tZW5kZWQgdG8gYXZvaWQgYWNjZXNzaW5nXG5bYFRyYW5zYWN0aW9uLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSkgaW4gYSBmaWx0ZXIsXG5zaW5jZSBpdCB3aWxsIGZvcmNlIGNyZWF0aW9uIG9mIGEgc3RhdGUgdGhhdCB3aWxsIHRoZW4gYmVcbmRpc2NhcmRlZCBhZ2FpbiwgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIGFjdHVhbGx5IGZpbHRlcmVkLlxuXG4oVGhpcyBmdW5jdGlvbmFsaXR5IHNob3VsZCBiZSB1c2VkIHdpdGggY2FyZS4gSW5kaXNjcmltaW5hdGVseVxubW9kaWZ5aW5nIHRyYW5zYWN0aW9uIGlzIGxpa2VseSB0byBicmVhayBzb21ldGhpbmcgb3IgZGVncmFkZVxudGhlIHVzZXIgZXhwZXJpZW5jZS4pXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIgPSB0cmFuc2FjdGlvbkZpbHRlcjtcbi8qKlxuVGhpcyBpcyBhIG1vcmUgbGltaXRlZCBmb3JtIG9mXG5bYHRyYW5zYWN0aW9uRmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlciksXG53aGljaCBjYW4gb25seSBhZGRcblthbm5vdGF0aW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuYW5ub3RhdGlvbnMpIGFuZFxuW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpLiBfQnV0XywgdGhpcyB0eXBlXG5vZiBmaWx0ZXIgcnVucyBldmVuIGlmIHRoZSB0cmFuc2FjdGlvbiBoYXMgZGlzYWJsZWQgcmVndWxhclxuW2ZpbHRlcmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSwgbWFraW5nIGl0IHN1aXRhYmxlXG5mb3IgZWZmZWN0cyB0aGF0IGRvbid0IG5lZWQgdG8gdG91Y2ggdGhlIGNoYW5nZXMgb3Igc2VsZWN0aW9uLFxuYnV0IGRvIHdhbnQgdG8gcHJvY2VzcyBldmVyeSB0cmFuc2FjdGlvbi5cblxuRXh0ZW5kZXJzIHJ1biBfYWZ0ZXJfIGZpbHRlcnMsIHdoZW4gYm90aCBhcmUgcHJlc2VudC5cbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkV4dGVuZGVyID0gdHJhbnNhY3Rpb25FeHRlbmRlcjtcbkNvbXBhcnRtZW50LnJlY29uZmlndXJlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vKipcblV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbWJpbmluZyBiZWhhdmlvcnMgdG8gZmlsbCBpbiBhIGNvbmZpZ1xub2JqZWN0IGZyb20gYW4gYXJyYXkgb2YgcHJvdmlkZWQgY29uZmlncy4gYGRlZmF1bHRzYCBzaG91bGQgaG9sZFxuZGVmYXVsdCB2YWx1ZXMgZm9yIGFsbCBvcHRpb25hbCBmaWVsZHMgaW4gYENvbmZpZ2AuXG5cblRoZSBmdW5jdGlvbiB3aWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuRWFjaCByYW5nZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2YWx1ZSwgd2hpY2ggbXVzdCBpbmhlcml0IGZyb21cbnRoaXMgY2xhc3MuXG4qL1xuY2xhc3MgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICAgIHJhbmdlc2V0cy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgVW5sZXNzIHlvdSBhcmUgb25seSBjcmVhdGluZyBhIGZpeGVkIG51bWJlciBvZiB1bmlxdWUgaW5zdGFuY2VzXG4gICAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICAgIHByb3Blcmx5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMgPT0gb3RoZXI7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcmFuZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIHdpdGggdGhpcyB2YWx1ZS5cbiAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkgeyByZXR1cm4gUmFuZ2UuY3JlYXRlKGZyb20sIHRvLCB0aGlzKTsgfVxufVxuUmFuZ2VWYWx1ZS5wcm90b3R5cGUuc3RhcnRTaWRlID0gUmFuZ2VWYWx1ZS5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tEZWw7XG4vKipcbkEgcmFuZ2UgYXNzb2NpYXRlcyBhIHZhbHVlIHdpdGggYSByYW5nZSBvZiBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgSXRzIGVuZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFuZ2UuXG4gICAgKi9cbiAgICB2YWx1ZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIHRydWUpLCBlID0gdGhpcy5maW5kSW5kZXgodG8sIDEwMDAwMDAwMDAgLyogQy5GYXIgKi8sIGZhbHNlLCBpKTsgaSA8IGU7IGkrKylcbiAgICAgICAgICAgIGlmIChmKHRoaXMuZnJvbVtpXSArIG9mZnNldCwgdGhpcy50b1tpXSArIG9mZnNldCwgdGhpcy52YWx1ZVtpXSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKG9mZnNldCwgY2hhbmdlcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBbXSwgZnJvbSA9IFtdLCB0byA9IFtdLCBuZXdQb3MgPSAtMSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZVtpXSwgY3VyRnJvbSA9IHRoaXMuZnJvbVtpXSArIG9mZnNldCwgY3VyVG8gPSB0aGlzLnRvW2ldICsgb2Zmc2V0LCBuZXdGcm9tLCBuZXdUbztcbiAgICAgICAgICAgIGlmIChjdXJGcm9tID09IGN1clRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUsIHZhbC5tYXBNb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyA9IG1hcHBlZDtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnN0YXJ0U2lkZSAhPSB2YWwuZW5kU2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RvIDwgbmV3RnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0Zyb20gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBuZXdUbyA9IGNoYW5nZXMubWFwUG9zKGN1clRvLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Zyb20gPiBuZXdUbyB8fCBuZXdGcm9tID09IG5ld1RvICYmIHZhbC5zdGFydFNpZGUgPiAwICYmIHZhbC5lbmRTaWRlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChuZXdUbyAtIG5ld0Zyb20gfHwgdmFsLmVuZFNpZGUgLSB2YWwuc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAobmV3UG9zIDwgMClcbiAgICAgICAgICAgICAgICBuZXdQb3MgPSBuZXdGcm9tO1xuICAgICAgICAgICAgaWYgKHZhbC5wb2ludClcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBuZXdUbyAtIG5ld0Zyb20pO1xuICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpO1xuICAgICAgICAgICAgZnJvbS5wdXNoKG5ld0Zyb20gLSBuZXdQb3MpO1xuICAgICAgICAgICAgdG8ucHVzaChuZXdUbyAtIG5ld1Bvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFwcGVkOiB2YWx1ZS5sZW5ndGggPyBuZXcgQ2h1bmsoZnJvbSwgdG8sIHZhbHVlLCBtYXhQb2ludCkgOiBudWxsLCBwb3M6IG5ld1BvcyB9O1xuICAgIH1cbn1cbi8qKlxuQSByYW5nZSBzZXQgc3RvcmVzIGEgY29sbGVjdGlvbiBvZiBbcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBpbiBhXG53YXkgdGhhdCBtYWtlcyB0aGVtIGVmZmljaWVudCB0byBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0Lm1hcCkgYW5kXG5bdXBkYXRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0LnVwZGF0ZSkuIFRoaXMgaXMgYW4gaW1tdXRhYmxlIGRhdGFcbnN0cnVjdHVyZS5cbiovXG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua1BvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVuaywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBuZXh0TGF5ZXIsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmssIG5leHRMYXllciwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gbGFzdCA8IDAgPyAwIDogTWF0aC5tYXgodGhpcy5jaHVua0VuZChsYXN0KSwgdGhpcy5uZXh0TGF5ZXIubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiByYW5nZXMgaW4gdGhlIHNldC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5uZXh0TGF5ZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY2h1bmsgb2YgdGhpcy5jaHVuaylcbiAgICAgICAgICAgIHNpemUgKz0gY2h1bmsudmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaHVua0VuZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaHVua1Bvc1tpbmRleF0gKyB0aGlzLmNodW5rW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgcmFuZ2Ugc2V0LCBvcHRpb25hbGx5IGFkZGluZyBuZXcgcmFuZ2VzIG9yIGZpbHRlcmluZ1xuICAgIG91dCBleGlzdGluZyBvbmVzLlxuICAgIFxuICAgIChOb3RlOiBUaGUgdHlwZSBwYXJhbWV0ZXIgaXMganVzdCB0aGVyZSBhcyBhIGtsdWRnZSB0byB3b3JrXG4gICAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgICBmcm9tIGJlaW5nIGEgc3VidHlwZSBvZiBgUmFuZ2VTZXQ8WT5gIHdoZW4gYFhgIGlzIGEgc3VidHlwZSBvZlxuICAgIGBZYC4pXG4gICAgKi9cbiAgICB1cGRhdGUodXBkYXRlU3BlYykge1xuICAgICAgICBsZXQgeyBhZGQgPSBbXSwgc29ydCA9IGZhbHNlLCBmaWx0ZXJGcm9tID0gMCwgZmlsdGVyVG8gPSB0aGlzLmxlbmd0aCB9ID0gdXBkYXRlU3BlYztcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwZGF0ZVNwZWMuZmlsdGVyO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCA9PSAwICYmICFmaWx0ZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHNvcnQpXG4gICAgICAgICAgICBhZGQgPSBhZGQuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBhZGQubGVuZ3RoID8gUmFuZ2VTZXQub2YoYWRkKSA6IHRoaXM7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgTGF5ZXJDdXJzb3IodGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGkgPSAwLCBzcGlsbCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKGN1ci52YWx1ZSB8fCBpIDwgYWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgPCBhZGQubGVuZ3RoICYmIChjdXIuZnJvbSAtIGFkZFtpXS5mcm9tIHx8IGN1ci5zdGFydFNpZGUgLSBhZGRbaV0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gYWRkW2krK107XG4gICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnJhbmdlSW5kZXggPT0gMSAmJiBjdXIuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKGkgPT0gYWRkLmxlbmd0aCB8fCB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSA8IGFkZFtpXS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiB0aGlzLmNodW5rRW5kKGN1ci5jaHVua0luZGV4KSB8fCBmaWx0ZXJUbyA8IHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdKSAmJlxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkQ2h1bmsodGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbY3VyLmNodW5rSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGN1ci5uZXh0Q2h1bmsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlckZyb20gPiBjdXIudG8gfHwgZmlsdGVyVG8gPCBjdXIuZnJvbSB8fCBmaWx0ZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaWxsLnB1c2goUmFuZ2UuY3JlYXRlKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXIubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIXNwaWxsLmxlbmd0aCA/IFJhbmdlU2V0LmVtcHR5XG4gICAgICAgICAgICA6IHRoaXMubmV4dExheWVyLnVwZGF0ZSh7IGFkZDogc3BpbGwsIGZpbHRlciwgZmlsdGVyRnJvbSwgZmlsdGVyVG8gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICAgKi9cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSB8fCB0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNodW5rcyA9IFtdLCBjaHVua1BvcyA9IFtdLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGxldCB0b3VjaCA9IGNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0LCBzdGFydCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodG91Y2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKGNoYW5nZXMubWFwUG9zKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hcHBlZCwgcG9zIH0gPSBjaHVuay5tYXAoc3RhcnQsIGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbWFwcGVkLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dExheWVyLm1hcChjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIGNodW5rcy5sZW5ndGggPT0gMCA/IG5leHQgOiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rcywgbmV4dCB8fCBSYW5nZVNldC5lbXB0eSwgbWF4UG9pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyB0aGF0IHRvdWNoIHRoZSByZWdpb24gYGZyb21gIHRvIGB0b2AsXG4gICAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICAgIGJlIHJlcG9ydGVkIGluIGFueSBzcGVjaWZpYyBvcmRlci4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGBmYWxzZWAsIGl0ZXJhdGlvbiBzdG9wcy5cbiAgICAqL1xuICAgIGJldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBpZiAodG8gPj0gc3RhcnQgJiYgZnJvbSA8PSBzdGFydCArIGNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNodW5rLmJldHdlZW4oc3RhcnQsIGZyb20gLSBzdGFydCwgdG8gLSBzdGFydCwgZikgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRMYXllci5iZXR3ZWVuKGZyb20sIHRvLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gdGhpcyBzZXQsIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgICAqL1xuICAgIGl0ZXIoZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShbdGhpc10pLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7IHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgaW4gYSBjb2xsZWN0aW9uIG9mIHNldHMsIGluIG9yZGVyLFxuICAgIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAgICovXG4gICAgc3RhdGljIGl0ZXIoc2V0cywgZnJvbSA9IDApIHtcbiAgICAgICAgcmV0dXJuIEhlYXBDdXJzb3IuZnJvbShzZXRzKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdHdvIGdyb3VwcyBvZiBzZXRzLCBjYWxsaW5nIG1ldGhvZHMgb24gYGNvbXBhcmF0b3JgXG4gICAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUob2xkU2V0cywgbmV3U2V0cywgXG4gICAgLyoqXG4gICAgVGhpcyBpbmRpY2F0ZXMgaG93IHRoZSB1bmRlcmx5aW5nIGRhdGEgY2hhbmdlZCBiZXR3ZWVuIHRoZXNlXG4gICAgcmFuZ2VzLCBhbmQgaXMgbmVlZGVkIHRvIHN5bmNocm9uaXplIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICB0ZXh0RGlmZiwgY29tcGFyYXRvciwgXG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gaWdub3JlIGFsbCBub24tcG9pbnQgcmFuZ2VzLCBhbmQgcG9pbnRzIGJlbG93XG4gICAgdGhlIGdpdmVuIHNpemUuIFdoZW4gLTEsIGFsbCByYW5nZXMgYXJlIGNvbXBhcmVkLlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICB0ZXh0RGlmZi5pdGVyR2FwcygoZnJvbUEsIGZyb21CLCBsZW5ndGgpID0+IGNvbXBhcmUoc2lkZUEsIGZyb21BLCBzaWRlQiwgZnJvbUIsIGxlbmd0aCwgY29tcGFyYXRvcikpO1xuICAgICAgICBpZiAodGV4dERpZmYuZW1wdHkgJiYgdGV4dERpZmYubGVuZ3RoID09IDApXG4gICAgICAgICAgICBjb21wYXJlKHNpZGVBLCAwLCBzaWRlQiwgMCwgMCwgY29tcGFyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgICBpZiB0aGV5IGFyZSBlcXVpdmFsZW50IGluIHRoZSBnaXZlbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBlcShvbGRTZXRzLCBuZXdTZXRzLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi8gLSAxO1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgbmV3U2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG9sZFNldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgc2hhcmVkQ2h1bmtzID0gZmluZFNoYXJlZENodW5rcyhhLCBiKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pLCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvICE9IHNpZGVCLnRvIHx8XG4gICAgICAgICAgICAgICAgIXNhbWVWYWx1ZXMoc2lkZUEuYWN0aXZlLCBzaWRlQi5hY3RpdmUpIHx8XG4gICAgICAgICAgICAgICAgc2lkZUEucG9pbnQgJiYgKCFzaWRlQi5wb2ludCB8fCAhc2lkZUEucG9pbnQuZXEoc2lkZUIucG9pbnQpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gPiB0bylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpZGVBLm5leHQoKTtcbiAgICAgICAgICAgIHNpZGVCLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgYSBncm91cCBvZiByYW5nZSBzZXRzIGF0IHRoZSBzYW1lIHRpbWUsIG5vdGlmeWluZ1xuICAgIHRoZSBpdGVyYXRvciBhYm91dCB0aGUgcmFuZ2VzIGNvdmVyaW5nIGV2ZXJ5IGdpdmVuIHBpZWNlIG9mXG4gICAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXG4gICAgW2BTcGFuSXRlcmF0b3Iuc3BhbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3Bhbkl0ZXJhdG9yLnNwYW4pKSBhdCB0aGUgZW5kXG4gICAgb2YgdGhlIGl0ZXJhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBzcGFucyhzZXRzLCBmcm9tLCB0bywgaXRlcmF0b3IsIFxuICAgIC8qKlxuICAgIFdoZW4gZ2l2ZW4gYW5kIGdyZWF0ZXIgdGhhbiAtMSwgb25seSBwb2ludHMgb2YgYXQgbGVhc3QgdGhpc1xuICAgIHNpemUgYXJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgU3BhbkN1cnNvcihzZXRzLCBudWxsLCBtaW5Qb2ludFNpemUpLmdvdG8oZnJvbSksIHBvcyA9IGZyb207XG4gICAgICAgIGxldCBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5TdGFydDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGN1clRvID0gTWF0aC5taW4oY3Vyc29yLnRvLCB0byk7XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnBvaW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IGN1cnNvci5hY3RpdmVGb3JQb2ludChjdXJzb3IudG8pO1xuICAgICAgICAgICAgICAgIGxldCBvcGVuQ291bnQgPSBjdXJzb3IucG9pbnRGcm9tIDwgZnJvbSA/IGFjdGl2ZS5sZW5ndGggKyAxXG4gICAgICAgICAgICAgICAgICAgIDogY3Vyc29yLnBvaW50LnN0YXJ0U2lkZSA8IDAgPyBhY3RpdmUubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKGFjdGl2ZS5sZW5ndGgsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgYWN0aXZlLCBvcGVuQ291bnQsIGN1cnNvci5wb2ludFJhbmspO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBNYXRoLm1pbihjdXJzb3Iub3BlbkVuZChjdXJUbyksIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyVG8gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zcGFuKHBvcywgY3VyVG8sIGN1cnNvci5hY3RpdmUsIG9wZW5SYW5nZXMpO1xuICAgICAgICAgICAgICAgIG9wZW5SYW5nZXMgPSBjdXJzb3Iub3BlbkVuZChjdXJUbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5SYW5nZXMgKyAoY3Vyc29yLnBvaW50ICYmIGN1cnNvci50byA+IHRvID8gMSA6IDApO1xuICAgICAgICAgICAgcG9zID0gY3Vyc29yLnRvO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSByYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiByYW5nZSBvciBhcnJheSBvZiByYW5nZXMuIEJ5XG4gICAgZGVmYXVsdCwgdGhpcyBleHBlY3RzIHRoZSByYW5nZXMgdG8gYmUgX3NvcnRlZF8gKGJ5IHN0YXJ0XG4gICAgcG9zaXRpb24gYW5kLCBpZiB0d28gc3RhcnQgYXQgdGhlIHNhbWUgcG9zaXRpb24sXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApLiBZb3UgY2FuIHBhc3MgYHRydWVgIGFzIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGNhdXNlIHRoZSBtZXRob2QgdG8gc29ydCB0aGVtLlxuICAgICovXG4gICAgc3RhdGljIG9mKHJhbmdlcywgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgcmFuZ2VzIGluc3RhbmNlb2YgUmFuZ2UgPyBbcmFuZ2VzXSA6IHNvcnQgPyBsYXp5U29ydChyYW5nZXMpIDogcmFuZ2VzKVxuICAgICAgICAgICAgYnVpbGQuYWRkKHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiBhbiBhcnJheSBvZiByYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LlxuICAgICovXG4gICAgc3RhdGljIGpvaW4oc2V0cykge1xuICAgICAgICBpZiAoIXNldHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgICAgICBsZXQgcmVzdWx0ID0gc2V0c1tzZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKGxldCBpID0gc2V0cy5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZm9yIChsZXQgbGF5ZXIgPSBzZXRzW2ldOyBsYXllciAhPSBSYW5nZVNldC5lbXB0eTsgbGF5ZXIgPSBsYXllci5uZXh0TGF5ZXIpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFJhbmdlU2V0KGxheWVyLmNodW5rUG9zLCBsYXllci5jaHVuaywgcmVzdWx0LCBNYXRoLm1heChsYXllci5tYXhQb2ludCwgcmVzdWx0Lm1heFBvaW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgcmFuZ2VzLlxuKi9cblJhbmdlU2V0LmVtcHR5ID0gLypAX19QVVJFX18qL25ldyBSYW5nZVNldChbXSwgW10sIG51bGwsIC0xKTtcbmZ1bmN0aW9uIGxhenlTb3J0KHJhbmdlcykge1xuICAgIGlmIChyYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgZm9yIChsZXQgcHJldiA9IHJhbmdlc1swXSwgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSByYW5nZXNbaV07XG4gICAgICAgICAgICBpZiAoY21wUmFuZ2UocHJldiwgY3VyKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlcy5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG5SYW5nZVNldC5lbXB0eS5uZXh0TGF5ZXIgPSBSYW5nZVNldC5lbXB0eTtcbi8qKlxuQSByYW5nZSBzZXQgYnVpbGRlciBpcyBhIGRhdGEgc3RydWN0dXJlIHRoYXQgaGVscHMgYnVpbGQgdXAgYVxuW3JhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldCkgZGlyZWN0bHksIHdpdGhvdXQgZmlyc3QgYWxsb2NhdGluZ1xuYW4gYXJyYXkgb2YgW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpIG9iamVjdHMuXG4qL1xuY2xhc3MgUmFuZ2VTZXRCdWlsZGVyIHtcbiAgICBmaW5pc2hDaHVuayhuZXdBcnJheXMpIHtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChuZXcgQ2h1bmsodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnZhbHVlLCB0aGlzLm1heFBvaW50KSk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaCh0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIHRoaXMubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIGlmIChuZXdBcnJheXMpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5sYXN0VG8gPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSByYW5nZS4gUmFuZ2VzIHNob3VsZCBiZSBhZGRlZCBpbiBzb3J0ZWQgKGJ5IGBmcm9tYCBhbmRcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkgb3JkZXIuXG4gICAgKi9cbiAgICBhZGQoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5hZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpKVxuICAgICAgICAgICAgKHRoaXMubmV4dExheWVyIHx8ICh0aGlzLm5leHRMYXllciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIpKS5hZGQoZnJvbSwgdG8sIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRJbm5lcihmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSBmcm9tIC0gdGhpcy5sYXN0VG8gfHwgdmFsdWUuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGU7XG4gICAgICAgIGlmIChkaWZmIDw9IDAgJiYgKGZyb20gLSB0aGlzLmxhc3RGcm9tIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhbmdlcyBtdXN0IGJlIGFkZGVkIHNvcnRlZCBieSBgZnJvbWAgcG9zaXRpb24gYW5kIGBzdGFydFNpZGVgXCIpO1xuICAgICAgICBpZiAoZGlmZiA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoID09IDI1MCAvKiBDLkNodW5rU2l6ZSAqLylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5mcm9tLnB1c2goZnJvbSAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMudG8ucHVzaCh0byAtIHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMubGFzdCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlLnBvaW50KVxuICAgICAgICAgICAgdGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIHRvIC0gZnJvbSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZENodW5rKGZyb20sIGNodW5rKSB7XG4gICAgICAgIGlmICgoZnJvbSAtIHRoaXMubGFzdFRvIHx8IGNodW5rLnZhbHVlWzBdLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlKSA8IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MucHVzaChmcm9tKTtcbiAgICAgICAgbGV0IGxhc3QgPSBjaHVuay52YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICB0aGlzLmxhc3QgPSBjaHVuay52YWx1ZVtsYXN0XTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGNodW5rLmZyb21bbGFzdF0gKyBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IGNodW5rLnRvW2xhc3RdICsgZnJvbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmlzaCB0aGUgcmFuZ2Ugc2V0LiBSZXR1cm5zIHRoZSBuZXcgc2V0LiBUaGUgYnVpbGRlciBjYW4ndCBiZVxuICAgIHVzZWQgYW55bW9yZSBhZnRlciB0aGlzIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAqL1xuICAgIGZpbmlzaCgpIHsgcmV0dXJuIHRoaXMuZmluaXNoSW5uZXIoUmFuZ2VTZXQuZW1wdHkpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5pc2hJbm5lcihuZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmZyb20ubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gUmFuZ2VTZXQuY3JlYXRlKHRoaXMuY2h1bmtQb3MsIHRoaXMuY2h1bmtzLCB0aGlzLm5leHRMYXllciA/IHRoaXMubmV4dExheWVyLmZpbmlzaElubmVyKG5leHQpIDogbmV4dCwgdGhpcy5zZXRNYXhQb2ludCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IG51bGw7IC8vIE1ha2Ugc3VyZSBmdXJ0aGVyIGBhZGRgIGNhbGxzIHByb2R1Y2UgZXJyb3JzXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZFNoYXJlZENodW5rcyhhLCBiLCB0ZXh0RGlmZikge1xuICAgIGxldCBpbkEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGEpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldC5jaHVua1tpXS5tYXhQb2ludCA8PSAwKVxuICAgICAgICAgICAgICAgIGluQS5zZXQoc2V0LmNodW5rW2ldLCBzZXQuY2h1bmtQb3NbaV0pO1xuICAgIGxldCBzaGFyZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgc2V0IG9mIGIpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga25vd24gPSBpbkEuZ2V0KHNldC5jaHVua1tpXSk7XG4gICAgICAgICAgICBpZiAoa25vd24gIT0gbnVsbCAmJiAodGV4dERpZmYgPyB0ZXh0RGlmZi5tYXBQb3Moa25vd24pIDoga25vd24pID09IHNldC5jaHVua1Bvc1tpXSAmJlxuICAgICAgICAgICAgICAgICEodGV4dERpZmYgPT09IG51bGwgfHwgdGV4dERpZmYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHREaWZmLnRvdWNoZXNSYW5nZShrbm93biwga25vd24gKyBzZXQuY2h1bmtbaV0ubGVuZ3RoKSkpXG4gICAgICAgICAgICAgICAgc2hhcmVkLmFkZChzZXQuY2h1bmtbaV0pO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHNoYXJlZDtcbn1cbmNsYXNzIExheWVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXllciwgc2tpcCwgbWluUG9pbnQsIHJhbmsgPSAwKSB7XG4gICAgICAgIHRoaXMubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgdGhpcy5za2lwID0gc2tpcDtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdldCBlbmRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuZW5kU2lkZSA6IDA7IH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCA9IHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ290b0lubmVyKHBvcywgc2lkZSwgZm9yd2FyZCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5za2lwICYmIHRoaXMuc2tpcC5oYXMobmV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyLmNodW5rRW5kKHRoaXMuY2h1bmtJbmRleCkgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICBuZXh0Lm1heFBvaW50IDwgdGhpcy5taW5Qb2ludCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByYW5nZUluZGV4ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLmZpbmRJbmRleChwb3MgLSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIHNpZGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFmb3J3YXJkIHx8IHRoaXMucmFuZ2VJbmRleCA8IHJhbmdlSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHJhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA9PSB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rUG9zID0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBjaHVuayA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNodW5rUG9zICsgY2h1bmsuZnJvbVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IGNodW5rUG9zICsgY2h1bmsudG9bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gY2h1bmsudmFsdWVbdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJhbmdlSW5kZXgodGhpcy5yYW5nZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWluUG9pbnQgPCAwIHx8IHRoaXMudmFsdWUucG9pbnQgJiYgdGhpcy50byAtIHRoaXMuZnJvbSA+PSB0aGlzLm1pblBvaW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRSYW5nZUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0udmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGggJiYgdGhpcy5za2lwLmhhcyh0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0Q2h1bmsoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCsrO1xuICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tIC0gb3RoZXIuZnJvbSB8fCB0aGlzLnN0YXJ0U2lkZSAtIG90aGVyLnN0YXJ0U2lkZSB8fCB0aGlzLnJhbmsgLSBvdGhlci5yYW5rIHx8XG4gICAgICAgICAgICB0aGlzLnRvIC0gb3RoZXIudG8gfHwgdGhpcy5lbmRTaWRlIC0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG59XG5jbGFzcyBIZWFwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihoZWFwKSB7XG4gICAgICAgIHRoaXMuaGVhcCA9IGhlYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNldHMsIHNraXAgPSBudWxsLCBtaW5Qb2ludCA9IC0xKSB7XG4gICAgICAgIGxldCBoZWFwID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY3VyID0gc2V0c1tpXTsgIWN1ci5pc0VtcHR5OyBjdXIgPSBjdXIubmV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ci5tYXhQb2ludCA+PSBtaW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgaGVhcC5wdXNoKG5ldyBMYXllckN1cnNvcihjdXIsIHNraXAsIG1pblBvaW50LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYXAubGVuZ3RoID09IDEgPyBoZWFwWzBdIDogbmV3IEhlYXBDdXJzb3IoaGVhcCk7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy52YWx1ZS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXAubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0b3AuZnJvbTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9wLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gdG9wLnJhbms7XG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRvcC5uZXh0KCk7XG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgY3VyID0gaGVhcFtpbmRleF07Oykge1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IChpbmRleCA8PCAxKSArIDE7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcbiAgICAgICAgICAgIGNoaWxkID0gaGVhcFtjaGlsZEluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jb21wYXJlKGNoaWxkKSA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgaW5kZXggPSBjaGlsZEluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFNwYW5DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50KSB7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVUbyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZVJhbmsgPSBbXTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgLy8gQSBjdXJyZW50bHkgYWN0aXZlIHBvaW50IHJhbmdlLCBpZiBhbnlcbiAgICAgICAgdGhpcy5wb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRGcm9tID0gMDtcbiAgICAgICAgdGhpcy5wb2ludFJhbmsgPSAwO1xuICAgICAgICB0aGlzLnRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IDA7XG4gICAgICAgIC8vIFRoZSBhbW91bnQgb2Ygb3BlbiBhY3RpdmUgcmFuZ2VzIGF0IHRoZSBzdGFydCBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgIC8vIE5vdCBpbmNsdWRpbmcgcG9pbnRzLlxuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnNvciA9IEhlYXBDdXJzb3IuZnJvbShzZXRzLCBza2lwLCBtaW5Qb2ludCk7XG4gICAgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgdGhpcy5jdXJzb3IuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZS5sZW5ndGggPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCA9IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IC0xO1xuICAgICAgICB0aGlzLnRvID0gcG9zO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1pbkFjdGl2ZSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW3RoaXMubWluQWN0aXZlXSAtIHBvcyB8fCB0aGlzLmFjdGl2ZVt0aGlzLm1pbkFjdGl2ZV0uZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKHRoaXMubWluQWN0aXZlKTtcbiAgICAgICAgdGhpcy5jdXJzb3IuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgIH1cbiAgICByZW1vdmVBY3RpdmUoaW5kZXgpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVRvLCBpbmRleCk7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZVJhbmssIGluZGV4KTtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSBmaW5kTWluSW5kZXgodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICAgIH1cbiAgICBhZGRBY3RpdmUodHJhY2tPcGVuKSB7XG4gICAgICAgIGxldCBpID0gMCwgeyB2YWx1ZSwgdG8sIHJhbmsgfSA9IHRoaXMuY3Vyc29yO1xuICAgICAgICAvLyBPcmdhbml6ZSBhY3RpdmUgbWFya3MgYnkgcmFuayBmaXJzdCwgdGhlbiBieSBzaXplXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiAocmFuayAtIHRoaXMuYWN0aXZlUmFua1tpXSB8fCB0byAtIHRoaXMuYWN0aXZlVG9baV0pID4gMClcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMubWluQWN0aXZlO1xuICAgICAgICAgICAgaWYgKGEgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1thXSAtIHRoaXMuY3Vyc29yLmZyb20gfHwgdGhpcy5hY3RpdmVbYV0uZW5kU2lkZSAtIHRoaXMuY3Vyc29yLnN0YXJ0U2lkZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9bYV0gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmFjdGl2ZVRvW2FdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmFjdGl2ZVthXS5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRyYWNrT3BlbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJzb3IudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5lbmRTaWRlID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yLmZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuY3Vyc29yLmZyb207XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5jdXJzb3Iuc3RhcnRTaWRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWYWwgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRWYWwucG9pbnQpIHsgLy8gT3BlbmluZyBhIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQWN0aXZlKHRyYWNrT3Blbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod2FzUG9pbnQgJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSBub24tZW1wdHkgcG9pbnRzIHRoYXQgZW5kIHByZWNpc2VseSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNrT3Blbikge1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRyYWNrT3Blbi5sZW5ndGggLSAxOyBpID49IDAgJiYgdHJhY2tPcGVuW2ldIDwgZnJvbTsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWN0aXZlRm9yUG9pbnQodG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgICAgIGxldCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVSYW5rW2ldIDwgdGhpcy5wb2ludFJhbmspXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IHRvIHx8IHRoaXMuYWN0aXZlVG9baV0gPT0gdG8gJiYgdGhpcy5hY3RpdmVbaV0uZW5kU2lkZSA+PSB0aGlzLnBvaW50LmVuZFNpZGUpXG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2godGhpcy5hY3RpdmVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBvcGVuRW5kKHRvKSB7XG4gICAgICAgIGxldCBvcGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRoaXMuYWN0aXZlVG9baV0gPiB0bzsgaS0tKVxuICAgICAgICAgICAgb3BlbisrO1xuICAgICAgICByZXR1cm4gb3BlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlKGEsIHN0YXJ0QSwgYiwgc3RhcnRCLCBsZW5ndGgsIGNvbXBhcmF0b3IpIHtcbiAgICBhLmdvdG8oc3RhcnRBKTtcbiAgICBiLmdvdG8oc3RhcnRCKTtcbiAgICBsZXQgZW5kQiA9IHN0YXJ0QiArIGxlbmd0aDtcbiAgICBsZXQgcG9zID0gc3RhcnRCLCBkUG9zID0gc3RhcnRCIC0gc3RhcnRBO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGRFbmQgPSAoYS50byArIGRQb3MpIC0gYi50bywgZGlmZiA9IGRFbmQgfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvKSwgYi5hY3RpdmVGb3JQb2ludChiLnRvKSkpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVBvaW50KHBvcywgY2xpcEVuZCwgYS5wb2ludCwgYi5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xpcEVuZCA+IHBvcyAmJiAhc2FtZVZhbHVlcyhhLmFjdGl2ZSwgYi5hY3RpdmUpKVxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IuY29tcGFyZVJhbmdlKHBvcywgY2xpcEVuZCwgYS5hY3RpdmUsIGIuYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID4gZW5kQilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoKGRFbmQgfHwgYS5vcGVuRW5kICE9IGIub3BlbkVuZCkgJiYgY29tcGFyYXRvci5ib3VuZENoYW5nZSlcbiAgICAgICAgICAgIGNvbXBhcmF0b3IuYm91bmRDaGFuZ2UoZW5kKTtcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICBpZiAoZGlmZiA8PSAwKVxuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lVmFsdWVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0gJiYgIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBlID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA8IGU7IGkrKylcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgYXJyYXkucG9wKCk7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pXG4gICAgICAgIGFycmF5W2kgKyAxXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZE1pbkluZGV4KHZhbHVlLCBhcnJheSkge1xuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKChhcnJheVtpXSAtIGZvdW5kUG9zIHx8IHZhbHVlW2ldLmVuZFNpZGUgLSB2YWx1ZVtmb3VuZF0uZW5kU2lkZSkgPCAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICBmb3VuZFBvcyA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG4vKipcbkNvdW50IHRoZSBjb2x1bW4gcG9zaXRpb24gYXQgdGhlIGdpdmVuIG9mZnNldCBpbnRvIHRoZSBzdHJpbmcsXG50YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC5cbiovXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIHRhYlNpemUsIHRvID0gc3RyaW5nLmxlbmd0aCkge1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvICYmIGkgPCBzdHJpbmcubGVuZ3RoOykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSkge1xuICAgICAgICAgICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBjb2x1bW4gcG9zaXRpb24gaW4gYVxuc3RyaW5nLCB0YWtpbmcgZXh0ZW5kaW5nIGNoYXJhY3RlcnMgYW5kIHRhYiBzaXplIGludG8gYWNjb3VudC4gQnlcbmRlZmF1bHQsIHRoZSBzdHJpbmcgbGVuZ3RoIGlzIHJldHVybmVkIHdoZW4gaXQgaXMgdG9vIHNob3J0IHRvXG5yZWFjaCB0aGUgY29sdW1uLiBQYXNzIGBzdHJpY3RgIHRydWUgdG8gbWFrZSBpdCByZXR1cm4gLTEgaW4gdGhhdFxuc2l0dWF0aW9uLlxuKi9cbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBjb2wsIHRhYlNpemUsIHN0cmljdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gMDs7KSB7XG4gICAgICAgIGlmIChuID49IGNvbClcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBpZiAoaSA9PSBzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG4gKz0gc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSA/IHRhYlNpemUgLSAobiAlIHRhYlNpemUpIDogMTtcbiAgICAgICAgaSA9IGZpbmRDbHVzdGVyQnJlYWsoc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmljdCA9PT0gdHJ1ZSA/IC0xIDogc3RyaW5nLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgQW5ub3RhdGlvbiwgQW5ub3RhdGlvblR5cGUsIENoYW5nZURlc2MsIENoYW5nZVNldCwgQ2hhckNhdGVnb3J5LCBDb21wYXJ0bWVudCwgRWRpdG9yU2VsZWN0aW9uLCBFZGl0b3JTdGF0ZSwgRmFjZXQsIExpbmUsIE1hcE1vZGUsIFByZWMsIFJhbmdlLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBSYW5nZVZhbHVlLCBTZWxlY3Rpb25SYW5nZSwgU3RhdGVFZmZlY3QsIFN0YXRlRWZmZWN0VHlwZSwgU3RhdGVGaWVsZCwgVGV4dCwgVHJhbnNhY3Rpb24sIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBjb3VudENvbHVtbiwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgZnJvbUNvZGVQb2ludCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@codemirror+state@6.5.2/node_modules/@codemirror/state/dist/index.js\n");

/***/ })

};
;